{"ast":null,"code":"import _objectSpread from \"/app/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { document, globalThis } from \"../utils/server-safe-globals.js\";\nimport { AvailabilityStates, StreamTypes, TextTrackKinds } from \"../constants.js\";\nimport { containsComposedNode } from \"../utils/element-utils.js\";\nimport { enterFullscreen, exitFullscreen, isFullscreen } from \"../utils/fullscreen-api.js\";\nimport { airplaySupported, castSupported, fullscreenSupported, hasFullscreenSupport, hasPipSupport, hasVolumeSupportAsync, pipSupported } from \"../utils/platform-tests.js\";\nimport { getShowingSubtitleTracks, getSubtitleTracks, toggleSubtitleTracks } from \"./util.js\";\nimport { getTextTracksList } from \"../utils/captions.js\";\nimport { isValidNumber } from \"../utils/utils.js\";\nconst StreamTypeValues = Object.values(StreamTypes);\nlet volumeSupported;\nconst volumeSupportPromise = hasVolumeSupportAsync().then(supported => {\n  volumeSupported = supported;\n  return volumeSupported;\n});\nconst prepareStateOwners = async function () {\n  for (var _len = arguments.length, stateOwners = new Array(_len), _key = 0; _key < _len; _key++) {\n    stateOwners[_key] = arguments[_key];\n  }\n  await Promise.all(stateOwners.filter(x => x).map(async stateOwner => {\n    if (!(\"localName\" in stateOwner && stateOwner instanceof globalThis.HTMLElement)) {\n      return;\n    }\n    const name = stateOwner.localName;\n    if (!name.includes(\"-\")) return;\n    const classDef = globalThis.customElements.get(name);\n    if (classDef && stateOwner instanceof classDef) return;\n    await globalThis.customElements.whenDefined(name);\n    globalThis.customElements.upgrade(stateOwner);\n  }));\n};\nconst domParser = new globalThis.DOMParser();\nconst parseHtmlToText = text => text ? domParser.parseFromString(text, \"text/html\").body.textContent || text : text;\nconst stateMediator = {\n  mediaError: {\n    get(stateOwners, event) {\n      const {\n        media\n      } = stateOwners;\n      if ((event == null ? void 0 : event.type) === \"playing\") return;\n      return media == null ? void 0 : media.error;\n    },\n    mediaEvents: [\"emptied\", \"error\", \"playing\"]\n  },\n  mediaErrorCode: {\n    get(stateOwners, event) {\n      var _a;\n      const {\n        media\n      } = stateOwners;\n      if ((event == null ? void 0 : event.type) === \"playing\") return;\n      return (_a = media == null ? void 0 : media.error) == null ? void 0 : _a.code;\n    },\n    mediaEvents: [\"emptied\", \"error\", \"playing\"]\n  },\n  mediaErrorMessage: {\n    get(stateOwners, event) {\n      var _a, _b;\n      const {\n        media\n      } = stateOwners;\n      if ((event == null ? void 0 : event.type) === \"playing\") return;\n      return (_b = (_a = media == null ? void 0 : media.error) == null ? void 0 : _a.message) != null ? _b : \"\";\n    },\n    mediaEvents: [\"emptied\", \"error\", \"playing\"]\n  },\n  mediaWidth: {\n    get(stateOwners) {\n      var _a;\n      const {\n        media\n      } = stateOwners;\n      return (_a = media == null ? void 0 : media.videoWidth) != null ? _a : 0;\n    },\n    mediaEvents: [\"resize\"]\n  },\n  mediaHeight: {\n    get(stateOwners) {\n      var _a;\n      const {\n        media\n      } = stateOwners;\n      return (_a = media == null ? void 0 : media.videoHeight) != null ? _a : 0;\n    },\n    mediaEvents: [\"resize\"]\n  },\n  mediaPaused: {\n    get(stateOwners) {\n      var _a;\n      const {\n        media\n      } = stateOwners;\n      return (_a = media == null ? void 0 : media.paused) != null ? _a : true;\n    },\n    set(value, stateOwners) {\n      var _a;\n      const {\n        media\n      } = stateOwners;\n      if (!media) return;\n      if (value) {\n        media.pause();\n      } else {\n        (_a = media.play()) == null ? void 0 : _a.catch(() => {});\n      }\n    },\n    mediaEvents: [\"play\", \"playing\", \"pause\", \"emptied\"]\n  },\n  mediaHasPlayed: {\n    // We want to let the user know that the media started playing at any point (`media-has-played`).\n    // Since these propagators are all called when boostrapping state, let's verify this is\n    // a real playing event by checking that 1) there's media and 2) it isn't currently paused.\n    get(stateOwners, event) {\n      const {\n        media\n      } = stateOwners;\n      if (!media) return false;\n      if (!event) return !media.paused;\n      return event.type === \"playing\";\n    },\n    mediaEvents: [\"playing\", \"emptied\"]\n  },\n  mediaEnded: {\n    get(stateOwners) {\n      var _a;\n      const {\n        media\n      } = stateOwners;\n      return (_a = media == null ? void 0 : media.ended) != null ? _a : false;\n    },\n    mediaEvents: [\"seeked\", \"ended\", \"emptied\"]\n  },\n  mediaPlaybackRate: {\n    get(stateOwners) {\n      var _a;\n      const {\n        media\n      } = stateOwners;\n      return (_a = media == null ? void 0 : media.playbackRate) != null ? _a : 1;\n    },\n    set(value, stateOwners) {\n      const {\n        media\n      } = stateOwners;\n      if (!media) return;\n      if (!Number.isFinite(+value)) return;\n      media.playbackRate = +value;\n    },\n    mediaEvents: [\"ratechange\", \"loadstart\"]\n  },\n  mediaMuted: {\n    get(stateOwners) {\n      var _a;\n      const {\n        media\n      } = stateOwners;\n      return (_a = media == null ? void 0 : media.muted) != null ? _a : false;\n    },\n    set(value, stateOwners) {\n      const {\n        media,\n        options: {\n          noMutedPref\n        } = {}\n      } = stateOwners;\n      if (!media) return;\n      media.muted = value;\n      try {\n        const hasLocalStoragePrefMuted = globalThis.localStorage.getItem(\"media-chrome-pref-muted\") !== null;\n        const hasMutedAttribute = media.hasAttribute(\"muted\");\n        if (noMutedPref) {\n          if (hasLocalStoragePrefMuted) globalThis.localStorage.removeItem(\"media-chrome-pref-muted\");\n          return;\n        }\n        if (hasMutedAttribute && !hasLocalStoragePrefMuted) {\n          return;\n        }\n        globalThis.localStorage.setItem(\"media-chrome-pref-muted\", value ? \"true\" : \"false\");\n      } catch (e) {\n        console.debug(\"Error setting muted pref\", e);\n      }\n    },\n    mediaEvents: [\"volumechange\"],\n    stateOwnersUpdateHandlers: [(handler, stateOwners) => {\n      const {\n        options: {\n          noMutedPref\n        }\n      } = stateOwners;\n      const {\n        media\n      } = stateOwners;\n      if (!media || media.muted || noMutedPref) return;\n      try {\n        const mutedPref = globalThis.localStorage.getItem(\"media-chrome-pref-muted\") === \"true\";\n        stateMediator.mediaMuted.set(mutedPref, stateOwners);\n        handler(mutedPref);\n      } catch (e) {\n        console.debug(\"Error getting muted pref\", e);\n      }\n    }]\n  },\n  mediaLoop: {\n    get(stateOwners) {\n      const {\n        media\n      } = stateOwners;\n      return media == null ? void 0 : media.loop;\n    },\n    set(value, stateOwners) {\n      const {\n        media\n      } = stateOwners;\n      if (!media) return;\n      media.loop = value;\n    },\n    mediaEvents: [\"medialooprequest\"]\n  },\n  mediaVolume: {\n    get(stateOwners) {\n      var _a;\n      const {\n        media\n      } = stateOwners;\n      return (_a = media == null ? void 0 : media.volume) != null ? _a : 1;\n    },\n    set(value, stateOwners) {\n      const {\n        media,\n        options: {\n          noVolumePref\n        } = {}\n      } = stateOwners;\n      if (!media) return;\n      try {\n        if (value == null) {\n          globalThis.localStorage.removeItem(\"media-chrome-pref-volume\");\n        } else if (!media.hasAttribute(\"muted\") && !noVolumePref) {\n          globalThis.localStorage.setItem(\"media-chrome-pref-volume\", value.toString());\n        }\n      } catch (e) {\n        console.debug(\"Error setting volume pref\", e);\n      }\n      if (!Number.isFinite(+value)) return;\n      media.volume = +value;\n    },\n    mediaEvents: [\"volumechange\"],\n    stateOwnersUpdateHandlers: [(handler, stateOwners) => {\n      const {\n        options: {\n          noVolumePref\n        }\n      } = stateOwners;\n      if (noVolumePref) return;\n      try {\n        const {\n          media\n        } = stateOwners;\n        if (!media) return;\n        const volumePref = globalThis.localStorage.getItem(\"media-chrome-pref-volume\");\n        if (volumePref == null) return;\n        stateMediator.mediaVolume.set(+volumePref, stateOwners);\n        handler(+volumePref);\n      } catch (e) {\n        console.debug(\"Error getting volume pref\", e);\n      }\n    }]\n  },\n  // NOTE: Keeping this roughly equivalent to prior impl to reduce number of changes,\n  // however we may want to model \"derived\" state differently from \"primary\" state\n  // (in this case, derived === mediaVolumeLevel, primary === mediaMuted, mediaVolume) (CJP)\n  mediaVolumeLevel: {\n    get(stateOwners) {\n      const {\n        media\n      } = stateOwners;\n      if (typeof (media == null ? void 0 : media.volume) == \"undefined\") return \"high\";\n      if (media.muted || media.volume === 0) return \"off\";\n      if (media.volume < 0.5) return \"low\";\n      if (media.volume < 0.75) return \"medium\";\n      return \"high\";\n    },\n    mediaEvents: [\"volumechange\"]\n  },\n  mediaCurrentTime: {\n    get(stateOwners) {\n      var _a;\n      const {\n        media\n      } = stateOwners;\n      return (_a = media == null ? void 0 : media.currentTime) != null ? _a : 0;\n    },\n    set(value, stateOwners) {\n      const {\n        media\n      } = stateOwners;\n      if (!media || !isValidNumber(value)) return;\n      media.currentTime = value;\n    },\n    mediaEvents: [\"timeupdate\", \"loadedmetadata\"]\n  },\n  mediaDuration: {\n    get(stateOwners) {\n      const {\n        media,\n        options: {\n          defaultDuration\n        } = {}\n      } = stateOwners;\n      if (defaultDuration && (!media || !media.duration || Number.isNaN(media.duration) || !Number.isFinite(media.duration))) {\n        return defaultDuration;\n      }\n      return Number.isFinite(media == null ? void 0 : media.duration) ? media.duration : Number.NaN;\n    },\n    mediaEvents: [\"durationchange\", \"loadedmetadata\", \"emptied\"]\n  },\n  mediaLoading: {\n    get(stateOwners) {\n      const {\n        media\n      } = stateOwners;\n      return (media == null ? void 0 : media.readyState) < 3;\n    },\n    mediaEvents: [\"waiting\", \"playing\", \"emptied\"]\n  },\n  mediaSeekable: {\n    get(stateOwners) {\n      var _a;\n      const {\n        media\n      } = stateOwners;\n      if (!((_a = media == null ? void 0 : media.seekable) == null ? void 0 : _a.length)) return void 0;\n      const start = media.seekable.start(0);\n      const end = media.seekable.end(media.seekable.length - 1);\n      if (!start && !end) return void 0;\n      return [Number(start.toFixed(3)), Number(end.toFixed(3))];\n    },\n    mediaEvents: [\"loadedmetadata\", \"emptied\", \"progress\", \"seekablechange\"]\n  },\n  mediaBuffered: {\n    get(stateOwners) {\n      var _a;\n      const {\n        media\n      } = stateOwners;\n      const timeRanges = (_a = media == null ? void 0 : media.buffered) != null ? _a : [];\n      return Array.from(timeRanges).map((_, i) => [Number(timeRanges.start(i).toFixed(3)), Number(timeRanges.end(i).toFixed(3))]);\n    },\n    mediaEvents: [\"progress\", \"emptied\"]\n  },\n  mediaStreamType: {\n    get(stateOwners) {\n      const {\n        media,\n        options: {\n          defaultStreamType\n        } = {}\n      } = stateOwners;\n      const usedDefaultStreamType = [StreamTypes.LIVE, StreamTypes.ON_DEMAND].includes(defaultStreamType) ? defaultStreamType : void 0;\n      if (!media) return usedDefaultStreamType;\n      const {\n        streamType\n      } = media;\n      if (StreamTypeValues.includes(streamType)) {\n        if (streamType === StreamTypes.UNKNOWN) {\n          return usedDefaultStreamType;\n        }\n        return streamType;\n      }\n      const duration = media.duration;\n      if (duration === Infinity) {\n        return StreamTypes.LIVE;\n      } else if (Number.isFinite(duration)) {\n        return StreamTypes.ON_DEMAND;\n      }\n      return usedDefaultStreamType;\n    },\n    mediaEvents: [\"emptied\", \"durationchange\", \"loadedmetadata\", \"streamtypechange\"]\n  },\n  mediaTargetLiveWindow: {\n    get(stateOwners) {\n      const {\n        media\n      } = stateOwners;\n      if (!media) return Number.NaN;\n      const {\n        targetLiveWindow\n      } = media;\n      const streamType = stateMediator.mediaStreamType.get(stateOwners);\n      if ((targetLiveWindow == null || Number.isNaN(targetLiveWindow)) && streamType === StreamTypes.LIVE) {\n        return 0;\n      }\n      return targetLiveWindow;\n    },\n    mediaEvents: [\"emptied\", \"durationchange\", \"loadedmetadata\", \"streamtypechange\", \"targetlivewindowchange\"]\n  },\n  mediaTimeIsLive: {\n    get(stateOwners) {\n      const {\n        media,\n        // Default to 10 seconds\n        options: {\n          liveEdgeOffset = 10\n        } = {}\n      } = stateOwners;\n      if (!media) return false;\n      if (typeof media.liveEdgeStart === \"number\") {\n        if (Number.isNaN(media.liveEdgeStart)) return false;\n        return media.currentTime >= media.liveEdgeStart;\n      }\n      const live = stateMediator.mediaStreamType.get(stateOwners) === StreamTypes.LIVE;\n      if (!live) return false;\n      const seekable = media.seekable;\n      if (!seekable) return true;\n      if (!seekable.length) return false;\n      const liveEdgeStart = seekable.end(seekable.length - 1) - liveEdgeOffset;\n      return media.currentTime >= liveEdgeStart;\n    },\n    mediaEvents: [\"playing\", \"timeupdate\", \"progress\", \"waiting\", \"emptied\"]\n  },\n  // Text Tracks modeling\n  mediaSubtitlesList: {\n    get(stateOwners) {\n      return getSubtitleTracks(stateOwners).map(_ref => {\n        let {\n          kind,\n          label,\n          language\n        } = _ref;\n        return {\n          kind,\n          label,\n          language\n        };\n      });\n    },\n    mediaEvents: [\"loadstart\"],\n    textTracksEvents: [\"addtrack\", \"removetrack\"]\n  },\n  mediaSubtitlesShowing: {\n    get(stateOwners) {\n      return getShowingSubtitleTracks(stateOwners).map(_ref2 => {\n        let {\n          kind,\n          label,\n          language\n        } = _ref2;\n        return {\n          kind,\n          label,\n          language\n        };\n      });\n    },\n    mediaEvents: [\"loadstart\"],\n    textTracksEvents: [\"addtrack\", \"removetrack\", \"change\"],\n    stateOwnersUpdateHandlers: [(_handler, stateOwners) => {\n      var _a, _b;\n      const {\n        media,\n        options\n      } = stateOwners;\n      if (!media) return;\n      const updateDefaultSubtitlesCallback = event => {\n        var _a2;\n        if (!options.defaultSubtitles) return;\n        const nonSubsEvent = event && ![TextTrackKinds.CAPTIONS, TextTrackKinds.SUBTITLES].includes(\n        // @ts-ignore\n        (_a2 = event == null ? void 0 : event.track) == null ? void 0 : _a2.kind);\n        if (nonSubsEvent) return;\n        toggleSubtitleTracks(stateOwners, true);\n      };\n      media.addEventListener(\"loadstart\", updateDefaultSubtitlesCallback);\n      (_a = media.textTracks) == null ? void 0 : _a.addEventListener(\"addtrack\", updateDefaultSubtitlesCallback);\n      (_b = media.textTracks) == null ? void 0 : _b.addEventListener(\"removetrack\", updateDefaultSubtitlesCallback);\n      return () => {\n        var _a2, _b2;\n        media.removeEventListener(\"loadstart\", updateDefaultSubtitlesCallback);\n        (_a2 = media.textTracks) == null ? void 0 : _a2.removeEventListener(\"addtrack\", updateDefaultSubtitlesCallback);\n        (_b2 = media.textTracks) == null ? void 0 : _b2.removeEventListener(\"removetrack\", updateDefaultSubtitlesCallback);\n      };\n    }]\n  },\n  mediaChaptersCues: {\n    get(stateOwners) {\n      var _a;\n      const {\n        media\n      } = stateOwners;\n      if (!media) return [];\n      const [chaptersTrack] = getTextTracksList(media, {\n        kind: TextTrackKinds.CHAPTERS\n      });\n      return Array.from((_a = chaptersTrack == null ? void 0 : chaptersTrack.cues) != null ? _a : []).map(_ref3 => {\n        let {\n          text,\n          startTime,\n          endTime\n        } = _ref3;\n        return {\n          text: parseHtmlToText(text),\n          startTime,\n          endTime\n        };\n      });\n    },\n    mediaEvents: [\"loadstart\", \"loadedmetadata\"],\n    textTracksEvents: [\"addtrack\", \"removetrack\", \"change\"],\n    stateOwnersUpdateHandlers: [(handler, stateOwners) => {\n      var _a;\n      const {\n        media\n      } = stateOwners;\n      if (!media) return;\n      const chaptersTrack = media.querySelector('track[kind=\"chapters\"][default][src]');\n      const shadowChaptersTrack = (_a = media.shadowRoot) == null ? void 0 : _a.querySelector(':is(video,audio) > track[kind=\"chapters\"][default][src]');\n      chaptersTrack == null ? void 0 : chaptersTrack.addEventListener(\"load\", handler);\n      shadowChaptersTrack == null ? void 0 : shadowChaptersTrack.addEventListener(\"load\", handler);\n      return () => {\n        chaptersTrack == null ? void 0 : chaptersTrack.removeEventListener(\"load\", handler);\n        shadowChaptersTrack == null ? void 0 : shadowChaptersTrack.removeEventListener(\"load\", handler);\n      };\n    }]\n  },\n  // Modeling state tied to root node\n  mediaIsPip: {\n    get(stateOwners) {\n      var _a, _b;\n      const {\n        media,\n        documentElement\n      } = stateOwners;\n      if (!media || !documentElement) return false;\n      if (!documentElement.pictureInPictureElement) return false;\n      if (documentElement.pictureInPictureElement === media) return true;\n      if (documentElement.pictureInPictureElement instanceof HTMLMediaElement) {\n        if (!((_a = media.localName) == null ? void 0 : _a.includes(\"-\"))) return false;\n        return containsComposedNode(media, documentElement.pictureInPictureElement);\n      }\n      if (documentElement.pictureInPictureElement.localName.includes(\"-\")) {\n        let currentRoot = documentElement.pictureInPictureElement.shadowRoot;\n        while (currentRoot == null ? void 0 : currentRoot.pictureInPictureElement) {\n          if (currentRoot.pictureInPictureElement === media) return true;\n          currentRoot = (_b = currentRoot.pictureInPictureElement) == null ? void 0 : _b.shadowRoot;\n        }\n      }\n      return false;\n    },\n    set(value, stateOwners) {\n      const {\n        media\n      } = stateOwners;\n      if (!media) return;\n      if (value) {\n        if (!document.pictureInPictureEnabled) {\n          console.warn(\"MediaChrome: Picture-in-picture is not enabled\");\n          return;\n        }\n        if (!media.requestPictureInPicture) {\n          console.warn(\"MediaChrome: The current media does not support picture-in-picture\");\n          return;\n        }\n        const warnNotReady = () => {\n          console.warn(\"MediaChrome: The media is not ready for picture-in-picture. It must have a readyState > 0.\");\n        };\n        media.requestPictureInPicture().catch(err => {\n          if (err.code === 11) {\n            if (!media.src) {\n              console.warn(\"MediaChrome: The media is not ready for picture-in-picture. It must have a src set.\");\n              return;\n            }\n            if (media.readyState === 0 && media.preload === \"none\") {\n              const cleanup = () => {\n                media.removeEventListener(\"loadedmetadata\", tryPip);\n                media.preload = \"none\";\n              };\n              const tryPip = () => {\n                media.requestPictureInPicture().catch(warnNotReady);\n                cleanup();\n              };\n              media.addEventListener(\"loadedmetadata\", tryPip);\n              media.preload = \"metadata\";\n              setTimeout(() => {\n                if (media.readyState === 0) warnNotReady();\n                cleanup();\n              }, 1e3);\n            } else {\n              throw err;\n            }\n          } else {\n            throw err;\n          }\n        });\n      } else if (document.pictureInPictureElement) {\n        document.exitPictureInPicture();\n      }\n    },\n    mediaEvents: [\"enterpictureinpicture\", \"leavepictureinpicture\"]\n  },\n  mediaRenditionList: {\n    get(stateOwners) {\n      var _a;\n      const {\n        media\n      } = stateOwners;\n      return [...((_a = media == null ? void 0 : media.videoRenditions) != null ? _a : [])].map(videoRendition => _objectSpread({}, videoRendition));\n    },\n    mediaEvents: [\"emptied\", \"loadstart\"],\n    videoRenditionsEvents: [\"addrendition\", \"removerendition\"]\n  },\n  /** @TODO Model this as a derived value? (CJP) */\n  mediaRenditionSelected: {\n    get(stateOwners) {\n      var _a, _b, _c;\n      const {\n        media\n      } = stateOwners;\n      return (_c = (_b = media == null ? void 0 : media.videoRenditions) == null ? void 0 : _b[(_a = media.videoRenditions) == null ? void 0 : _a.selectedIndex]) == null ? void 0 : _c.id;\n    },\n    set(value, stateOwners) {\n      const {\n        media\n      } = stateOwners;\n      if (!(media == null ? void 0 : media.videoRenditions)) {\n        console.warn(\"MediaController: Rendition selection not supported by this media.\");\n        return;\n      }\n      const renditionId = value;\n      const index = Array.prototype.findIndex.call(media.videoRenditions, r => r.id == renditionId);\n      if (media.videoRenditions.selectedIndex != index) {\n        media.videoRenditions.selectedIndex = index;\n      }\n    },\n    mediaEvents: [\"emptied\"],\n    videoRenditionsEvents: [\"addrendition\", \"removerendition\", \"change\"]\n  },\n  mediaAudioTrackList: {\n    get(stateOwners) {\n      var _a;\n      const {\n        media\n      } = stateOwners;\n      return [...((_a = media == null ? void 0 : media.audioTracks) != null ? _a : [])];\n    },\n    mediaEvents: [\"emptied\", \"loadstart\"],\n    audioTracksEvents: [\"addtrack\", \"removetrack\"]\n  },\n  mediaAudioTrackEnabled: {\n    get(stateOwners) {\n      var _a, _b;\n      const {\n        media\n      } = stateOwners;\n      return (_b = [...((_a = media == null ? void 0 : media.audioTracks) != null ? _a : [])].find(audioTrack => audioTrack.enabled)) == null ? void 0 : _b.id;\n    },\n    set(value, stateOwners) {\n      const {\n        media\n      } = stateOwners;\n      if (!(media == null ? void 0 : media.audioTracks)) {\n        console.warn(\"MediaChrome: Audio track selection not supported by this media.\");\n        return;\n      }\n      const audioTrackId = value;\n      for (const track of media.audioTracks) {\n        track.enabled = audioTrackId == track.id;\n      }\n    },\n    mediaEvents: [\"emptied\"],\n    audioTracksEvents: [\"addtrack\", \"removetrack\", \"change\"]\n  },\n  mediaIsFullscreen: {\n    get(stateOwners) {\n      return isFullscreen(stateOwners);\n    },\n    set(value, stateOwners, event) {\n      var _a;\n      if (!value) {\n        exitFullscreen(stateOwners);\n      } else {\n        enterFullscreen(stateOwners);\n        const isPointer = event.detail;\n        if (isPointer) (_a = stateOwners.media) == null ? void 0 : _a.focus();\n      }\n    },\n    // older Safari version may require webkit-specific events\n    rootEvents: [\"fullscreenchange\", \"webkitfullscreenchange\"],\n    // iOS requires webkit-specific events on the video.\n    mediaEvents: [\"webkitbeginfullscreen\", \"webkitendfullscreen\", \"webkitpresentationmodechanged\"]\n  },\n  mediaIsCasting: {\n    // Note this relies on a customized castable-video element.\n    get(stateOwners) {\n      var _a;\n      const {\n        media\n      } = stateOwners;\n      if (!(media == null ? void 0 : media.remote) || ((_a = media.remote) == null ? void 0 : _a.state) === \"disconnected\") return false;\n      return !!media.remote.state;\n    },\n    set(value, stateOwners) {\n      var _a, _b;\n      const {\n        media\n      } = stateOwners;\n      if (!media) return;\n      if (value && ((_a = media.remote) == null ? void 0 : _a.state) !== \"disconnected\") return;\n      if (!value && ((_b = media.remote) == null ? void 0 : _b.state) !== \"connected\") return;\n      if (typeof media.remote.prompt !== \"function\") {\n        console.warn(\"MediaChrome: Casting is not supported in this environment\");\n        return;\n      }\n      media.remote.prompt().catch(() => {});\n    },\n    remoteEvents: [\"connect\", \"connecting\", \"disconnect\"]\n  },\n  // NOTE: Newly added state for tracking airplaying\n  mediaIsAirplaying: {\n    // NOTE: Cannot know if airplaying since Safari doesn't fully support HTMLMediaElement::remote yet (e.g. remote::state) (CJP)\n    get() {\n      return false;\n    },\n    set(_value, stateOwners) {\n      const {\n        media\n      } = stateOwners;\n      if (!media) return;\n      if (!(media.webkitShowPlaybackTargetPicker && globalThis.WebKitPlaybackTargetAvailabilityEvent)) {\n        console.error(\"MediaChrome: received a request to select AirPlay but AirPlay is not supported in this environment\");\n        return;\n      }\n      media.webkitShowPlaybackTargetPicker();\n    },\n    mediaEvents: [\"webkitcurrentplaybacktargetiswirelesschanged\"]\n  },\n  mediaFullscreenUnavailable: {\n    get(stateOwners) {\n      const {\n        media\n      } = stateOwners;\n      if (!fullscreenSupported || !hasFullscreenSupport(media)) return AvailabilityStates.UNSUPPORTED;\n      return void 0;\n    }\n  },\n  mediaPipUnavailable: {\n    get(stateOwners) {\n      const {\n        media\n      } = stateOwners;\n      if (!pipSupported || !hasPipSupport(media)) return AvailabilityStates.UNSUPPORTED;else if (media == null ? void 0 : media.disablePictureInPicture) return AvailabilityStates.UNAVAILABLE;\n      return void 0;\n    }\n  },\n  mediaVolumeUnavailable: {\n    get(stateOwners) {\n      const {\n        media\n      } = stateOwners;\n      if (volumeSupported === false || (media == null ? void 0 : media.volume) == void 0) {\n        return AvailabilityStates.UNSUPPORTED;\n      }\n      return void 0;\n    },\n    // NOTE: Slightly different impl here. Added generic support for\n    // \"stateOwnersUpdateHandlers\" since the original impl had to hack around\n    // race conditions. (CJP)\n    stateOwnersUpdateHandlers: [handler => {\n      if (volumeSupported == null) {\n        volumeSupportPromise.then(supported => handler(supported ? void 0 : AvailabilityStates.UNSUPPORTED));\n      }\n    }]\n  },\n  mediaCastUnavailable: {\n    // @ts-ignore\n    get(stateOwners) {\n      let {\n        availability = \"not-available\"\n      } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var _a;\n      const {\n        media\n      } = stateOwners;\n      if (!castSupported || !((_a = media == null ? void 0 : media.remote) == null ? void 0 : _a.state)) {\n        return AvailabilityStates.UNSUPPORTED;\n      }\n      if (availability == null || availability === \"available\") return void 0;\n      return AvailabilityStates.UNAVAILABLE;\n    },\n    stateOwnersUpdateHandlers: [(handler, stateOwners) => {\n      var _a;\n      const {\n        media\n      } = stateOwners;\n      if (!media) return;\n      const remotePlaybackDisabled = media.disableRemotePlayback || media.hasAttribute(\"disableremoteplayback\");\n      if (!remotePlaybackDisabled) {\n        (_a = media == null ? void 0 : media.remote) == null ? void 0 : _a.watchAvailability(availabilityBool => {\n          const availability = availabilityBool ? \"available\" : \"not-available\";\n          handler({\n            availability\n          });\n        }).catch(error => {\n          if (error.name === \"NotSupportedError\") {\n            handler({\n              availability: null\n            });\n          } else {\n            handler({\n              availability: \"not-available\"\n            });\n          }\n        });\n      }\n      return () => {\n        var _a2;\n        (_a2 = media == null ? void 0 : media.remote) == null ? void 0 : _a2.cancelWatchAvailability().catch(() => {});\n      };\n    }]\n  },\n  mediaAirplayUnavailable: {\n    get(_stateOwners, event) {\n      if (!airplaySupported) return AvailabilityStates.UNSUPPORTED;\n      if ((event == null ? void 0 : event.availability) === \"not-available\") {\n        return AvailabilityStates.UNAVAILABLE;\n      }\n      return void 0;\n    },\n    // NOTE: Keeping this event, as it's still the documented way of monitoring\n    // for AirPlay availability from Apple.\n    // See: https://developer.apple.com/documentation/webkitjs/adding_an_airplay_button_to_your_safari_media_controls#2940021 (CJP)\n    mediaEvents: [\"webkitplaybacktargetavailabilitychanged\"],\n    stateOwnersUpdateHandlers: [(handler, stateOwners) => {\n      var _a;\n      const {\n        media\n      } = stateOwners;\n      if (!media) return;\n      const remotePlaybackDisabled = media.disableRemotePlayback || media.hasAttribute(\"disableremoteplayback\");\n      if (!remotePlaybackDisabled) {\n        (_a = media == null ? void 0 : media.remote) == null ? void 0 : _a.watchAvailability(availabilityBool => {\n          const availability = availabilityBool ? \"available\" : \"not-available\";\n          handler({\n            availability\n          });\n        }).catch(error => {\n          if (error.name === \"NotSupportedError\") {\n            handler({\n              availability: null\n            });\n          } else {\n            handler({\n              availability: \"not-available\"\n            });\n          }\n        });\n      }\n      return () => {\n        var _a2;\n        (_a2 = media == null ? void 0 : media.remote) == null ? void 0 : _a2.cancelWatchAvailability().catch(() => {});\n      };\n    }]\n  },\n  mediaRenditionUnavailable: {\n    get(stateOwners) {\n      var _a;\n      const {\n        media\n      } = stateOwners;\n      if (!(media == null ? void 0 : media.videoRenditions)) {\n        return AvailabilityStates.UNSUPPORTED;\n      }\n      if (!((_a = media.videoRenditions) == null ? void 0 : _a.length)) {\n        return AvailabilityStates.UNAVAILABLE;\n      }\n      return void 0;\n    },\n    mediaEvents: [\"emptied\", \"loadstart\"],\n    videoRenditionsEvents: [\"addrendition\", \"removerendition\"]\n  },\n  mediaAudioTrackUnavailable: {\n    get(stateOwners) {\n      var _a, _b;\n      const {\n        media\n      } = stateOwners;\n      if (!(media == null ? void 0 : media.audioTracks)) {\n        return AvailabilityStates.UNSUPPORTED;\n      }\n      if (((_b = (_a = media.audioTracks) == null ? void 0 : _a.length) != null ? _b : 0) <= 1) {\n        return AvailabilityStates.UNAVAILABLE;\n      }\n      return void 0;\n    },\n    mediaEvents: [\"emptied\", \"loadstart\"],\n    audioTracksEvents: [\"addtrack\", \"removetrack\"]\n  },\n  mediaLang: {\n    get(stateOwners) {\n      const {\n        options: {\n          mediaLang\n        } = {}\n      } = stateOwners;\n      return mediaLang != null ? mediaLang : \"en\";\n    }\n  }\n};\nexport { prepareStateOwners, stateMediator, volumeSupportPromise };","map":{"version":3,"names":["document","globalThis","AvailabilityStates","StreamTypes","TextTrackKinds","containsComposedNode","enterFullscreen","exitFullscreen","isFullscreen","airplaySupported","castSupported","fullscreenSupported","hasFullscreenSupport","hasPipSupport","hasVolumeSupportAsync","pipSupported","getShowingSubtitleTracks","getSubtitleTracks","toggleSubtitleTracks","getTextTracksList","isValidNumber","StreamTypeValues","Object","values","volumeSupported","volumeSupportPromise","then","supported","prepareStateOwners","_len","arguments","length","stateOwners","Array","_key","Promise","all","filter","x","map","stateOwner","HTMLElement","name","localName","includes","classDef","customElements","get","whenDefined","upgrade","domParser","DOMParser","parseHtmlToText","text","parseFromString","body","textContent","stateMediator","mediaError","event","media","type","error","mediaEvents","mediaErrorCode","_a","code","mediaErrorMessage","_b","message","mediaWidth","videoWidth","mediaHeight","videoHeight","mediaPaused","paused","set","value","pause","play","catch","mediaHasPlayed","mediaEnded","ended","mediaPlaybackRate","playbackRate","Number","isFinite","mediaMuted","muted","options","noMutedPref","hasLocalStoragePrefMuted","localStorage","getItem","hasMutedAttribute","hasAttribute","removeItem","setItem","e","console","debug","stateOwnersUpdateHandlers","handler","mutedPref","mediaLoop","loop","mediaVolume","volume","noVolumePref","toString","volumePref","mediaVolumeLevel","mediaCurrentTime","currentTime","mediaDuration","defaultDuration","duration","isNaN","NaN","mediaLoading","readyState","mediaSeekable","seekable","start","end","toFixed","mediaBuffered","timeRanges","buffered","from","_","i","mediaStreamType","defaultStreamType","usedDefaultStreamType","LIVE","ON_DEMAND","streamType","UNKNOWN","Infinity","mediaTargetLiveWindow","targetLiveWindow","mediaTimeIsLive","liveEdgeOffset","liveEdgeStart","live","mediaSubtitlesList","_ref","kind","label","language","textTracksEvents","mediaSubtitlesShowing","_ref2","_handler","updateDefaultSubtitlesCallback","_a2","defaultSubtitles","nonSubsEvent","CAPTIONS","SUBTITLES","track","addEventListener","textTracks","_b2","removeEventListener","mediaChaptersCues","chaptersTrack","CHAPTERS","cues","_ref3","startTime","endTime","querySelector","shadowChaptersTrack","shadowRoot","mediaIsPip","documentElement","pictureInPictureElement","HTMLMediaElement","currentRoot","pictureInPictureEnabled","warn","requestPictureInPicture","warnNotReady","err","src","preload","cleanup","tryPip","setTimeout","exitPictureInPicture","mediaRenditionList","videoRenditions","videoRendition","_objectSpread","videoRenditionsEvents","mediaRenditionSelected","_c","selectedIndex","id","renditionId","index","prototype","findIndex","call","r","mediaAudioTrackList","audioTracks","audioTracksEvents","mediaAudioTrackEnabled","find","audioTrack","enabled","audioTrackId","mediaIsFullscreen","isPointer","detail","focus","rootEvents","mediaIsCasting","remote","state","prompt","remoteEvents","mediaIsAirplaying","_value","webkitShowPlaybackTargetPicker","WebKitPlaybackTargetAvailabilityEvent","mediaFullscreenUnavailable","UNSUPPORTED","mediaPipUnavailable","disablePictureInPicture","UNAVAILABLE","mediaVolumeUnavailable","mediaCastUnavailable","availability","undefined","remotePlaybackDisabled","disableRemotePlayback","watchAvailability","availabilityBool","cancelWatchAvailability","mediaAirplayUnavailable","_stateOwners","mediaRenditionUnavailable","mediaAudioTrackUnavailable","mediaLang"],"sources":["/app/frontend/node_modules/media-chrome/dist/media-store/state-mediator.js"],"sourcesContent":["import { document, globalThis } from \"../utils/server-safe-globals.js\";\nimport {\n  AvailabilityStates,\n  StreamTypes,\n  TextTrackKinds\n} from \"../constants.js\";\nimport { containsComposedNode } from \"../utils/element-utils.js\";\nimport {\n  enterFullscreen,\n  exitFullscreen,\n  isFullscreen\n} from \"../utils/fullscreen-api.js\";\nimport {\n  airplaySupported,\n  castSupported,\n  fullscreenSupported,\n  hasFullscreenSupport,\n  hasPipSupport,\n  hasVolumeSupportAsync,\n  pipSupported\n} from \"../utils/platform-tests.js\";\nimport {\n  getShowingSubtitleTracks,\n  getSubtitleTracks,\n  toggleSubtitleTracks\n} from \"./util.js\";\nimport { getTextTracksList } from \"../utils/captions.js\";\nimport { isValidNumber } from \"../utils/utils.js\";\nconst StreamTypeValues = Object.values(StreamTypes);\nlet volumeSupported;\nconst volumeSupportPromise = hasVolumeSupportAsync().then((supported) => {\n  volumeSupported = supported;\n  return volumeSupported;\n});\nconst prepareStateOwners = async (...stateOwners) => {\n  await Promise.all(\n    stateOwners.filter((x) => x).map(async (stateOwner) => {\n      if (!(\"localName\" in stateOwner && stateOwner instanceof globalThis.HTMLElement)) {\n        return;\n      }\n      const name = stateOwner.localName;\n      if (!name.includes(\"-\"))\n        return;\n      const classDef = globalThis.customElements.get(name);\n      if (classDef && stateOwner instanceof classDef)\n        return;\n      await globalThis.customElements.whenDefined(name);\n      globalThis.customElements.upgrade(stateOwner);\n    })\n  );\n};\nconst domParser = new globalThis.DOMParser();\nconst parseHtmlToText = (text) => text ? domParser.parseFromString(text, \"text/html\").body.textContent || text : text;\nconst stateMediator = {\n  mediaError: {\n    get(stateOwners, event) {\n      const { media } = stateOwners;\n      if ((event == null ? void 0 : event.type) === \"playing\")\n        return;\n      return media == null ? void 0 : media.error;\n    },\n    mediaEvents: [\"emptied\", \"error\", \"playing\"]\n  },\n  mediaErrorCode: {\n    get(stateOwners, event) {\n      var _a;\n      const { media } = stateOwners;\n      if ((event == null ? void 0 : event.type) === \"playing\")\n        return;\n      return (_a = media == null ? void 0 : media.error) == null ? void 0 : _a.code;\n    },\n    mediaEvents: [\"emptied\", \"error\", \"playing\"]\n  },\n  mediaErrorMessage: {\n    get(stateOwners, event) {\n      var _a, _b;\n      const { media } = stateOwners;\n      if ((event == null ? void 0 : event.type) === \"playing\")\n        return;\n      return (_b = (_a = media == null ? void 0 : media.error) == null ? void 0 : _a.message) != null ? _b : \"\";\n    },\n    mediaEvents: [\"emptied\", \"error\", \"playing\"]\n  },\n  mediaWidth: {\n    get(stateOwners) {\n      var _a;\n      const { media } = stateOwners;\n      return (_a = media == null ? void 0 : media.videoWidth) != null ? _a : 0;\n    },\n    mediaEvents: [\"resize\"]\n  },\n  mediaHeight: {\n    get(stateOwners) {\n      var _a;\n      const { media } = stateOwners;\n      return (_a = media == null ? void 0 : media.videoHeight) != null ? _a : 0;\n    },\n    mediaEvents: [\"resize\"]\n  },\n  mediaPaused: {\n    get(stateOwners) {\n      var _a;\n      const { media } = stateOwners;\n      return (_a = media == null ? void 0 : media.paused) != null ? _a : true;\n    },\n    set(value, stateOwners) {\n      var _a;\n      const { media } = stateOwners;\n      if (!media)\n        return;\n      if (value) {\n        media.pause();\n      } else {\n        (_a = media.play()) == null ? void 0 : _a.catch(() => {\n        });\n      }\n    },\n    mediaEvents: [\"play\", \"playing\", \"pause\", \"emptied\"]\n  },\n  mediaHasPlayed: {\n    // We want to let the user know that the media started playing at any point (`media-has-played`).\n    // Since these propagators are all called when boostrapping state, let's verify this is\n    // a real playing event by checking that 1) there's media and 2) it isn't currently paused.\n    get(stateOwners, event) {\n      const { media } = stateOwners;\n      if (!media)\n        return false;\n      if (!event)\n        return !media.paused;\n      return event.type === \"playing\";\n    },\n    mediaEvents: [\"playing\", \"emptied\"]\n  },\n  mediaEnded: {\n    get(stateOwners) {\n      var _a;\n      const { media } = stateOwners;\n      return (_a = media == null ? void 0 : media.ended) != null ? _a : false;\n    },\n    mediaEvents: [\"seeked\", \"ended\", \"emptied\"]\n  },\n  mediaPlaybackRate: {\n    get(stateOwners) {\n      var _a;\n      const { media } = stateOwners;\n      return (_a = media == null ? void 0 : media.playbackRate) != null ? _a : 1;\n    },\n    set(value, stateOwners) {\n      const { media } = stateOwners;\n      if (!media)\n        return;\n      if (!Number.isFinite(+value))\n        return;\n      media.playbackRate = +value;\n    },\n    mediaEvents: [\"ratechange\", \"loadstart\"]\n  },\n  mediaMuted: {\n    get(stateOwners) {\n      var _a;\n      const { media } = stateOwners;\n      return (_a = media == null ? void 0 : media.muted) != null ? _a : false;\n    },\n    set(value, stateOwners) {\n      const { media, options: { noMutedPref } = {} } = stateOwners;\n      if (!media)\n        return;\n      media.muted = value;\n      try {\n        const hasLocalStoragePrefMuted = globalThis.localStorage.getItem(\"media-chrome-pref-muted\") !== null;\n        const hasMutedAttribute = media.hasAttribute(\"muted\");\n        if (noMutedPref) {\n          if (hasLocalStoragePrefMuted)\n            globalThis.localStorage.removeItem(\"media-chrome-pref-muted\");\n          return;\n        }\n        if (hasMutedAttribute && !hasLocalStoragePrefMuted) {\n          return;\n        }\n        globalThis.localStorage.setItem(\n          \"media-chrome-pref-muted\",\n          value ? \"true\" : \"false\"\n        );\n      } catch (e) {\n        console.debug(\"Error setting muted pref\", e);\n      }\n    },\n    mediaEvents: [\"volumechange\"],\n    stateOwnersUpdateHandlers: [\n      (handler, stateOwners) => {\n        const {\n          options: { noMutedPref }\n        } = stateOwners;\n        const { media } = stateOwners;\n        if (!media || media.muted || noMutedPref)\n          return;\n        try {\n          const mutedPref = globalThis.localStorage.getItem(\"media-chrome-pref-muted\") === \"true\";\n          stateMediator.mediaMuted.set(mutedPref, stateOwners);\n          handler(mutedPref);\n        } catch (e) {\n          console.debug(\"Error getting muted pref\", e);\n        }\n      }\n    ]\n  },\n  mediaLoop: {\n    get(stateOwners) {\n      const { media } = stateOwners;\n      return media == null ? void 0 : media.loop;\n    },\n    set(value, stateOwners) {\n      const { media } = stateOwners;\n      if (!media)\n        return;\n      media.loop = value;\n    },\n    mediaEvents: [\"medialooprequest\"]\n  },\n  mediaVolume: {\n    get(stateOwners) {\n      var _a;\n      const { media } = stateOwners;\n      return (_a = media == null ? void 0 : media.volume) != null ? _a : 1;\n    },\n    set(value, stateOwners) {\n      const { media, options: { noVolumePref } = {} } = stateOwners;\n      if (!media)\n        return;\n      try {\n        if (value == null) {\n          globalThis.localStorage.removeItem(\"media-chrome-pref-volume\");\n        } else if (!media.hasAttribute(\"muted\") && !noVolumePref) {\n          globalThis.localStorage.setItem(\n            \"media-chrome-pref-volume\",\n            value.toString()\n          );\n        }\n      } catch (e) {\n        console.debug(\"Error setting volume pref\", e);\n      }\n      if (!Number.isFinite(+value))\n        return;\n      media.volume = +value;\n    },\n    mediaEvents: [\"volumechange\"],\n    stateOwnersUpdateHandlers: [\n      (handler, stateOwners) => {\n        const {\n          options: { noVolumePref }\n        } = stateOwners;\n        if (noVolumePref)\n          return;\n        try {\n          const { media } = stateOwners;\n          if (!media)\n            return;\n          const volumePref = globalThis.localStorage.getItem(\n            \"media-chrome-pref-volume\"\n          );\n          if (volumePref == null)\n            return;\n          stateMediator.mediaVolume.set(+volumePref, stateOwners);\n          handler(+volumePref);\n        } catch (e) {\n          console.debug(\"Error getting volume pref\", e);\n        }\n      }\n    ]\n  },\n  // NOTE: Keeping this roughly equivalent to prior impl to reduce number of changes,\n  // however we may want to model \"derived\" state differently from \"primary\" state\n  // (in this case, derived === mediaVolumeLevel, primary === mediaMuted, mediaVolume) (CJP)\n  mediaVolumeLevel: {\n    get(stateOwners) {\n      const { media } = stateOwners;\n      if (typeof (media == null ? void 0 : media.volume) == \"undefined\")\n        return \"high\";\n      if (media.muted || media.volume === 0)\n        return \"off\";\n      if (media.volume < 0.5)\n        return \"low\";\n      if (media.volume < 0.75)\n        return \"medium\";\n      return \"high\";\n    },\n    mediaEvents: [\"volumechange\"]\n  },\n  mediaCurrentTime: {\n    get(stateOwners) {\n      var _a;\n      const { media } = stateOwners;\n      return (_a = media == null ? void 0 : media.currentTime) != null ? _a : 0;\n    },\n    set(value, stateOwners) {\n      const { media } = stateOwners;\n      if (!media || !isValidNumber(value))\n        return;\n      media.currentTime = value;\n    },\n    mediaEvents: [\"timeupdate\", \"loadedmetadata\"]\n  },\n  mediaDuration: {\n    get(stateOwners) {\n      const { media, options: { defaultDuration } = {} } = stateOwners;\n      if (defaultDuration && (!media || !media.duration || Number.isNaN(media.duration) || !Number.isFinite(media.duration))) {\n        return defaultDuration;\n      }\n      return Number.isFinite(media == null ? void 0 : media.duration) ? media.duration : Number.NaN;\n    },\n    mediaEvents: [\"durationchange\", \"loadedmetadata\", \"emptied\"]\n  },\n  mediaLoading: {\n    get(stateOwners) {\n      const { media } = stateOwners;\n      return (media == null ? void 0 : media.readyState) < 3;\n    },\n    mediaEvents: [\"waiting\", \"playing\", \"emptied\"]\n  },\n  mediaSeekable: {\n    get(stateOwners) {\n      var _a;\n      const { media } = stateOwners;\n      if (!((_a = media == null ? void 0 : media.seekable) == null ? void 0 : _a.length))\n        return void 0;\n      const start = media.seekable.start(0);\n      const end = media.seekable.end(media.seekable.length - 1);\n      if (!start && !end)\n        return void 0;\n      return [Number(start.toFixed(3)), Number(end.toFixed(3))];\n    },\n    mediaEvents: [\"loadedmetadata\", \"emptied\", \"progress\", \"seekablechange\"]\n  },\n  mediaBuffered: {\n    get(stateOwners) {\n      var _a;\n      const { media } = stateOwners;\n      const timeRanges = (_a = media == null ? void 0 : media.buffered) != null ? _a : [];\n      return Array.from(timeRanges).map((_, i) => [\n        Number(timeRanges.start(i).toFixed(3)),\n        Number(timeRanges.end(i).toFixed(3))\n      ]);\n    },\n    mediaEvents: [\"progress\", \"emptied\"]\n  },\n  mediaStreamType: {\n    get(stateOwners) {\n      const { media, options: { defaultStreamType } = {} } = stateOwners;\n      const usedDefaultStreamType = [\n        StreamTypes.LIVE,\n        StreamTypes.ON_DEMAND\n      ].includes(defaultStreamType) ? defaultStreamType : void 0;\n      if (!media)\n        return usedDefaultStreamType;\n      const { streamType } = media;\n      if (StreamTypeValues.includes(streamType)) {\n        if (streamType === StreamTypes.UNKNOWN) {\n          return usedDefaultStreamType;\n        }\n        return streamType;\n      }\n      const duration = media.duration;\n      if (duration === Infinity) {\n        return StreamTypes.LIVE;\n      } else if (Number.isFinite(duration)) {\n        return StreamTypes.ON_DEMAND;\n      }\n      return usedDefaultStreamType;\n    },\n    mediaEvents: [\n      \"emptied\",\n      \"durationchange\",\n      \"loadedmetadata\",\n      \"streamtypechange\"\n    ]\n  },\n  mediaTargetLiveWindow: {\n    get(stateOwners) {\n      const { media } = stateOwners;\n      if (!media)\n        return Number.NaN;\n      const { targetLiveWindow } = media;\n      const streamType = stateMediator.mediaStreamType.get(stateOwners);\n      if ((targetLiveWindow == null || Number.isNaN(targetLiveWindow)) && streamType === StreamTypes.LIVE) {\n        return 0;\n      }\n      return targetLiveWindow;\n    },\n    mediaEvents: [\n      \"emptied\",\n      \"durationchange\",\n      \"loadedmetadata\",\n      \"streamtypechange\",\n      \"targetlivewindowchange\"\n    ]\n  },\n  mediaTimeIsLive: {\n    get(stateOwners) {\n      const {\n        media,\n        // Default to 10 seconds\n        options: { liveEdgeOffset = 10 } = {}\n      } = stateOwners;\n      if (!media)\n        return false;\n      if (typeof media.liveEdgeStart === \"number\") {\n        if (Number.isNaN(media.liveEdgeStart))\n          return false;\n        return media.currentTime >= media.liveEdgeStart;\n      }\n      const live = stateMediator.mediaStreamType.get(stateOwners) === StreamTypes.LIVE;\n      if (!live)\n        return false;\n      const seekable = media.seekable;\n      if (!seekable)\n        return true;\n      if (!seekable.length)\n        return false;\n      const liveEdgeStart = seekable.end(seekable.length - 1) - liveEdgeOffset;\n      return media.currentTime >= liveEdgeStart;\n    },\n    mediaEvents: [\"playing\", \"timeupdate\", \"progress\", \"waiting\", \"emptied\"]\n  },\n  // Text Tracks modeling\n  mediaSubtitlesList: {\n    get(stateOwners) {\n      return getSubtitleTracks(stateOwners).map(\n        ({ kind, label, language }) => ({ kind, label, language })\n      );\n    },\n    mediaEvents: [\"loadstart\"],\n    textTracksEvents: [\"addtrack\", \"removetrack\"]\n  },\n  mediaSubtitlesShowing: {\n    get(stateOwners) {\n      return getShowingSubtitleTracks(stateOwners).map(\n        ({ kind, label, language }) => ({ kind, label, language })\n      );\n    },\n    mediaEvents: [\"loadstart\"],\n    textTracksEvents: [\"addtrack\", \"removetrack\", \"change\"],\n    stateOwnersUpdateHandlers: [\n      (_handler, stateOwners) => {\n        var _a, _b;\n        const { media, options } = stateOwners;\n        if (!media)\n          return;\n        const updateDefaultSubtitlesCallback = (event) => {\n          var _a2;\n          if (!options.defaultSubtitles)\n            return;\n          const nonSubsEvent = event && ![TextTrackKinds.CAPTIONS, TextTrackKinds.SUBTITLES].includes(\n            // @ts-ignore\n            (_a2 = event == null ? void 0 : event.track) == null ? void 0 : _a2.kind\n          );\n          if (nonSubsEvent)\n            return;\n          toggleSubtitleTracks(stateOwners, true);\n        };\n        media.addEventListener(\n          \"loadstart\",\n          updateDefaultSubtitlesCallback\n        );\n        (_a = media.textTracks) == null ? void 0 : _a.addEventListener(\n          \"addtrack\",\n          updateDefaultSubtitlesCallback\n        );\n        (_b = media.textTracks) == null ? void 0 : _b.addEventListener(\n          \"removetrack\",\n          updateDefaultSubtitlesCallback\n        );\n        return () => {\n          var _a2, _b2;\n          media.removeEventListener(\n            \"loadstart\",\n            updateDefaultSubtitlesCallback\n          );\n          (_a2 = media.textTracks) == null ? void 0 : _a2.removeEventListener(\n            \"addtrack\",\n            updateDefaultSubtitlesCallback\n          );\n          (_b2 = media.textTracks) == null ? void 0 : _b2.removeEventListener(\n            \"removetrack\",\n            updateDefaultSubtitlesCallback\n          );\n        };\n      }\n    ]\n  },\n  mediaChaptersCues: {\n    get(stateOwners) {\n      var _a;\n      const { media } = stateOwners;\n      if (!media)\n        return [];\n      const [chaptersTrack] = getTextTracksList(media, {\n        kind: TextTrackKinds.CHAPTERS\n      });\n      return Array.from((_a = chaptersTrack == null ? void 0 : chaptersTrack.cues) != null ? _a : []).map(\n        ({ text, startTime, endTime }) => ({\n          text: parseHtmlToText(text),\n          startTime,\n          endTime\n        })\n      );\n    },\n    mediaEvents: [\"loadstart\", \"loadedmetadata\"],\n    textTracksEvents: [\"addtrack\", \"removetrack\", \"change\"],\n    stateOwnersUpdateHandlers: [\n      (handler, stateOwners) => {\n        var _a;\n        const { media } = stateOwners;\n        if (!media)\n          return;\n        const chaptersTrack = media.querySelector(\n          'track[kind=\"chapters\"][default][src]'\n        );\n        const shadowChaptersTrack = (_a = media.shadowRoot) == null ? void 0 : _a.querySelector(\n          ':is(video,audio) > track[kind=\"chapters\"][default][src]'\n        );\n        chaptersTrack == null ? void 0 : chaptersTrack.addEventListener(\"load\", handler);\n        shadowChaptersTrack == null ? void 0 : shadowChaptersTrack.addEventListener(\"load\", handler);\n        return () => {\n          chaptersTrack == null ? void 0 : chaptersTrack.removeEventListener(\"load\", handler);\n          shadowChaptersTrack == null ? void 0 : shadowChaptersTrack.removeEventListener(\"load\", handler);\n        };\n      }\n    ]\n  },\n  // Modeling state tied to root node\n  mediaIsPip: {\n    get(stateOwners) {\n      var _a, _b;\n      const { media, documentElement } = stateOwners;\n      if (!media || !documentElement)\n        return false;\n      if (!documentElement.pictureInPictureElement)\n        return false;\n      if (documentElement.pictureInPictureElement === media)\n        return true;\n      if (documentElement.pictureInPictureElement instanceof HTMLMediaElement) {\n        if (!((_a = media.localName) == null ? void 0 : _a.includes(\"-\")))\n          return false;\n        return containsComposedNode(\n          media,\n          documentElement.pictureInPictureElement\n        );\n      }\n      if (documentElement.pictureInPictureElement.localName.includes(\"-\")) {\n        let currentRoot = documentElement.pictureInPictureElement.shadowRoot;\n        while (currentRoot == null ? void 0 : currentRoot.pictureInPictureElement) {\n          if (currentRoot.pictureInPictureElement === media)\n            return true;\n          currentRoot = (_b = currentRoot.pictureInPictureElement) == null ? void 0 : _b.shadowRoot;\n        }\n      }\n      return false;\n    },\n    set(value, stateOwners) {\n      const { media } = stateOwners;\n      if (!media)\n        return;\n      if (value) {\n        if (!document.pictureInPictureEnabled) {\n          console.warn(\"MediaChrome: Picture-in-picture is not enabled\");\n          return;\n        }\n        if (!media.requestPictureInPicture) {\n          console.warn(\n            \"MediaChrome: The current media does not support picture-in-picture\"\n          );\n          return;\n        }\n        const warnNotReady = () => {\n          console.warn(\n            \"MediaChrome: The media is not ready for picture-in-picture. It must have a readyState > 0.\"\n          );\n        };\n        media.requestPictureInPicture().catch((err) => {\n          if (err.code === 11) {\n            if (!media.src) {\n              console.warn(\n                \"MediaChrome: The media is not ready for picture-in-picture. It must have a src set.\"\n              );\n              return;\n            }\n            if (media.readyState === 0 && media.preload === \"none\") {\n              const cleanup = () => {\n                media.removeEventListener(\"loadedmetadata\", tryPip);\n                media.preload = \"none\";\n              };\n              const tryPip = () => {\n                media.requestPictureInPicture().catch(warnNotReady);\n                cleanup();\n              };\n              media.addEventListener(\"loadedmetadata\", tryPip);\n              media.preload = \"metadata\";\n              setTimeout(() => {\n                if (media.readyState === 0)\n                  warnNotReady();\n                cleanup();\n              }, 1e3);\n            } else {\n              throw err;\n            }\n          } else {\n            throw err;\n          }\n        });\n      } else if (document.pictureInPictureElement) {\n        document.exitPictureInPicture();\n      }\n    },\n    mediaEvents: [\"enterpictureinpicture\", \"leavepictureinpicture\"]\n  },\n  mediaRenditionList: {\n    get(stateOwners) {\n      var _a;\n      const { media } = stateOwners;\n      return [...(_a = media == null ? void 0 : media.videoRenditions) != null ? _a : []].map((videoRendition) => ({\n        ...videoRendition\n      }));\n    },\n    mediaEvents: [\"emptied\", \"loadstart\"],\n    videoRenditionsEvents: [\"addrendition\", \"removerendition\"]\n  },\n  /** @TODO Model this as a derived value? (CJP) */\n  mediaRenditionSelected: {\n    get(stateOwners) {\n      var _a, _b, _c;\n      const { media } = stateOwners;\n      return (_c = (_b = media == null ? void 0 : media.videoRenditions) == null ? void 0 : _b[(_a = media.videoRenditions) == null ? void 0 : _a.selectedIndex]) == null ? void 0 : _c.id;\n    },\n    set(value, stateOwners) {\n      const { media } = stateOwners;\n      if (!(media == null ? void 0 : media.videoRenditions)) {\n        console.warn(\n          \"MediaController: Rendition selection not supported by this media.\"\n        );\n        return;\n      }\n      const renditionId = value;\n      const index = Array.prototype.findIndex.call(\n        media.videoRenditions,\n        (r) => r.id == renditionId\n      );\n      if (media.videoRenditions.selectedIndex != index) {\n        media.videoRenditions.selectedIndex = index;\n      }\n    },\n    mediaEvents: [\"emptied\"],\n    videoRenditionsEvents: [\"addrendition\", \"removerendition\", \"change\"]\n  },\n  mediaAudioTrackList: {\n    get(stateOwners) {\n      var _a;\n      const { media } = stateOwners;\n      return [...(_a = media == null ? void 0 : media.audioTracks) != null ? _a : []];\n    },\n    mediaEvents: [\"emptied\", \"loadstart\"],\n    audioTracksEvents: [\"addtrack\", \"removetrack\"]\n  },\n  mediaAudioTrackEnabled: {\n    get(stateOwners) {\n      var _a, _b;\n      const { media } = stateOwners;\n      return (_b = [...(_a = media == null ? void 0 : media.audioTracks) != null ? _a : []].find(\n        (audioTrack) => audioTrack.enabled\n      )) == null ? void 0 : _b.id;\n    },\n    set(value, stateOwners) {\n      const { media } = stateOwners;\n      if (!(media == null ? void 0 : media.audioTracks)) {\n        console.warn(\n          \"MediaChrome: Audio track selection not supported by this media.\"\n        );\n        return;\n      }\n      const audioTrackId = value;\n      for (const track of media.audioTracks) {\n        track.enabled = audioTrackId == track.id;\n      }\n    },\n    mediaEvents: [\"emptied\"],\n    audioTracksEvents: [\"addtrack\", \"removetrack\", \"change\"]\n  },\n  mediaIsFullscreen: {\n    get(stateOwners) {\n      return isFullscreen(stateOwners);\n    },\n    set(value, stateOwners, event) {\n      var _a;\n      if (!value) {\n        exitFullscreen(stateOwners);\n      } else {\n        enterFullscreen(stateOwners);\n        const isPointer = event.detail;\n        if (isPointer)\n          (_a = stateOwners.media) == null ? void 0 : _a.focus();\n      }\n    },\n    // older Safari version may require webkit-specific events\n    rootEvents: [\"fullscreenchange\", \"webkitfullscreenchange\"],\n    // iOS requires webkit-specific events on the video.\n    mediaEvents: [\n      \"webkitbeginfullscreen\",\n      \"webkitendfullscreen\",\n      \"webkitpresentationmodechanged\"\n    ]\n  },\n  mediaIsCasting: {\n    // Note this relies on a customized castable-video element.\n    get(stateOwners) {\n      var _a;\n      const { media } = stateOwners;\n      if (!(media == null ? void 0 : media.remote) || ((_a = media.remote) == null ? void 0 : _a.state) === \"disconnected\")\n        return false;\n      return !!media.remote.state;\n    },\n    set(value, stateOwners) {\n      var _a, _b;\n      const { media } = stateOwners;\n      if (!media)\n        return;\n      if (value && ((_a = media.remote) == null ? void 0 : _a.state) !== \"disconnected\")\n        return;\n      if (!value && ((_b = media.remote) == null ? void 0 : _b.state) !== \"connected\")\n        return;\n      if (typeof media.remote.prompt !== \"function\") {\n        console.warn(\n          \"MediaChrome: Casting is not supported in this environment\"\n        );\n        return;\n      }\n      media.remote.prompt().catch(() => {\n      });\n    },\n    remoteEvents: [\"connect\", \"connecting\", \"disconnect\"]\n  },\n  // NOTE: Newly added state for tracking airplaying\n  mediaIsAirplaying: {\n    // NOTE: Cannot know if airplaying since Safari doesn't fully support HTMLMediaElement::remote yet (e.g. remote::state) (CJP)\n    get() {\n      return false;\n    },\n    set(_value, stateOwners) {\n      const { media } = stateOwners;\n      if (!media)\n        return;\n      if (!(media.webkitShowPlaybackTargetPicker && globalThis.WebKitPlaybackTargetAvailabilityEvent)) {\n        console.error(\n          \"MediaChrome: received a request to select AirPlay but AirPlay is not supported in this environment\"\n        );\n        return;\n      }\n      media.webkitShowPlaybackTargetPicker();\n    },\n    mediaEvents: [\"webkitcurrentplaybacktargetiswirelesschanged\"]\n  },\n  mediaFullscreenUnavailable: {\n    get(stateOwners) {\n      const { media } = stateOwners;\n      if (!fullscreenSupported || !hasFullscreenSupport(media))\n        return AvailabilityStates.UNSUPPORTED;\n      return void 0;\n    }\n  },\n  mediaPipUnavailable: {\n    get(stateOwners) {\n      const { media } = stateOwners;\n      if (!pipSupported || !hasPipSupport(media))\n        return AvailabilityStates.UNSUPPORTED;\n      else if (media == null ? void 0 : media.disablePictureInPicture)\n        return AvailabilityStates.UNAVAILABLE;\n      return void 0;\n    }\n  },\n  mediaVolumeUnavailable: {\n    get(stateOwners) {\n      const { media } = stateOwners;\n      if (volumeSupported === false || (media == null ? void 0 : media.volume) == void 0) {\n        return AvailabilityStates.UNSUPPORTED;\n      }\n      return void 0;\n    },\n    // NOTE: Slightly different impl here. Added generic support for\n    // \"stateOwnersUpdateHandlers\" since the original impl had to hack around\n    // race conditions. (CJP)\n    stateOwnersUpdateHandlers: [\n      (handler) => {\n        if (volumeSupported == null) {\n          volumeSupportPromise.then(\n            (supported) => handler(supported ? void 0 : AvailabilityStates.UNSUPPORTED)\n          );\n        }\n      }\n    ]\n  },\n  mediaCastUnavailable: {\n    // @ts-ignore\n    get(stateOwners, { availability = \"not-available\" } = {}) {\n      var _a;\n      const { media } = stateOwners;\n      if (!castSupported || !((_a = media == null ? void 0 : media.remote) == null ? void 0 : _a.state)) {\n        return AvailabilityStates.UNSUPPORTED;\n      }\n      if (availability == null || availability === \"available\")\n        return void 0;\n      return AvailabilityStates.UNAVAILABLE;\n    },\n    stateOwnersUpdateHandlers: [\n      (handler, stateOwners) => {\n        var _a;\n        const { media } = stateOwners;\n        if (!media)\n          return;\n        const remotePlaybackDisabled = media.disableRemotePlayback || media.hasAttribute(\"disableremoteplayback\");\n        if (!remotePlaybackDisabled) {\n          (_a = media == null ? void 0 : media.remote) == null ? void 0 : _a.watchAvailability((availabilityBool) => {\n            const availability = availabilityBool ? \"available\" : \"not-available\";\n            handler({ availability });\n          }).catch((error) => {\n            if (error.name === \"NotSupportedError\") {\n              handler({ availability: null });\n            } else {\n              handler({ availability: \"not-available\" });\n            }\n          });\n        }\n        return () => {\n          var _a2;\n          (_a2 = media == null ? void 0 : media.remote) == null ? void 0 : _a2.cancelWatchAvailability().catch(() => {\n          });\n        };\n      }\n    ]\n  },\n  mediaAirplayUnavailable: {\n    get(_stateOwners, event) {\n      if (!airplaySupported)\n        return AvailabilityStates.UNSUPPORTED;\n      if ((event == null ? void 0 : event.availability) === \"not-available\") {\n        return AvailabilityStates.UNAVAILABLE;\n      }\n      return void 0;\n    },\n    // NOTE: Keeping this event, as it's still the documented way of monitoring\n    // for AirPlay availability from Apple.\n    // See: https://developer.apple.com/documentation/webkitjs/adding_an_airplay_button_to_your_safari_media_controls#2940021 (CJP)\n    mediaEvents: [\"webkitplaybacktargetavailabilitychanged\"],\n    stateOwnersUpdateHandlers: [\n      (handler, stateOwners) => {\n        var _a;\n        const { media } = stateOwners;\n        if (!media)\n          return;\n        const remotePlaybackDisabled = media.disableRemotePlayback || media.hasAttribute(\"disableremoteplayback\");\n        if (!remotePlaybackDisabled) {\n          (_a = media == null ? void 0 : media.remote) == null ? void 0 : _a.watchAvailability((availabilityBool) => {\n            const availability = availabilityBool ? \"available\" : \"not-available\";\n            handler({ availability });\n          }).catch((error) => {\n            if (error.name === \"NotSupportedError\") {\n              handler({ availability: null });\n            } else {\n              handler({ availability: \"not-available\" });\n            }\n          });\n        }\n        return () => {\n          var _a2;\n          (_a2 = media == null ? void 0 : media.remote) == null ? void 0 : _a2.cancelWatchAvailability().catch(() => {\n          });\n        };\n      }\n    ]\n  },\n  mediaRenditionUnavailable: {\n    get(stateOwners) {\n      var _a;\n      const { media } = stateOwners;\n      if (!(media == null ? void 0 : media.videoRenditions)) {\n        return AvailabilityStates.UNSUPPORTED;\n      }\n      if (!((_a = media.videoRenditions) == null ? void 0 : _a.length)) {\n        return AvailabilityStates.UNAVAILABLE;\n      }\n      return void 0;\n    },\n    mediaEvents: [\"emptied\", \"loadstart\"],\n    videoRenditionsEvents: [\"addrendition\", \"removerendition\"]\n  },\n  mediaAudioTrackUnavailable: {\n    get(stateOwners) {\n      var _a, _b;\n      const { media } = stateOwners;\n      if (!(media == null ? void 0 : media.audioTracks)) {\n        return AvailabilityStates.UNSUPPORTED;\n      }\n      if (((_b = (_a = media.audioTracks) == null ? void 0 : _a.length) != null ? _b : 0) <= 1) {\n        return AvailabilityStates.UNAVAILABLE;\n      }\n      return void 0;\n    },\n    mediaEvents: [\"emptied\", \"loadstart\"],\n    audioTracksEvents: [\"addtrack\", \"removetrack\"]\n  },\n  mediaLang: {\n    get(stateOwners) {\n      const { options: { mediaLang } = {} } = stateOwners;\n      return mediaLang != null ? mediaLang : \"en\";\n    }\n  }\n};\nexport {\n  prepareStateOwners,\n  stateMediator,\n  volumeSupportPromise\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}