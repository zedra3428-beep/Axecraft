{"ast":null,"code":"\"use client\";\n\nimport { jsx } from 'react/jsx-runtime';\nimport { isHTMLElement } from 'motion-dom';\nimport * as React from 'react';\nimport { useId, useRef, useContext, useInsertionEffect } from 'react';\nimport { MotionConfigContext } from '../../context/MotionConfigContext.mjs';\nimport { useComposedRefs } from '../../utils/use-composed-ref.mjs';\n\n/**\n * Measurement functionality has to be within a separate component\n * to leverage snapshot lifecycle.\n */\nclass PopChildMeasure extends React.Component {\n  getSnapshotBeforeUpdate(prevProps) {\n    const element = this.props.childRef.current;\n    if (element && prevProps.isPresent && !this.props.isPresent) {\n      const parent = element.offsetParent;\n      const parentWidth = isHTMLElement(parent) ? parent.offsetWidth || 0 : 0;\n      const size = this.props.sizeRef.current;\n      size.height = element.offsetHeight || 0;\n      size.width = element.offsetWidth || 0;\n      size.top = element.offsetTop;\n      size.left = element.offsetLeft;\n      size.right = parentWidth - size.width - size.left;\n    }\n    return null;\n  }\n  /**\n   * Required with getSnapshotBeforeUpdate to stop React complaining.\n   */\n  componentDidUpdate() {}\n  render() {\n    return this.props.children;\n  }\n}\nfunction PopChild(_ref) {\n  var _children$props$ref, _children$props;\n  let {\n    children,\n    isPresent,\n    anchorX,\n    root\n  } = _ref;\n  const id = useId();\n  const ref = useRef(null);\n  const size = useRef({\n    width: 0,\n    height: 0,\n    top: 0,\n    left: 0,\n    right: 0\n  });\n  const {\n    nonce\n  } = useContext(MotionConfigContext);\n  /**\n   * In React 19, refs are passed via props.ref instead of element.ref.\n   * We check props.ref first (React 19) and fall back to element.ref (React 18).\n   */\n  const childRef = (_children$props$ref = (_children$props = children.props) === null || _children$props === void 0 ? void 0 : _children$props.ref) !== null && _children$props$ref !== void 0 ? _children$props$ref : children === null || children === void 0 ? void 0 : children.ref;\n  const composedRef = useComposedRefs(ref, childRef);\n  /**\n   * We create and inject a style block so we can apply this explicit\n   * sizing in a non-destructive manner by just deleting the style block.\n   *\n   * We can't apply size via render as the measurement happens\n   * in getSnapshotBeforeUpdate (post-render), likewise if we apply the\n   * styles directly on the DOM node, we might be overwriting\n   * styles set via the style prop.\n   */\n  useInsertionEffect(() => {\n    const {\n      width,\n      height,\n      top,\n      left,\n      right\n    } = size.current;\n    if (isPresent || !ref.current || !width || !height) return;\n    const x = anchorX === \"left\" ? \"left: \".concat(left) : \"right: \".concat(right);\n    ref.current.dataset.motionPopId = id;\n    const style = document.createElement(\"style\");\n    if (nonce) style.nonce = nonce;\n    const parent = root !== null && root !== void 0 ? root : document.head;\n    parent.appendChild(style);\n    if (style.sheet) {\n      style.sheet.insertRule(\"\\n          [data-motion-pop-id=\\\"\".concat(id, \"\\\"] {\\n            position: absolute !important;\\n            width: \").concat(width, \"px !important;\\n            height: \").concat(height, \"px !important;\\n            \").concat(x, \"px !important;\\n            top: \").concat(top, \"px !important;\\n          }\\n        \"));\n    }\n    return () => {\n      if (parent.contains(style)) {\n        parent.removeChild(style);\n      }\n    };\n  }, [isPresent]);\n  return jsx(PopChildMeasure, {\n    isPresent: isPresent,\n    childRef: ref,\n    sizeRef: size,\n    children: React.cloneElement(children, {\n      ref: composedRef\n    })\n  });\n}\nexport { PopChild };","map":{"version":3,"names":["PopChildMeasure","React","Component","getSnapshotBeforeUpdate","prevProps","element","isPresent","props","parent","offsetParent","parentWidth","isHTMLElement","offsetWidth","size","top","offsetTop","left","offsetLeft","right","width","componentDidUpdate","children","PopChild","_ref","_children$props$ref","_children$props","anchorX","root","id","useId","ref","useRef","height","childRef","current","x","concat","nonce","style","document","head","appendChild","sheet","insertRule","contains","removeChild","jsx","sizeRef","cloneElement","composedRef"],"sources":["/app/frontend/node_modules/framer-motion/src/components/AnimatePresence/PopChild.tsx"],"sourcesContent":["\"use client\"\n\nimport { isHTMLElement } from \"motion-dom\"\nimport * as React from \"react\"\nimport { useContext, useId, useInsertionEffect, useRef } from \"react\"\n\nimport { MotionConfigContext } from \"../../context/MotionConfigContext\"\nimport { useComposedRefs } from \"../../utils/use-composed-ref\"\n\ninterface Size {\n    width: number\n    height: number\n    top: number\n    left: number\n    right: number\n}\n\ninterface Props {\n    children: React.ReactElement\n    isPresent: boolean\n    anchorX?: \"left\" | \"right\"\n    root?: HTMLElement | ShadowRoot\n}\n\ninterface MeasureProps extends Props {\n    childRef: React.RefObject<HTMLElement | null>\n    sizeRef: React.RefObject<Size>\n}\n\n/**\n * Measurement functionality has to be within a separate component\n * to leverage snapshot lifecycle.\n */\nclass PopChildMeasure extends React.Component<MeasureProps> {\n    getSnapshotBeforeUpdate(prevProps: MeasureProps) {\n        const element = this.props.childRef.current\n        if (element && prevProps.isPresent && !this.props.isPresent) {\n            const parent = element.offsetParent\n            const parentWidth = isHTMLElement(parent)\n                ? parent.offsetWidth || 0\n                : 0\n\n            const size = this.props.sizeRef.current!\n            size.height = element.offsetHeight || 0\n            size.width = element.offsetWidth || 0\n            size.top = element.offsetTop\n            size.left = element.offsetLeft\n            size.right = parentWidth - size.width - size.left\n        }\n\n        return null\n    }\n\n    /**\n     * Required with getSnapshotBeforeUpdate to stop React complaining.\n     */\n    componentDidUpdate() {}\n\n    render() {\n        return this.props.children\n    }\n}\n\nexport function PopChild({ children, isPresent, anchorX, root }: Props) {\n    const id = useId()\n    const ref = useRef<HTMLElement>(null)\n    const size = useRef<Size>({\n        width: 0,\n        height: 0,\n        top: 0,\n        left: 0,\n        right: 0,\n    })\n    const { nonce } = useContext(MotionConfigContext)\n    /**\n     * In React 19, refs are passed via props.ref instead of element.ref.\n     * We check props.ref first (React 19) and fall back to element.ref (React 18).\n     */\n    const childRef =\n        (children.props as { ref?: React.Ref<HTMLElement> })?.ref ??\n        (children as unknown as { ref?: React.Ref<HTMLElement> })?.ref\n    const composedRef = useComposedRefs(ref, childRef)\n\n    /**\n     * We create and inject a style block so we can apply this explicit\n     * sizing in a non-destructive manner by just deleting the style block.\n     *\n     * We can't apply size via render as the measurement happens\n     * in getSnapshotBeforeUpdate (post-render), likewise if we apply the\n     * styles directly on the DOM node, we might be overwriting\n     * styles set via the style prop.\n     */\n    useInsertionEffect(() => {\n        const { width, height, top, left, right } = size.current\n        if (isPresent || !ref.current || !width || !height) return\n\n        const x = anchorX === \"left\" ? `left: ${left}` : `right: ${right}`\n\n        ref.current.dataset.motionPopId = id\n\n        const style = document.createElement(\"style\")\n        if (nonce) style.nonce = nonce\n\n        const parent = root ?? document.head\n        parent.appendChild(style)\n\n        if (style.sheet) {\n            style.sheet.insertRule(`\n          [data-motion-pop-id=\"${id}\"] {\n            position: absolute !important;\n            width: ${width}px !important;\n            height: ${height}px !important;\n            ${x}px !important;\n            top: ${top}px !important;\n          }\n        `)\n        }\n\n        return () => {\n            if (parent.contains(style)) {\n                parent.removeChild(style)\n            }\n        }\n    }, [isPresent])\n\n    return (\n        <PopChildMeasure isPresent={isPresent} childRef={ref} sizeRef={size}>\n            {React.cloneElement(children as any, { ref: composedRef })}\n        </PopChildMeasure>\n    )\n}\n"],"mappings":";;;;;;;;;AA6BA;;;AAGG;AACH,MAAAA,eAAA,SAAAC,KAAA,CAAAC,SAAA;EACIC,wBAAAC,SAAA;;IAEI,IAAAC,OAAA,IAAAD,SAAA,CAAAE,SAAA,UAAAC,KAAA,CAAAD,SAAA;MACI,MAAAE,MAAA,GAAAH,OAAA,CAAAI,YAAA;MACA,MAAAC,WAAA,GAAAC,aAAA,CAAAH,MAAA,IACIA,MAAA,CAAAI,WAAA,Q;;;;MAMJC,IAAA,CAAAC,GAAA,GAAAT,OAAA,CAAAU,SAAA;MACAF,IAAA,CAAAG,IAAA,GAAAX,OAAA,CAAAY,UAAA;MACAJ,IAAA,CAAAK,KAAA,GAAAR,WAAA,GAAAG,IAAA,CAAAM,KAAA,GAAAN,IAAA,CAAAG,IAAA;;IAGJ;;EAGJ;;AAEG;EACHI,mBAAA;;IAGI,YAAAb,KAAA,CAAAc,QAAA;;AAEP;AAEK,SAAAC,SAAAC,IAAA;EAAA,IAAAC,mBAAA,EAAAC,eAAA;EAAA;IAAAJ,QAAA;IAAAf,SAAA;IAAAoB,OAAA;IAAAC;EAAA,IAAAJ,IAAA;EACF,MAAAK,EAAA,GAAAC,KAAA;EACA,MAAAC,GAAA,GAAAC,MAAA;;IAEIZ,KAAA;IACAa,MAAA;IACAlB,GAAA;IACAE,IAAA;IACAE,KAAA;EACH;;;;EAED;;;AAGG;EACH,MAAAe,QAAA,IAAAT,mBAAA,IAAAC,eAAA,GAAAJ,QAAA,CAAAd,KAAA,cAAAkB,eAAA,uBAAAA,eAAA,CAAAK,GAAA,cAAAN,mBAAA,cAAAA,mBAAA,G;;EAKA;;;;;;;;AAQG;;IAEC;MAAAL,KAAA;MAAAa,MAAA;MAAAlB,GAAA;MAAAE,IAAA;MAAAE;IAAA,IAAAL,IAAA,CAAAqB,OAAA;;IAGA,MAAAC,CAAA,GAAAT,OAAA,uBAAAU,MAAA,CAAApB,IAAA,cAAAoB,MAAA,CAAAlB,KAAA;;;IAKA,IAAAmB,KAAA,EAAWC,KAAA,CAAAD,KAAA,GAAAA,KAAA;IAEX,MAAA7B,MAAA,GAAAmB,IAAA,aAAAA,IAAA,cAAAA,IAAA,GAAAY,QAAA,CAAAC,IAAA;IACAhC,MAAA,CAAAiC,WAAA,CAAAH,KAAA;IAEA,IAAAA,KAAA,CAAAI,KAAA;MACIJ,KAAA,CAAAI,KAAA,CAAAC,UAAA,sCAAAP,MAAA,C,sRAQH;;IAGD;MACI,IAAA5B,MAAA,CAAAoC,QAAA,CAAAN,KAAA;QACI9B,MAAA,CAAAqC,WAAA,CAAAP,KAAA;;IAER;EACJ,IAAAhC,SAAA;EAEA,OAAAwC,GAAA,CAAA9C,eAAA;IAAAM,SAAA,EAAAA,SAAA;IAAA2B,QAAA,EAAAH,GAAA;IAAAiB,OAAA,EAAAlC,IAAA;IAAAQ,QAAA,EAAApB,KAAA,CAAA+C,YAAA,CAAA3B,QAAA;MAAAS,GAAA,EAAAmB;IAAA;EAAA;AAKJ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}