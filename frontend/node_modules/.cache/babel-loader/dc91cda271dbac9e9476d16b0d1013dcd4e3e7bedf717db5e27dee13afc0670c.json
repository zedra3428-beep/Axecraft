{"ast":null,"code":"import { KeyframeResolver, time, frame, isMotionValue, cancelFrame, transformProps, motionValue, findValueType, complex, getAnimatableNone, microtask } from 'motion-dom';\nimport { warnOnce, isNumericalString, isZeroValueString, SubscriptionManager } from 'motion-utils';\nimport { featureDefinitions } from '../motion/features/definitions.mjs';\nimport { createBox } from '../projection/geometry/models.mjs';\nimport { initPrefersReducedMotion } from '../utils/reduced-motion/index.mjs';\nimport { hasReducedMotionListener, prefersReducedMotion } from '../utils/reduced-motion/state.mjs';\nimport { visualElementStore } from './store.mjs';\nimport { isControllingVariants, isVariantNode } from './utils/is-controlling-variants.mjs';\nimport { updateMotionValuesFromProps } from './utils/motion-values.mjs';\nimport { resolveVariantFromProps } from './utils/resolve-variants.mjs';\nconst propEventHandlers = [\"AnimationStart\", \"AnimationComplete\", \"Update\", \"BeforeLayoutMeasure\", \"LayoutMeasure\", \"LayoutAnimationStart\", \"LayoutAnimationComplete\"];\n/**\n * A VisualElement is an imperative abstraction around UI elements such as\n * HTMLElement, SVGElement, Three.Object3D etc.\n */\nclass VisualElement {\n  /**\n   * This method takes React props and returns found MotionValues. For example, HTML\n   * MotionValues will be found within the style prop, whereas for Three.js within attribute arrays.\n   *\n   * This isn't an abstract method as it needs calling in the constructor, but it is\n   * intended to be one.\n   */\n  scrapeMotionValuesFromProps(_props, _prevProps, _visualElement) {\n    return {};\n  }\n  constructor({\n    parent,\n    props,\n    presenceContext,\n    reducedMotionConfig,\n    blockInitialAnimation,\n    visualState\n  }, options = {}) {\n    /**\n     * A reference to the current underlying Instance, e.g. a HTMLElement\n     * or Three.Mesh etc.\n     */\n    this.current = null;\n    /**\n     * A set containing references to this VisualElement's children.\n     */\n    this.children = new Set();\n    /**\n     * Determine what role this visual element should take in the variant tree.\n     */\n    this.isVariantNode = false;\n    this.isControllingVariants = false;\n    /**\n     * Decides whether this VisualElement should animate in reduced motion\n     * mode.\n     *\n     * TODO: This is currently set on every individual VisualElement but feels\n     * like it could be set globally.\n     */\n    this.shouldReduceMotion = null;\n    /**\n     * A map of all motion values attached to this visual element. Motion\n     * values are source of truth for any given animated value. A motion\n     * value might be provided externally by the component via props.\n     */\n    this.values = new Map();\n    this.KeyframeResolver = KeyframeResolver;\n    /**\n     * Cleanup functions for active features (hover/tap/exit etc)\n     */\n    this.features = {};\n    /**\n     * A map of every subscription that binds the provided or generated\n     * motion values onChange listeners to this visual element.\n     */\n    this.valueSubscriptions = new Map();\n    /**\n     * A reference to the previously-provided motion values as returned\n     * from scrapeMotionValuesFromProps. We use the keys in here to determine\n     * if any motion values need to be removed after props are updated.\n     */\n    this.prevMotionValues = {};\n    /**\n     * An object containing a SubscriptionManager for each active event.\n     */\n    this.events = {};\n    /**\n     * An object containing an unsubscribe function for each prop event subscription.\n     * For example, every \"Update\" event can have multiple subscribers via\n     * VisualElement.on(), but only one of those can be defined via the onUpdate prop.\n     */\n    this.propEventSubscriptions = {};\n    this.notifyUpdate = () => this.notify(\"Update\", this.latestValues);\n    this.render = () => {\n      if (!this.current) return;\n      this.triggerBuild();\n      this.renderInstance(this.current, this.renderState, this.props.style, this.projection);\n    };\n    this.renderScheduledAt = 0.0;\n    this.scheduleRender = () => {\n      const now = time.now();\n      if (this.renderScheduledAt < now) {\n        this.renderScheduledAt = now;\n        frame.render(this.render, false, true);\n      }\n    };\n    const {\n      latestValues,\n      renderState\n    } = visualState;\n    this.latestValues = latestValues;\n    this.baseTarget = {\n      ...latestValues\n    };\n    this.initialValues = props.initial ? {\n      ...latestValues\n    } : {};\n    this.renderState = renderState;\n    this.parent = parent;\n    this.props = props;\n    this.presenceContext = presenceContext;\n    this.depth = parent ? parent.depth + 1 : 0;\n    this.reducedMotionConfig = reducedMotionConfig;\n    this.options = options;\n    this.blockInitialAnimation = Boolean(blockInitialAnimation);\n    this.isControllingVariants = isControllingVariants(props);\n    this.isVariantNode = isVariantNode(props);\n    if (this.isVariantNode) {\n      this.variantChildren = new Set();\n    }\n    this.manuallyAnimateOnMount = Boolean(parent && parent.current);\n    /**\n     * Any motion values that are provided to the element when created\n     * aren't yet bound to the element, as this would technically be impure.\n     * However, we iterate through the motion values and set them to the\n     * initial values for this component.\n     *\n     * TODO: This is impure and we should look at changing this to run on mount.\n     * Doing so will break some tests but this isn't necessarily a breaking change,\n     * more a reflection of the test.\n     */\n    const {\n      willChange,\n      ...initialMotionValues\n    } = this.scrapeMotionValuesFromProps(props, {}, this);\n    for (const key in initialMotionValues) {\n      const value = initialMotionValues[key];\n      if (latestValues[key] !== undefined && isMotionValue(value)) {\n        value.set(latestValues[key]);\n      }\n    }\n  }\n  mount(instance) {\n    this.current = instance;\n    visualElementStore.set(instance, this);\n    if (this.projection && !this.projection.instance) {\n      this.projection.mount(instance);\n    }\n    if (this.parent && this.isVariantNode && !this.isControllingVariants) {\n      this.removeFromVariantTree = this.parent.addVariantChild(this);\n    }\n    this.values.forEach((value, key) => this.bindToMotionValue(key, value));\n    /**\n     * Determine reduced motion preference. Only initialize the matchMedia\n     * listener if we actually need the dynamic value (i.e., when config\n     * is neither \"never\" nor \"always\").\n     */\n    if (this.reducedMotionConfig === \"never\") {\n      this.shouldReduceMotion = false;\n    } else if (this.reducedMotionConfig === \"always\") {\n      this.shouldReduceMotion = true;\n    } else {\n      if (!hasReducedMotionListener.current) {\n        initPrefersReducedMotion();\n      }\n      this.shouldReduceMotion = prefersReducedMotion.current;\n    }\n    if (process.env.NODE_ENV !== \"production\") {\n      warnOnce(this.shouldReduceMotion !== true, \"You have Reduced Motion enabled on your device. Animations may not appear as expected.\", \"reduced-motion-disabled\");\n    }\n    this.parent?.addChild(this);\n    this.update(this.props, this.presenceContext);\n  }\n  unmount() {\n    this.projection && this.projection.unmount();\n    cancelFrame(this.notifyUpdate);\n    cancelFrame(this.render);\n    this.valueSubscriptions.forEach(remove => remove());\n    this.valueSubscriptions.clear();\n    this.removeFromVariantTree && this.removeFromVariantTree();\n    this.parent?.removeChild(this);\n    for (const key in this.events) {\n      this.events[key].clear();\n    }\n    for (const key in this.features) {\n      const feature = this.features[key];\n      if (feature) {\n        feature.unmount();\n        feature.isMounted = false;\n      }\n    }\n    this.current = null;\n  }\n  addChild(child) {\n    this.children.add(child);\n    this.enteringChildren ?? (this.enteringChildren = new Set());\n    this.enteringChildren.add(child);\n  }\n  removeChild(child) {\n    this.children.delete(child);\n    this.enteringChildren && this.enteringChildren.delete(child);\n  }\n  bindToMotionValue(key, value) {\n    if (this.valueSubscriptions.has(key)) {\n      this.valueSubscriptions.get(key)();\n    }\n    const valueIsTransform = transformProps.has(key);\n    if (valueIsTransform && this.onBindTransform) {\n      this.onBindTransform();\n    }\n    const removeOnChange = value.on(\"change\", latestValue => {\n      this.latestValues[key] = latestValue;\n      this.props.onUpdate && frame.preRender(this.notifyUpdate);\n      if (valueIsTransform && this.projection) {\n        this.projection.isTransformDirty = true;\n      }\n      this.scheduleRender();\n    });\n    let removeSyncCheck;\n    if (window.MotionCheckAppearSync) {\n      removeSyncCheck = window.MotionCheckAppearSync(this, key, value);\n    }\n    this.valueSubscriptions.set(key, () => {\n      removeOnChange();\n      if (removeSyncCheck) removeSyncCheck();\n      if (value.owner) value.stop();\n    });\n  }\n  sortNodePosition(other) {\n    /**\n     * If these nodes aren't even of the same type we can't compare their depth.\n     */\n    if (!this.current || !this.sortInstanceNodePosition || this.type !== other.type) {\n      return 0;\n    }\n    return this.sortInstanceNodePosition(this.current, other.current);\n  }\n  updateFeatures() {\n    let key = \"animation\";\n    for (key in featureDefinitions) {\n      const featureDefinition = featureDefinitions[key];\n      if (!featureDefinition) continue;\n      const {\n        isEnabled,\n        Feature: FeatureConstructor\n      } = featureDefinition;\n      /**\n       * If this feature is enabled but not active, make a new instance.\n       */\n      if (!this.features[key] && FeatureConstructor && isEnabled(this.props)) {\n        this.features[key] = new FeatureConstructor(this);\n      }\n      /**\n       * If we have a feature, mount or update it.\n       */\n      if (this.features[key]) {\n        const feature = this.features[key];\n        if (feature.isMounted) {\n          feature.update();\n        } else {\n          feature.mount();\n          feature.isMounted = true;\n        }\n      }\n    }\n  }\n  triggerBuild() {\n    this.build(this.renderState, this.latestValues, this.props);\n  }\n  /**\n   * Measure the current viewport box with or without transforms.\n   * Only measures axis-aligned boxes, rotate and skew must be manually\n   * removed with a re-render to work.\n   */\n  measureViewportBox() {\n    return this.current ? this.measureInstanceViewportBox(this.current, this.props) : createBox();\n  }\n  getStaticValue(key) {\n    return this.latestValues[key];\n  }\n  setStaticValue(key, value) {\n    this.latestValues[key] = value;\n  }\n  /**\n   * Update the provided props. Ensure any newly-added motion values are\n   * added to our map, old ones removed, and listeners updated.\n   */\n  update(props, presenceContext) {\n    if (props.transformTemplate || this.props.transformTemplate) {\n      this.scheduleRender();\n    }\n    this.prevProps = this.props;\n    this.props = props;\n    this.prevPresenceContext = this.presenceContext;\n    this.presenceContext = presenceContext;\n    /**\n     * Update prop event handlers ie onAnimationStart, onAnimationComplete\n     */\n    for (let i = 0; i < propEventHandlers.length; i++) {\n      const key = propEventHandlers[i];\n      if (this.propEventSubscriptions[key]) {\n        this.propEventSubscriptions[key]();\n        delete this.propEventSubscriptions[key];\n      }\n      const listenerName = \"on\" + key;\n      const listener = props[listenerName];\n      if (listener) {\n        this.propEventSubscriptions[key] = this.on(key, listener);\n      }\n    }\n    this.prevMotionValues = updateMotionValuesFromProps(this, this.scrapeMotionValuesFromProps(props, this.prevProps, this), this.prevMotionValues);\n    if (this.handleChildMotionValue) {\n      this.handleChildMotionValue();\n    }\n  }\n  getProps() {\n    return this.props;\n  }\n  /**\n   * Returns the variant definition with a given name.\n   */\n  getVariant(name) {\n    return this.props.variants ? this.props.variants[name] : undefined;\n  }\n  /**\n   * Returns the defined default transition on this component.\n   */\n  getDefaultTransition() {\n    return this.props.transition;\n  }\n  getTransformPagePoint() {\n    return this.props.transformPagePoint;\n  }\n  getClosestVariantNode() {\n    return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : undefined;\n  }\n  /**\n   * Add a child visual element to our set of children.\n   */\n  addVariantChild(child) {\n    const closestVariantNode = this.getClosestVariantNode();\n    if (closestVariantNode) {\n      closestVariantNode.variantChildren && closestVariantNode.variantChildren.add(child);\n      return () => closestVariantNode.variantChildren.delete(child);\n    }\n  }\n  /**\n   * Add a motion value and bind it to this visual element.\n   */\n  addValue(key, value) {\n    // Remove existing value if it exists\n    const existingValue = this.values.get(key);\n    if (value !== existingValue) {\n      if (existingValue) this.removeValue(key);\n      this.bindToMotionValue(key, value);\n      this.values.set(key, value);\n      this.latestValues[key] = value.get();\n    }\n  }\n  /**\n   * Remove a motion value and unbind any active subscriptions.\n   */\n  removeValue(key) {\n    this.values.delete(key);\n    const unsubscribe = this.valueSubscriptions.get(key);\n    if (unsubscribe) {\n      unsubscribe();\n      this.valueSubscriptions.delete(key);\n    }\n    delete this.latestValues[key];\n    this.removeValueFromRenderState(key, this.renderState);\n  }\n  /**\n   * Check whether we have a motion value for this key\n   */\n  hasValue(key) {\n    return this.values.has(key);\n  }\n  getValue(key, defaultValue) {\n    if (this.props.values && this.props.values[key]) {\n      return this.props.values[key];\n    }\n    let value = this.values.get(key);\n    if (value === undefined && defaultValue !== undefined) {\n      value = motionValue(defaultValue === null ? undefined : defaultValue, {\n        owner: this\n      });\n      this.addValue(key, value);\n    }\n    return value;\n  }\n  /**\n   * If we're trying to animate to a previously unencountered value,\n   * we need to check for it in our state and as a last resort read it\n   * directly from the instance (which might have performance implications).\n   */\n  readValue(key, target) {\n    let value = this.latestValues[key] !== undefined || !this.current ? this.latestValues[key] : this.getBaseTargetFromProps(this.props, key) ?? this.readValueFromInstance(this.current, key, this.options);\n    if (value !== undefined && value !== null) {\n      if (typeof value === \"string\" && (isNumericalString(value) || isZeroValueString(value))) {\n        // If this is a number read as a string, ie \"0\" or \"200\", convert it to a number\n        value = parseFloat(value);\n      } else if (!findValueType(value) && complex.test(target)) {\n        value = getAnimatableNone(key, target);\n      }\n      this.setBaseTarget(key, isMotionValue(value) ? value.get() : value);\n    }\n    return isMotionValue(value) ? value.get() : value;\n  }\n  /**\n   * Set the base target to later animate back to. This is currently\n   * only hydrated on creation and when we first read a value.\n   */\n  setBaseTarget(key, value) {\n    this.baseTarget[key] = value;\n  }\n  /**\n   * Find the base target for a value thats been removed from all animation\n   * props.\n   */\n  getBaseTarget(key) {\n    const {\n      initial\n    } = this.props;\n    let valueFromInitial;\n    if (typeof initial === \"string\" || typeof initial === \"object\") {\n      const variant = resolveVariantFromProps(this.props, initial, this.presenceContext?.custom);\n      if (variant) {\n        valueFromInitial = variant[key];\n      }\n    }\n    /**\n     * If this value still exists in the current initial variant, read that.\n     */\n    if (initial && valueFromInitial !== undefined) {\n      return valueFromInitial;\n    }\n    /**\n     * Alternatively, if this VisualElement config has defined a getBaseTarget\n     * so we can read the value from an alternative source, try that.\n     */\n    const target = this.getBaseTargetFromProps(this.props, key);\n    if (target !== undefined && !isMotionValue(target)) return target;\n    /**\n     * If the value was initially defined on initial, but it doesn't any more,\n     * return undefined. Otherwise return the value as initially read from the DOM.\n     */\n    return this.initialValues[key] !== undefined && valueFromInitial === undefined ? undefined : this.baseTarget[key];\n  }\n  on(eventName, callback) {\n    if (!this.events[eventName]) {\n      this.events[eventName] = new SubscriptionManager();\n    }\n    return this.events[eventName].add(callback);\n  }\n  notify(eventName, ...args) {\n    if (this.events[eventName]) {\n      this.events[eventName].notify(...args);\n    }\n  }\n  scheduleRenderMicrotask() {\n    microtask.render(this.render);\n  }\n}\nexport { VisualElement };","map":{"version":3,"names":["propEventHandlers","VisualElement","scrapeMotionValuesFromProps","_props","_prevProps","_visualElement","constructor","parent","props","presenceContext","reducedMotionConfig","blockInitialAnimation","visualState","options","current","children","Set","isVariantNode","isControllingVariants","shouldReduceMotion","values","Map","KeyframeResolver","features","valueSubscriptions","prevMotionValues","events","propEventSubscriptions","notifyUpdate","notify","latestValues","render","triggerBuild","renderInstance","renderState","style","projection","renderScheduledAt","scheduleRender","now","time","frame","baseTarget","initialValues","initial","depth","Boolean","variantChildren","manuallyAnimateOnMount","willChange","initialMotionValues","key","value","undefined","isMotionValue","set","mount","instance","visualElementStore","removeFromVariantTree","addVariantChild","forEach","bindToMotionValue","hasReducedMotionListener","initPrefersReducedMotion","prefersReducedMotion","process","env","NODE_ENV","warnOnce","addChild","update","unmount","cancelFrame","remove","clear","removeChild","feature","isMounted","child","add","enteringChildren","delete","has","get","valueIsTransform","transformProps","onBindTransform","removeOnChange","on","latestValue","onUpdate","preRender","isTransformDirty","removeSyncCheck","window","MotionCheckAppearSync","owner","stop","sortNodePosition","other","sortInstanceNodePosition","type","updateFeatures","featureDefinitions","featureDefinition","isEnabled","Feature","FeatureConstructor","build","measureViewportBox","measureInstanceViewportBox","createBox","getStaticValue","setStaticValue","transformTemplate","prevProps","prevPresenceContext","i","length","listenerName","listener","updateMotionValuesFromProps","handleChildMotionValue","getProps","getVariant","name","variants","getDefaultTransition","transition","getTransformPagePoint","transformPagePoint","getClosestVariantNode","closestVariantNode","addValue","existingValue","removeValue","unsubscribe","removeValueFromRenderState","hasValue","getValue","defaultValue","motionValue","readValue","target","getBaseTargetFromProps","readValueFromInstance","isNumericalString","isZeroValueString","parseFloat","findValueType","complex","test","getAnimatableNone","setBaseTarget","getBaseTarget","valueFromInitial","variant","resolveVariantFromProps","custom","eventName","callback","SubscriptionManager","args","scheduleRenderMicrotask","microtask"],"sources":["/app/frontend/node_modules/framer-motion/src/render/VisualElement.ts"],"sourcesContent":["import {\n    cancelFrame,\n    complex,\n    findValueType,\n    frame,\n    getAnimatableNone,\n    isMotionValue,\n    KeyframeResolver,\n    microtask,\n    motionValue,\n    time,\n    transformProps,\n    type AnyResolvedKeyframe,\n    type MotionValue,\n} from \"motion-dom\"\nimport type { Box } from \"motion-utils\"\nimport {\n    isNumericalString,\n    isZeroValueString,\n    SubscriptionManager,\n    warnOnce,\n} from \"motion-utils\"\nimport {\n    MotionConfigContext,\n    ReducedMotionConfig,\n} from \"../context/MotionConfigContext\"\nimport type { PresenceContextProps } from \"../context/PresenceContext\"\nimport { featureDefinitions } from \"../motion/features/definitions\"\nimport { Feature } from \"../motion/features/Feature\"\nimport { FeatureDefinitions } from \"../motion/features/types\"\nimport { MotionProps, MotionStyle } from \"../motion/types\"\nimport { createBox } from \"../projection/geometry/models\"\nimport { IProjectionNode } from \"../projection/node/types\"\nimport { initPrefersReducedMotion } from \"../utils/reduced-motion\"\nimport {\n    hasReducedMotionListener,\n    prefersReducedMotion,\n} from \"../utils/reduced-motion/state\"\nimport { visualElementStore } from \"./store\"\nimport {\n    ResolvedValues,\n    VisualElementEventCallbacks,\n    VisualElementOptions,\n} from \"./types\"\nimport { AnimationState } from \"./utils/animation-state\"\nimport {\n    isControllingVariants as checkIsControllingVariants,\n    isVariantNode as checkIsVariantNode,\n} from \"./utils/is-controlling-variants\"\nimport { updateMotionValuesFromProps } from \"./utils/motion-values\"\nimport { resolveVariantFromProps } from \"./utils/resolve-variants\"\n\nconst propEventHandlers = [\n    \"AnimationStart\",\n    \"AnimationComplete\",\n    \"Update\",\n    \"BeforeLayoutMeasure\",\n    \"LayoutMeasure\",\n    \"LayoutAnimationStart\",\n    \"LayoutAnimationComplete\",\n] as const\n\n/**\n * A VisualElement is an imperative abstraction around UI elements such as\n * HTMLElement, SVGElement, Three.Object3D etc.\n */\nexport abstract class VisualElement<\n    Instance = unknown,\n    RenderState = unknown,\n    Options extends {} = {}\n> {\n    /**\n     * VisualElements are arranged in trees mirroring that of the React tree.\n     * Each type of VisualElement has a unique name, to detect when we're crossing\n     * type boundaries within that tree.\n     */\n    abstract type: string\n\n    /**\n     * An `Array.sort` compatible function that will compare two Instances and\n     * compare their respective positions within the tree.\n     */\n    abstract sortInstanceNodePosition(a: Instance, b: Instance): number\n\n    /**\n     * Measure the viewport-relative bounding box of the Instance.\n     */\n    abstract measureInstanceViewportBox(\n        instance: Instance,\n        props: MotionProps & Partial<MotionConfigContext>\n    ): Box\n\n    /**\n     * When a value has been removed from all animation props we need to\n     * pick a target to animate back to. For instance, for HTMLElements\n     * we can look in the style prop.\n     */\n    abstract getBaseTargetFromProps(\n        props: MotionProps,\n        key: string\n    ): AnyResolvedKeyframe | undefined | MotionValue\n\n    /**\n     * When we first animate to a value we need to animate it *from* a value.\n     * Often this have been specified via the initial prop but it might be\n     * that the value needs to be read from the Instance.\n     */\n    abstract readValueFromInstance(\n        instance: Instance,\n        key: string,\n        options: Options\n    ): AnyResolvedKeyframe | null | undefined\n\n    /**\n     * When a value has been removed from the VisualElement we use this to remove\n     * it from the inherting class' unique render state.\n     */\n    abstract removeValueFromRenderState(\n        key: string,\n        renderState: RenderState\n    ): void\n\n    /**\n     * Run before a React or VisualElement render, builds the latest motion\n     * values into an Instance-specific format. For example, HTMLVisualElement\n     * will use this step to build `style` and `var` values.\n     */\n    abstract build(\n        renderState: RenderState,\n        latestValues: ResolvedValues,\n        props: MotionProps\n    ): void\n\n    /**\n     * Apply the built values to the Instance. For example, HTMLElements will have\n     * styles applied via `setProperty` and the style attribute, whereas SVGElements\n     * will have values applied to attributes.\n     */\n    abstract renderInstance(\n        instance: Instance,\n        renderState: RenderState,\n        styleProp?: MotionStyle,\n        projection?: IProjectionNode\n    ): void\n\n    /**\n     * This method is called when a transform property is bound to a motion value.\n     * It's currently used to measure SVG elements when a new transform property is bound.\n     */\n    onBindTransform?(): void\n\n    /**\n     * If the component child is provided as a motion value, handle subscriptions\n     * with the renderer-specific VisualElement.\n     */\n    handleChildMotionValue?(): void\n\n    /**\n     * This method takes React props and returns found MotionValues. For example, HTML\n     * MotionValues will be found within the style prop, whereas for Three.js within attribute arrays.\n     *\n     * This isn't an abstract method as it needs calling in the constructor, but it is\n     * intended to be one.\n     */\n    scrapeMotionValuesFromProps(\n        _props: MotionProps,\n        _prevProps: MotionProps,\n        _visualElement: VisualElement\n    ): {\n        [key: string]: MotionValue | AnyResolvedKeyframe\n    } {\n        return {}\n    }\n\n    /**\n     * A reference to the current underlying Instance, e.g. a HTMLElement\n     * or Three.Mesh etc.\n     */\n    current: Instance | null = null\n\n    /**\n     * A reference to the parent VisualElement (if exists).\n     */\n    parent: VisualElement | undefined\n\n    /**\n     * A set containing references to this VisualElement's children.\n     */\n    children = new Set<VisualElement>()\n\n    /**\n     * A set containing the latest children of this VisualElement. This is flushed\n     * at the start of every commit. We use it to calculate the stagger delay\n     * for newly-added children.\n     */\n    enteringChildren?: Set<VisualElement>\n\n    /**\n     * The depth of this VisualElement within the overall VisualElement tree.\n     */\n    depth: number\n\n    /**\n     * The current render state of this VisualElement. Defined by inherting VisualElements.\n     */\n    renderState: RenderState\n\n    /**\n     * An object containing the latest static values for each of this VisualElement's\n     * MotionValues.\n     */\n    latestValues: ResolvedValues\n\n    /**\n     * Determine what role this visual element should take in the variant tree.\n     */\n    isVariantNode: boolean = false\n    isControllingVariants: boolean = false\n\n    /**\n     * If this component is part of the variant tree, it should track\n     * any children that are also part of the tree. This is essentially\n     * a shadow tree to simplify logic around how to stagger over children.\n     */\n    variantChildren?: Set<VisualElement>\n\n    /**\n     * Decides whether this VisualElement should animate in reduced motion\n     * mode.\n     *\n     * TODO: This is currently set on every individual VisualElement but feels\n     * like it could be set globally.\n     */\n    shouldReduceMotion: boolean | null = null\n\n    /**\n     * Normally, if a component is controlled by a parent's variants, it can\n     * rely on that ancestor to trigger animations further down the tree.\n     * However, if a component is created after its parent is mounted, the parent\n     * won't trigger that mount animation so the child needs to.\n     *\n     * TODO: This might be better replaced with a method isParentMounted\n     */\n    manuallyAnimateOnMount: boolean\n\n    /**\n     * This can be set by AnimatePresence to force components that mount\n     * at the same time as it to mount as if they have initial={false} set.\n     */\n    blockInitialAnimation: boolean\n\n    /**\n     * A reference to this VisualElement's projection node, used in layout animations.\n     */\n    projection?: IProjectionNode\n\n    /**\n     * A map of all motion values attached to this visual element. Motion\n     * values are source of truth for any given animated value. A motion\n     * value might be provided externally by the component via props.\n     */\n    values = new Map<string, MotionValue>()\n\n    /**\n     * The AnimationState, this is hydrated by the animation Feature.\n     */\n    animationState?: AnimationState\n\n    KeyframeResolver = KeyframeResolver\n\n    /**\n     * The options used to create this VisualElement. The Options type is defined\n     * by the inheriting VisualElement and is passed straight through to the render functions.\n     */\n    readonly options: Options\n\n    /**\n     * A reference to the latest props provided to the VisualElement's host React component.\n     */\n    props: MotionProps\n    prevProps?: MotionProps\n\n    presenceContext: PresenceContextProps | null\n    prevPresenceContext?: PresenceContextProps | null\n\n    /**\n     * Cleanup functions for active features (hover/tap/exit etc)\n     */\n    private features: {\n        [K in keyof FeatureDefinitions]?: Feature<Instance>\n    } = {}\n\n    /**\n     * A map of every subscription that binds the provided or generated\n     * motion values onChange listeners to this visual element.\n     */\n    private valueSubscriptions = new Map<string, VoidFunction>()\n\n    /**\n     * A reference to the ReducedMotionConfig passed to the VisualElement's host React component.\n     */\n    private reducedMotionConfig: ReducedMotionConfig | undefined\n\n    /**\n     * On mount, this will be hydrated with a callback to disconnect\n     * this visual element from its parent on unmount.\n     */\n    private removeFromVariantTree: undefined | VoidFunction\n\n    /**\n     * A reference to the previously-provided motion values as returned\n     * from scrapeMotionValuesFromProps. We use the keys in here to determine\n     * if any motion values need to be removed after props are updated.\n     */\n    private prevMotionValues: MotionStyle = {}\n\n    /**\n     * When values are removed from all animation props we need to search\n     * for a fallback value to animate to. These values are tracked in baseTarget.\n     */\n    private baseTarget: ResolvedValues\n\n    /**\n     * Create an object of the values we initially animated from (if initial prop present).\n     */\n    private initialValues: ResolvedValues\n\n    /**\n     * An object containing a SubscriptionManager for each active event.\n     */\n    private events: {\n        [key: string]: SubscriptionManager<any>\n    } = {}\n\n    /**\n     * An object containing an unsubscribe function for each prop event subscription.\n     * For example, every \"Update\" event can have multiple subscribers via\n     * VisualElement.on(), but only one of those can be defined via the onUpdate prop.\n     */\n    private propEventSubscriptions: {\n        [key: string]: VoidFunction\n    } = {}\n\n    constructor(\n        {\n            parent,\n            props,\n            presenceContext,\n            reducedMotionConfig,\n            blockInitialAnimation,\n            visualState,\n        }: VisualElementOptions<Instance, RenderState>,\n        options: Options = {} as any\n    ) {\n        const { latestValues, renderState } = visualState\n        this.latestValues = latestValues\n        this.baseTarget = { ...latestValues }\n        this.initialValues = props.initial ? { ...latestValues } : {}\n        this.renderState = renderState\n        this.parent = parent\n        this.props = props\n        this.presenceContext = presenceContext\n        this.depth = parent ? parent.depth + 1 : 0\n        this.reducedMotionConfig = reducedMotionConfig\n        this.options = options\n        this.blockInitialAnimation = Boolean(blockInitialAnimation)\n\n        this.isControllingVariants = checkIsControllingVariants(props)\n        this.isVariantNode = checkIsVariantNode(props)\n        if (this.isVariantNode) {\n            this.variantChildren = new Set()\n        }\n\n        this.manuallyAnimateOnMount = Boolean(parent && parent.current)\n\n        /**\n         * Any motion values that are provided to the element when created\n         * aren't yet bound to the element, as this would technically be impure.\n         * However, we iterate through the motion values and set them to the\n         * initial values for this component.\n         *\n         * TODO: This is impure and we should look at changing this to run on mount.\n         * Doing so will break some tests but this isn't necessarily a breaking change,\n         * more a reflection of the test.\n         */\n        const { willChange, ...initialMotionValues } =\n            this.scrapeMotionValuesFromProps(props, {}, this)\n\n        for (const key in initialMotionValues) {\n            const value = initialMotionValues[key]\n\n            if (latestValues[key] !== undefined && isMotionValue(value)) {\n                value.set(latestValues[key])\n            }\n        }\n    }\n\n    mount(instance: Instance) {\n        this.current = instance\n\n        visualElementStore.set(instance, this)\n\n        if (this.projection && !this.projection.instance) {\n            this.projection.mount(instance)\n        }\n\n        if (this.parent && this.isVariantNode && !this.isControllingVariants) {\n            this.removeFromVariantTree = this.parent.addVariantChild(this)\n        }\n\n        this.values.forEach((value, key) => this.bindToMotionValue(key, value))\n\n        /**\n         * Determine reduced motion preference. Only initialize the matchMedia\n         * listener if we actually need the dynamic value (i.e., when config\n         * is neither \"never\" nor \"always\").\n         */\n        if (this.reducedMotionConfig === \"never\") {\n            this.shouldReduceMotion = false\n        } else if (this.reducedMotionConfig === \"always\") {\n            this.shouldReduceMotion = true\n        } else {\n            if (!hasReducedMotionListener.current) {\n                initPrefersReducedMotion()\n            }\n            this.shouldReduceMotion = prefersReducedMotion.current\n        }\n\n        if (process.env.NODE_ENV !== \"production\") {\n            warnOnce(\n                this.shouldReduceMotion !== true,\n                \"You have Reduced Motion enabled on your device. Animations may not appear as expected.\",\n                \"reduced-motion-disabled\"\n            )\n        }\n\n        this.parent?.addChild(this)\n\n        this.update(this.props, this.presenceContext)\n    }\n\n    unmount() {\n        this.projection && this.projection.unmount()\n        cancelFrame(this.notifyUpdate)\n        cancelFrame(this.render)\n        this.valueSubscriptions.forEach((remove) => remove())\n        this.valueSubscriptions.clear()\n        this.removeFromVariantTree && this.removeFromVariantTree()\n        this.parent?.removeChild(this)\n\n        for (const key in this.events) {\n            this.events[key].clear()\n        }\n\n        for (const key in this.features) {\n            const feature = this.features[key as keyof typeof this.features]\n            if (feature) {\n                feature.unmount()\n                feature.isMounted = false\n            }\n        }\n        this.current = null\n    }\n\n    addChild(child: VisualElement) {\n        this.children.add(child)\n        this.enteringChildren ??= new Set()\n        this.enteringChildren.add(child)\n    }\n\n    removeChild(child: VisualElement) {\n        this.children.delete(child)\n        this.enteringChildren && this.enteringChildren.delete(child)\n    }\n\n    private bindToMotionValue(key: string, value: MotionValue) {\n        if (this.valueSubscriptions.has(key)) {\n            this.valueSubscriptions.get(key)!()\n        }\n\n        const valueIsTransform = transformProps.has(key)\n\n        if (valueIsTransform && this.onBindTransform) {\n            this.onBindTransform()\n        }\n\n        const removeOnChange = value.on(\n            \"change\",\n            (latestValue: AnyResolvedKeyframe) => {\n                this.latestValues[key] = latestValue\n\n                this.props.onUpdate && frame.preRender(this.notifyUpdate)\n\n                if (valueIsTransform && this.projection) {\n                    this.projection.isTransformDirty = true\n                }\n\n                this.scheduleRender()\n            }\n        )\n\n        let removeSyncCheck: VoidFunction | void\n        if (window.MotionCheckAppearSync) {\n            removeSyncCheck = window.MotionCheckAppearSync(this, key, value)\n        }\n\n        this.valueSubscriptions.set(key, () => {\n            removeOnChange()\n            if (removeSyncCheck) removeSyncCheck()\n            if (value.owner) value.stop()\n        })\n    }\n\n    sortNodePosition(other: VisualElement<Instance>) {\n        /**\n         * If these nodes aren't even of the same type we can't compare their depth.\n         */\n        if (\n            !this.current ||\n            !this.sortInstanceNodePosition ||\n            this.type !== other.type\n        ) {\n            return 0\n        }\n\n        return this.sortInstanceNodePosition(\n            this.current as Instance,\n            other.current as Instance\n        )\n    }\n\n    updateFeatures() {\n        let key: keyof typeof featureDefinitions = \"animation\"\n\n        for (key in featureDefinitions) {\n            const featureDefinition = featureDefinitions[key]\n\n            if (!featureDefinition) continue\n\n            const { isEnabled, Feature: FeatureConstructor } = featureDefinition\n\n            /**\n             * If this feature is enabled but not active, make a new instance.\n             */\n            if (\n                !this.features[key] &&\n                FeatureConstructor &&\n                isEnabled(this.props)\n            ) {\n                this.features[key] = new FeatureConstructor(this) as any\n            }\n\n            /**\n             * If we have a feature, mount or update it.\n             */\n            if (this.features[key]) {\n                const feature = this.features[key]!\n                if (feature.isMounted) {\n                    feature.update()\n                } else {\n                    feature.mount()\n                    feature.isMounted = true\n                }\n            }\n        }\n    }\n\n    notifyUpdate = () => this.notify(\"Update\", this.latestValues)\n\n    triggerBuild() {\n        this.build(this.renderState, this.latestValues, this.props)\n    }\n\n    render = () => {\n        if (!this.current) return\n        this.triggerBuild()\n        this.renderInstance(\n            this.current,\n            this.renderState,\n            this.props.style,\n            this.projection\n        )\n    }\n\n    private renderScheduledAt = 0.0\n    scheduleRender = () => {\n        const now = time.now()\n        if (this.renderScheduledAt < now) {\n            this.renderScheduledAt = now\n            frame.render(this.render, false, true)\n        }\n    }\n\n    /**\n     * Measure the current viewport box with or without transforms.\n     * Only measures axis-aligned boxes, rotate and skew must be manually\n     * removed with a re-render to work.\n     */\n    measureViewportBox() {\n        return this.current\n            ? this.measureInstanceViewportBox(this.current, this.props)\n            : createBox()\n    }\n\n    getStaticValue(key: string) {\n        return this.latestValues[key]\n    }\n\n    setStaticValue(key: string, value: AnyResolvedKeyframe) {\n        this.latestValues[key] = value\n    }\n\n    /**\n     * Update the provided props. Ensure any newly-added motion values are\n     * added to our map, old ones removed, and listeners updated.\n     */\n    update(props: MotionProps, presenceContext: PresenceContextProps | null) {\n        if (props.transformTemplate || this.props.transformTemplate) {\n            this.scheduleRender()\n        }\n\n        this.prevProps = this.props\n        this.props = props\n\n        this.prevPresenceContext = this.presenceContext\n        this.presenceContext = presenceContext\n\n        /**\n         * Update prop event handlers ie onAnimationStart, onAnimationComplete\n         */\n        for (let i = 0; i < propEventHandlers.length; i++) {\n            const key = propEventHandlers[i]\n            if (this.propEventSubscriptions[key]) {\n                this.propEventSubscriptions[key]()\n                delete this.propEventSubscriptions[key]\n            }\n\n            const listenerName = (\"on\" + key) as keyof typeof props\n            const listener = props[listenerName]\n            if (listener) {\n                this.propEventSubscriptions[key] = this.on(key as any, listener)\n            }\n        }\n\n        this.prevMotionValues = updateMotionValuesFromProps(\n            this,\n            this.scrapeMotionValuesFromProps(props, this.prevProps, this),\n            this.prevMotionValues\n        )\n\n        if (this.handleChildMotionValue) {\n            this.handleChildMotionValue()\n        }\n    }\n\n    getProps() {\n        return this.props\n    }\n\n    /**\n     * Returns the variant definition with a given name.\n     */\n    getVariant(name: string) {\n        return this.props.variants ? this.props.variants[name] : undefined\n    }\n\n    /**\n     * Returns the defined default transition on this component.\n     */\n    getDefaultTransition() {\n        return this.props.transition\n    }\n\n    getTransformPagePoint() {\n        return (this.props as any).transformPagePoint\n    }\n\n    getClosestVariantNode(): VisualElement | undefined {\n        return this.isVariantNode\n            ? this\n            : this.parent\n            ? this.parent.getClosestVariantNode()\n            : undefined\n    }\n\n    /**\n     * Add a child visual element to our set of children.\n     */\n    addVariantChild(child: VisualElement) {\n        const closestVariantNode = this.getClosestVariantNode()\n        if (closestVariantNode) {\n            closestVariantNode.variantChildren &&\n                closestVariantNode.variantChildren.add(child)\n            return () => closestVariantNode.variantChildren!.delete(child)\n        }\n    }\n\n    /**\n     * Add a motion value and bind it to this visual element.\n     */\n    addValue(key: string, value: MotionValue) {\n        // Remove existing value if it exists\n        const existingValue = this.values.get(key)\n\n        if (value !== existingValue) {\n            if (existingValue) this.removeValue(key)\n            this.bindToMotionValue(key, value)\n            this.values.set(key, value)\n            this.latestValues[key] = value.get()\n        }\n    }\n\n    /**\n     * Remove a motion value and unbind any active subscriptions.\n     */\n    removeValue(key: string) {\n        this.values.delete(key)\n        const unsubscribe = this.valueSubscriptions.get(key)\n        if (unsubscribe) {\n            unsubscribe()\n            this.valueSubscriptions.delete(key)\n        }\n        delete this.latestValues[key]\n        this.removeValueFromRenderState(key, this.renderState)\n    }\n\n    /**\n     * Check whether we have a motion value for this key\n     */\n    hasValue(key: string) {\n        return this.values.has(key)\n    }\n\n    /**\n     * Get a motion value for this key. If called with a default\n     * value, we'll create one if none exists.\n     */\n    getValue(key: string): MotionValue | undefined\n    getValue(key: string, defaultValue: AnyResolvedKeyframe | null): MotionValue\n    getValue(\n        key: string,\n        defaultValue?: AnyResolvedKeyframe | null\n    ): MotionValue | undefined {\n        if (this.props.values && this.props.values[key]) {\n            return this.props.values[key]\n        }\n\n        let value = this.values.get(key)\n\n        if (value === undefined && defaultValue !== undefined) {\n            value = motionValue(\n                defaultValue === null ? undefined : defaultValue,\n                { owner: this }\n            )\n            this.addValue(key, value)\n        }\n\n        return value\n    }\n\n    /**\n     * If we're trying to animate to a previously unencountered value,\n     * we need to check for it in our state and as a last resort read it\n     * directly from the instance (which might have performance implications).\n     */\n    readValue(key: string, target?: AnyResolvedKeyframe | null) {\n        let value =\n            this.latestValues[key] !== undefined || !this.current\n                ? this.latestValues[key]\n                : this.getBaseTargetFromProps(this.props, key) ??\n                  this.readValueFromInstance(this.current, key, this.options)\n\n        if (value !== undefined && value !== null) {\n            if (\n                typeof value === \"string\" &&\n                (isNumericalString(value) || isZeroValueString(value))\n            ) {\n                // If this is a number read as a string, ie \"0\" or \"200\", convert it to a number\n                value = parseFloat(value)\n            } else if (!findValueType(value) && complex.test(target)) {\n                value = getAnimatableNone(key, target as string)\n            }\n\n            this.setBaseTarget(key, isMotionValue(value) ? value.get() : value)\n        }\n\n        return isMotionValue(value) ? value.get() : value\n    }\n\n    /**\n     * Set the base target to later animate back to. This is currently\n     * only hydrated on creation and when we first read a value.\n     */\n    setBaseTarget(key: string, value: AnyResolvedKeyframe) {\n        this.baseTarget[key] = value\n    }\n\n    /**\n     * Find the base target for a value thats been removed from all animation\n     * props.\n     */\n    getBaseTarget(key: string): ResolvedValues[string] | undefined | null {\n        const { initial } = this.props\n\n        let valueFromInitial: ResolvedValues[string] | undefined | null\n\n        if (typeof initial === \"string\" || typeof initial === \"object\") {\n            const variant = resolveVariantFromProps(\n                this.props,\n                initial as any,\n                this.presenceContext?.custom\n            )\n            if (variant) {\n                valueFromInitial = variant[\n                    key as keyof typeof variant\n                ] as string\n            }\n        }\n\n        /**\n         * If this value still exists in the current initial variant, read that.\n         */\n        if (initial && valueFromInitial !== undefined) {\n            return valueFromInitial\n        }\n\n        /**\n         * Alternatively, if this VisualElement config has defined a getBaseTarget\n         * so we can read the value from an alternative source, try that.\n         */\n        const target = this.getBaseTargetFromProps(this.props, key)\n        if (target !== undefined && !isMotionValue(target)) return target\n\n        /**\n         * If the value was initially defined on initial, but it doesn't any more,\n         * return undefined. Otherwise return the value as initially read from the DOM.\n         */\n        return this.initialValues[key] !== undefined &&\n            valueFromInitial === undefined\n            ? undefined\n            : this.baseTarget[key]\n    }\n\n    on<EventName extends keyof VisualElementEventCallbacks>(\n        eventName: EventName,\n        callback: VisualElementEventCallbacks[EventName]\n    ) {\n        if (!this.events[eventName]) {\n            this.events[eventName] = new SubscriptionManager()\n        }\n\n        return this.events[eventName].add(callback)\n    }\n\n    notify<EventName extends keyof VisualElementEventCallbacks>(\n        eventName: EventName,\n        ...args: any\n    ) {\n        if (this.events[eventName]) {\n            this.events[eventName].notify(...args)\n        }\n    }\n\n    scheduleRenderMicrotask() {\n        microtask.render(this.render)\n    }\n}\n"],"mappings":";;;;;;;;;;AAoDA,MAAMA,iBAAiB,GAAG,CACtB,gBAAgB,EAChB,mBAAmB,EACnB,QAAQ,EACR,qBAAqB,EACrB,eAAe,EACf,sBAAsB,EACtB,yBAAyB,CACnB;AAEV;;;AAGG;MACmBC,aAAa;EA2F/B;;;;;;AAMG;EACHC,2BAA2BA,CACvBC,MAAmB,EACnBC,UAAuB,EACvBC,cAA6B;IAI7B,OAAO,EAAE;;EA4KbC,YACI;IACIC,MAAM;IACNC,KAAK;IACLC,eAAe;IACfC,mBAAmB;IACnBC,qBAAqB;IACrBC;EAAW,CAC+B,EAC9CC,OAAA,GAAmB,EAAS;IAlLhC;;;AAGG;IACH,IAAO,CAAAC,OAAA,GAAoB,IAAI;IAO/B;;AAEG;IACH,KAAAC,QAAQ,GAAG,IAAIC,GAAG,EAAiB;IAyBnC;;AAEG;IACH,IAAa,CAAAC,aAAA,GAAY,KAAK;IAC9B,IAAqB,CAAAC,qBAAA,GAAY,KAAK;IAStC;;;;;;AAMG;IACH,IAAkB,CAAAC,kBAAA,GAAmB,IAAI;IAuBzC;;;;AAIG;IACH,KAAAC,MAAM,GAAG,IAAIC,GAAG,EAAuB;IAOvC,IAAgB,CAAAC,gBAAA,GAAGA,gBAAgB;IAiBnC;;AAEG;IACK,IAAQ,CAAAC,QAAA,GAEZ,EAAE;IAEN;;;AAGG;IACK,KAAAC,kBAAkB,GAAG,IAAIH,GAAG,EAAwB;IAa5D;;;;AAIG;IACK,IAAgB,CAAAI,gBAAA,GAAgB,EAAE;IAa1C;;AAEG;IACK,IAAM,CAAAC,MAAA,GAEV,EAAE;IAEN;;;;AAIG;IACK,IAAsB,CAAAC,sBAAA,GAE1B,EAAE;IAkON,KAAAC,YAAY,GAAG,MAAM,IAAI,CAACC,MAAM,CAAC,QAAQ,EAAE,IAAI,CAACC,YAAY,CAAC;IAM7D,IAAM,CAAAC,MAAA,GAAG,MAAK;MACV,IAAI,CAAC,IAAI,CAACjB,OAAO,EAAE;MACnB,IAAI,CAACkB,YAAY,EAAE;MACnB,IAAI,CAACC,cAAc,CACf,IAAI,CAACnB,OAAO,EACZ,IAAI,CAACoB,WAAW,EAChB,IAAI,CAAC1B,KAAK,CAAC2B,KAAK,EAChB,IAAI,CAACC,UAAU,CAClB;IACL,CAAC;IAEO,IAAiB,CAAAC,iBAAA,GAAG,GAAG;IAC/B,IAAc,CAAAC,cAAA,GAAG,MAAK;MAClB,MAAMC,GAAG,GAAGC,IAAI,CAACD,GAAG,EAAE;MACtB,IAAI,IAAI,CAACF,iBAAiB,GAAGE,GAAG,EAAE;QAC9B,IAAI,CAACF,iBAAiB,GAAGE,GAAG;QAC5BE,KAAK,CAACV,MAAM,CAAC,IAAI,CAACA,MAAM,EAAE,KAAK,EAAE,IAAI,CAAC;;IAE9C,CAAC;IA7OG,MAAM;MAAED,YAAY;MAAEI;IAAW,CAAE,GAAGtB,WAAW;IACjD,IAAI,CAACkB,YAAY,GAAGA,YAAY;IAChC,IAAI,CAACY,UAAU,GAAG;MAAE,GAAGZ;IAAY,CAAE;IACrC,IAAI,CAACa,aAAa,GAAGnC,KAAK,CAACoC,OAAO,GAAG;MAAE,GAAGd;IAAY,CAAE,GAAG,EAAE;IAC7D,IAAI,CAACI,WAAW,GAAGA,WAAW;IAC9B,IAAI,CAAC3B,MAAM,GAAGA,MAAM;IACpB,IAAI,CAACC,KAAK,GAAGA,KAAK;IAClB,IAAI,CAACC,eAAe,GAAGA,eAAe;IACtC,IAAI,CAACoC,KAAK,GAAGtC,MAAM,GAAGA,MAAM,CAACsC,KAAK,GAAG,CAAC,GAAG,CAAC;IAC1C,IAAI,CAACnC,mBAAmB,GAAGA,mBAAmB;IAC9C,IAAI,CAACG,OAAO,GAAGA,OAAO;IACtB,IAAI,CAACF,qBAAqB,GAAGmC,OAAO,CAACnC,qBAAqB,CAAC;IAE3D,IAAI,CAACO,qBAAqB,GAAGA,qBAA0B,CAACV,KAAK,CAAC;IAC9D,IAAI,CAACS,aAAa,GAAGA,aAAkB,CAACT,KAAK,CAAC;IAC9C,IAAI,IAAI,CAACS,aAAa,EAAE;MACpB,IAAI,CAAC8B,eAAe,GAAG,IAAI/B,GAAG,EAAE;;IAGpC,IAAI,CAACgC,sBAAsB,GAAGF,OAAO,CAACvC,MAAM,IAAIA,MAAM,CAACO,OAAO,CAAC;IAE/D;;;;;;;;;AASG;IACH,MAAM;MAAEmC,UAAU;MAAE,GAAGC;IAAmB,CAAE,GACxC,IAAI,CAAChD,2BAA2B,CAACM,KAAK,EAAE,EAAE,EAAE,IAAI,CAAC;IAErD,KAAK,MAAM2C,GAAG,IAAID,mBAAmB,EAAE;MACnC,MAAME,KAAK,GAAGF,mBAAmB,CAACC,GAAG,CAAC;MAEtC,IAAIrB,YAAY,CAACqB,GAAG,CAAC,KAAKE,SAAS,IAAIC,aAAa,CAACF,KAAK,CAAC,EAAE;QACzDA,KAAK,CAACG,GAAG,CAACzB,YAAY,CAACqB,GAAG,CAAC,CAAC;;;;EAKxCK,KAAKA,CAACC,QAAkB;IACpB,IAAI,CAAC3C,OAAO,GAAG2C,QAAQ;IAEvBC,kBAAkB,CAACH,GAAG,CAACE,QAAQ,EAAE,IAAI,CAAC;IAEtC,IAAI,IAAI,CAACrB,UAAU,IAAI,CAAC,IAAI,CAACA,UAAU,CAACqB,QAAQ,EAAE;MAC9C,IAAI,CAACrB,UAAU,CAACoB,KAAK,CAACC,QAAQ,CAAC;;IAGnC,IAAI,IAAI,CAAClD,MAAM,IAAI,IAAI,CAACU,aAAa,IAAI,CAAC,IAAI,CAACC,qBAAqB,EAAE;MAClE,IAAI,CAACyC,qBAAqB,GAAG,IAAI,CAACpD,MAAM,CAACqD,eAAe,CAAC,IAAI,CAAC;;IAGlE,IAAI,CAACxC,MAAM,CAACyC,OAAO,CAAC,CAACT,KAAK,EAAED,GAAG,KAAK,IAAI,CAACW,iBAAiB,CAACX,GAAG,EAAEC,KAAK,CAAC,CAAC;IAEvE;;;;AAIG;IACH,IAAI,IAAI,CAAC1C,mBAAmB,KAAK,OAAO,EAAE;MACtC,IAAI,CAACS,kBAAkB,GAAG,KAAK;KAClC,MAAM,IAAI,IAAI,CAACT,mBAAmB,KAAK,QAAQ,EAAE;MAC9C,IAAI,CAACS,kBAAkB,GAAG,IAAI;KACjC,MAAM;MACH,IAAI,CAAC4C,wBAAwB,CAACjD,OAAO,EAAE;QACnCkD,wBAAwB,EAAE;;MAE9B,IAAI,CAAC7C,kBAAkB,GAAG8C,oBAAoB,CAACnD,OAAO;;IAG1D,IAAIoD,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,YAAY,EAAE;MACvCC,QAAQ,CACJ,IAAI,CAAClD,kBAAkB,KAAK,IAAI,EAChC,wFAAwF,EACxF,yBAAyB,CAC5B;;IAGL,IAAI,CAACZ,MAAM,EAAE+D,QAAQ,CAAC,IAAI,CAAC;IAE3B,IAAI,CAACC,MAAM,CAAC,IAAI,CAAC/D,KAAK,EAAE,IAAI,CAACC,eAAe,CAAC;;EAGjD+D,OAAOA,CAAA;IACH,IAAI,CAACpC,UAAU,IAAI,IAAI,CAACA,UAAU,CAACoC,OAAO,EAAE;IAC5CC,WAAW,CAAC,IAAI,CAAC7C,YAAY,CAAC;IAC9B6C,WAAW,CAAC,IAAI,CAAC1C,MAAM,CAAC;IACxB,IAAI,CAACP,kBAAkB,CAACqC,OAAO,CAAEa,MAAM,IAAKA,MAAM,EAAE,CAAC;IACrD,IAAI,CAAClD,kBAAkB,CAACmD,KAAK,EAAE;IAC/B,IAAI,CAAChB,qBAAqB,IAAI,IAAI,CAACA,qBAAqB,EAAE;IAC1D,IAAI,CAACpD,MAAM,EAAEqE,WAAW,CAAC,IAAI,CAAC;IAE9B,KAAK,MAAMzB,GAAG,IAAI,IAAI,CAACzB,MAAM,EAAE;MAC3B,IAAI,CAACA,MAAM,CAACyB,GAAG,CAAC,CAACwB,KAAK,EAAE;;IAG5B,KAAK,MAAMxB,GAAG,IAAI,IAAI,CAAC5B,QAAQ,EAAE;MAC7B,MAAMsD,OAAO,GAAG,IAAI,CAACtD,QAAQ,CAAC4B,GAAiC,CAAC;MAChE,IAAI0B,OAAO,EAAE;QACTA,OAAO,CAACL,OAAO,EAAE;QACjBK,OAAO,CAACC,SAAS,GAAG,KAAK;;;IAGjC,IAAI,CAAChE,OAAO,GAAG,IAAI;;EAGvBwD,QAAQA,CAACS,KAAoB;IACzB,IAAI,CAAChE,QAAQ,CAACiE,GAAG,CAACD,KAAK,CAAC;IACxB,IAAI,CAACE,gBAAgB,KAArB,IAAI,CAACA,gBAAgB,GAAK,IAAIjE,GAAG,EAAE;IACnC,IAAI,CAACiE,gBAAgB,CAACD,GAAG,CAACD,KAAK,CAAC;;EAGpCH,WAAWA,CAACG,KAAoB;IAC5B,IAAI,CAAChE,QAAQ,CAACmE,MAAM,CAACH,KAAK,CAAC;IAC3B,IAAI,CAACE,gBAAgB,IAAI,IAAI,CAACA,gBAAgB,CAACC,MAAM,CAACH,KAAK,CAAC;;EAGxDjB,iBAAiBA,CAACX,GAAW,EAAEC,KAAkB;IACrD,IAAI,IAAI,CAAC5B,kBAAkB,CAAC2D,GAAG,CAAChC,GAAG,CAAC,EAAE;MAClC,IAAI,CAAC3B,kBAAkB,CAAC4D,GAAG,CAACjC,GAAG,CAAE,EAAE;;IAGvC,MAAMkC,gBAAgB,GAAGC,cAAc,CAACH,GAAG,CAAChC,GAAG,CAAC;IAEhD,IAAIkC,gBAAgB,IAAI,IAAI,CAACE,eAAe,EAAE;MAC1C,IAAI,CAACA,eAAe,EAAE;;IAG1B,MAAMC,cAAc,GAAGpC,KAAK,CAACqC,EAAE,CAC3B,QAAQ,EACPC,WAAgC,IAAI;MACjC,IAAI,CAAC5D,YAAY,CAACqB,GAAG,CAAC,GAAGuC,WAAW;MAEpC,IAAI,CAAClF,KAAK,CAACmF,QAAQ,IAAIlD,KAAK,CAACmD,SAAS,CAAC,IAAI,CAAChE,YAAY,CAAC;MAEzD,IAAIyD,gBAAgB,IAAI,IAAI,CAACjD,UAAU,EAAE;QACrC,IAAI,CAACA,UAAU,CAACyD,gBAAgB,GAAG,IAAI;;MAG3C,IAAI,CAACvD,cAAc,EAAE;IACzB,CAAC,CACJ;IAED,IAAIwD,eAAoC;IACxC,IAAIC,MAAM,CAACC,qBAAqB,EAAE;MAC9BF,eAAe,GAAGC,MAAM,CAACC,qBAAqB,CAAC,IAAI,EAAE7C,GAAG,EAAEC,KAAK,CAAC;;IAGpE,IAAI,CAAC5B,kBAAkB,CAAC+B,GAAG,CAACJ,GAAG,EAAE,MAAK;MAClCqC,cAAc,EAAE;MAChB,IAAIM,eAAe,EAAEA,eAAe,EAAE;MACtC,IAAI1C,KAAK,CAAC6C,KAAK,EAAE7C,KAAK,CAAC8C,IAAI,EAAE;IACjC,CAAC,CAAC;;EAGNC,gBAAgBA,CAACC,KAA8B;IAC3C;;AAEG;IACH,IACI,CAAC,IAAI,CAACtF,OAAO,IACb,CAAC,IAAI,CAACuF,wBAAwB,IAC9B,IAAI,CAACC,IAAI,KAAKF,KAAK,CAACE,IAAI,EAC1B;MACE,OAAO,CAAC;;IAGZ,OAAO,IAAI,CAACD,wBAAwB,CAChC,IAAI,CAACvF,OAAmB,EACxBsF,KAAK,CAACtF,OAAmB,CAC5B;;EAGLyF,cAAcA,CAAA;IACV,IAAIpD,GAAG,GAAoC,WAAW;IAEtD,KAAKA,GAAG,IAAIqD,kBAAkB,EAAE;MAC5B,MAAMC,iBAAiB,GAAGD,kBAAkB,CAACrD,GAAG,CAAC;MAEjD,IAAI,CAACsD,iBAAiB,EAAE;MAExB,MAAM;QAAEC,SAAS;QAAEC,OAAO,EAAEC;MAAkB,CAAE,GAAGH,iBAAiB;MAEpE;;AAEG;MACH,IACI,CAAC,IAAI,CAAClF,QAAQ,CAAC4B,GAAG,CAAC,IACnByD,kBAAkB,IAClBF,SAAS,CAAC,IAAI,CAAClG,KAAK,CAAC,EACvB;QACE,IAAI,CAACe,QAAQ,CAAC4B,GAAG,CAAC,GAAG,IAAIyD,kBAAkB,CAAC,IAAI,CAAQ;;MAG5D;;AAEG;MACH,IAAI,IAAI,CAACrF,QAAQ,CAAC4B,GAAG,CAAC,EAAE;QACpB,MAAM0B,OAAO,GAAG,IAAI,CAACtD,QAAQ,CAAC4B,GAAG,CAAE;QACnC,IAAI0B,OAAO,CAACC,SAAS,EAAE;UACnBD,OAAO,CAACN,MAAM,EAAE;SACnB,MAAM;UACHM,OAAO,CAACrB,KAAK,EAAE;UACfqB,OAAO,CAACC,SAAS,GAAG,IAAI;;;;;EAQxC9C,YAAYA,CAAA;IACR,IAAI,CAAC6E,KAAK,CAAC,IAAI,CAAC3E,WAAW,EAAE,IAAI,CAACJ,YAAY,EAAE,IAAI,CAACtB,KAAK,CAAC;;EAuB/D;;;;AAIG;EACHsG,kBAAkBA,CAAA;IACd,OAAO,IAAI,CAAChG,OAAO,GACb,IAAI,CAACiG,0BAA0B,CAAC,IAAI,CAACjG,OAAO,EAAE,IAAI,CAACN,KAAK,CAAC,GACzDwG,SAAS,EAAE;;EAGrBC,cAAcA,CAAC9D,GAAW;IACtB,OAAO,IAAI,CAACrB,YAAY,CAACqB,GAAG,CAAC;;EAGjC+D,cAAcA,CAAC/D,GAAW,EAAEC,KAA0B;IAClD,IAAI,CAACtB,YAAY,CAACqB,GAAG,CAAC,GAAGC,KAAK;;EAGlC;;;AAGG;EACHmB,MAAMA,CAAC/D,KAAkB,EAAEC,eAA4C;IACnE,IAAID,KAAK,CAAC2G,iBAAiB,IAAI,IAAI,CAAC3G,KAAK,CAAC2G,iBAAiB,EAAE;MACzD,IAAI,CAAC7E,cAAc,EAAE;;IAGzB,IAAI,CAAC8E,SAAS,GAAG,IAAI,CAAC5G,KAAK;IAC3B,IAAI,CAACA,KAAK,GAAGA,KAAK;IAElB,IAAI,CAAC6G,mBAAmB,GAAG,IAAI,CAAC5G,eAAe;IAC/C,IAAI,CAACA,eAAe,GAAGA,eAAe;IAEtC;;AAEG;IACH,KAAK,IAAI6G,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGtH,iBAAiB,CAACuH,MAAM,EAAED,CAAC,EAAE,EAAE;MAC/C,MAAMnE,GAAG,GAAGnD,iBAAiB,CAACsH,CAAC,CAAC;MAChC,IAAI,IAAI,CAAC3F,sBAAsB,CAACwB,GAAG,CAAC,EAAE;QAClC,IAAI,CAACxB,sBAAsB,CAACwB,GAAG,CAAC,EAAE;QAClC,OAAO,IAAI,CAACxB,sBAAsB,CAACwB,GAAG,CAAC;;MAG3C,MAAMqE,YAAY,GAAI,IAAI,GAAGrE,GAA0B;MACvD,MAAMsE,QAAQ,GAAGjH,KAAK,CAACgH,YAAY,CAAC;MACpC,IAAIC,QAAQ,EAAE;QACV,IAAI,CAAC9F,sBAAsB,CAACwB,GAAG,CAAC,GAAG,IAAI,CAACsC,EAAE,CAACtC,GAAU,EAAEsE,QAAQ,CAAC;;;IAIxE,IAAI,CAAChG,gBAAgB,GAAGiG,2BAA2B,CAC/C,IAAI,EACJ,IAAI,CAACxH,2BAA2B,CAACM,KAAK,EAAE,IAAI,CAAC4G,SAAS,EAAE,IAAI,CAAC,EAC7D,IAAI,CAAC3F,gBAAgB,CACxB;IAED,IAAI,IAAI,CAACkG,sBAAsB,EAAE;MAC7B,IAAI,CAACA,sBAAsB,EAAE;;;EAIrCC,QAAQA,CAAA;IACJ,OAAO,IAAI,CAACpH,KAAK;;EAGrB;;AAEG;EACHqH,UAAUA,CAACC,IAAY;IACnB,OAAO,IAAI,CAACtH,KAAK,CAACuH,QAAQ,GAAG,IAAI,CAACvH,KAAK,CAACuH,QAAQ,CAACD,IAAI,CAAC,GAAGzE,SAAS;;EAGtE;;AAEG;EACH2E,oBAAoBA,CAAA;IAChB,OAAO,IAAI,CAACxH,KAAK,CAACyH,UAAU;;EAGhCC,qBAAqBA,CAAA;IACjB,OAAQ,IAAI,CAAC1H,KAAa,CAAC2H,kBAAkB;;EAGjDC,qBAAqBA,CAAA;IACjB,OAAO,IAAI,CAACnH,aAAa,GACnB,IAAI,GACJ,IAAI,CAACV,MAAM,GACX,IAAI,CAACA,MAAM,CAAC6H,qBAAqB,EAAE,GACnC/E,SAAS;;EAGnB;;AAEG;EACHO,eAAeA,CAACmB,KAAoB;IAChC,MAAMsD,kBAAkB,GAAG,IAAI,CAACD,qBAAqB,EAAE;IACvD,IAAIC,kBAAkB,EAAE;MACpBA,kBAAkB,CAACtF,eAAe,IAC9BsF,kBAAkB,CAACtF,eAAe,CAACiC,GAAG,CAACD,KAAK,CAAC;MACjD,OAAO,MAAMsD,kBAAkB,CAACtF,eAAgB,CAACmC,MAAM,CAACH,KAAK,CAAC;;;EAItE;;AAEG;EACHuD,QAAQA,CAACnF,GAAW,EAAEC,KAAkB;;IAEpC,MAAMmF,aAAa,GAAG,IAAI,CAACnH,MAAM,CAACgE,GAAG,CAACjC,GAAG,CAAC;IAE1C,IAAIC,KAAK,KAAKmF,aAAa,EAAE;MACzB,IAAIA,aAAa,EAAE,IAAI,CAACC,WAAW,CAACrF,GAAG,CAAC;MACxC,IAAI,CAACW,iBAAiB,CAACX,GAAG,EAAEC,KAAK,CAAC;MAClC,IAAI,CAAChC,MAAM,CAACmC,GAAG,CAACJ,GAAG,EAAEC,KAAK,CAAC;MAC3B,IAAI,CAACtB,YAAY,CAACqB,GAAG,CAAC,GAAGC,KAAK,CAACgC,GAAG,EAAE;;;EAI5C;;AAEG;EACHoD,WAAWA,CAACrF,GAAW;IACnB,IAAI,CAAC/B,MAAM,CAAC8D,MAAM,CAAC/B,GAAG,CAAC;IACvB,MAAMsF,WAAW,GAAG,IAAI,CAACjH,kBAAkB,CAAC4D,GAAG,CAACjC,GAAG,CAAC;IACpD,IAAIsF,WAAW,EAAE;MACbA,WAAW,EAAE;MACb,IAAI,CAACjH,kBAAkB,CAAC0D,MAAM,CAAC/B,GAAG,CAAC;;IAEvC,OAAO,IAAI,CAACrB,YAAY,CAACqB,GAAG,CAAC;IAC7B,IAAI,CAACuF,0BAA0B,CAACvF,GAAG,EAAE,IAAI,CAACjB,WAAW,CAAC;;EAG1D;;AAEG;EACHyG,QAAQA,CAACxF,GAAW;IAChB,OAAO,IAAI,CAAC/B,MAAM,CAAC+D,GAAG,CAAChC,GAAG,CAAC;;EAS/ByF,QAAQA,CACJzF,GAAW,EACX0F,YAAyC;IAEzC,IAAI,IAAI,CAACrI,KAAK,CAACY,MAAM,IAAI,IAAI,CAACZ,KAAK,CAACY,MAAM,CAAC+B,GAAG,CAAC,EAAE;MAC7C,OAAO,IAAI,CAAC3C,KAAK,CAACY,MAAM,CAAC+B,GAAG,CAAC;;IAGjC,IAAIC,KAAK,GAAG,IAAI,CAAChC,MAAM,CAACgE,GAAG,CAACjC,GAAG,CAAC;IAEhC,IAAIC,KAAK,KAAKC,SAAS,IAAIwF,YAAY,KAAKxF,SAAS,EAAE;MACnDD,KAAK,GAAG0F,WAAW,CACfD,YAAY,KAAK,IAAI,GAAGxF,SAAS,GAAGwF,YAAY,EAChD;QAAE5C,KAAK,EAAE;MAAI,CAAE,CAClB;MACD,IAAI,CAACqC,QAAQ,CAACnF,GAAG,EAAEC,KAAK,CAAC;;IAG7B,OAAOA,KAAK;;EAGhB;;;;AAIG;EACH2F,SAASA,CAAC5F,GAAW,EAAE6F,MAAmC;IACtD,IAAI5F,KAAK,GACL,IAAI,CAACtB,YAAY,CAACqB,GAAG,CAAC,KAAKE,SAAS,IAAI,CAAC,IAAI,CAACvC,OAAO,GAC/C,IAAI,CAACgB,YAAY,CAACqB,GAAG,CAAC,GACtB,IAAI,CAAC8F,sBAAsB,CAAC,IAAI,CAACzI,KAAK,EAAE2C,GAAG,CAAC,IAC5C,IAAI,CAAC+F,qBAAqB,CAAC,IAAI,CAACpI,OAAO,EAAEqC,GAAG,EAAE,IAAI,CAACtC,OAAO,CAAC;IAErE,IAAIuC,KAAK,KAAKC,SAAS,IAAID,KAAK,KAAK,IAAI,EAAE;MACvC,IACI,OAAOA,KAAK,KAAK,QAAQ,KACxB+F,iBAAiB,CAAC/F,KAAK,CAAC,IAAIgG,iBAAiB,CAAChG,KAAK,CAAC,CAAC,EACxD;;QAEEA,KAAK,GAAGiG,UAAU,CAACjG,KAAK,CAAC;OAC5B,MAAM,IAAI,CAACkG,aAAa,CAAClG,KAAK,CAAC,IAAImG,OAAO,CAACC,IAAI,CAACR,MAAM,CAAC,EAAE;QACtD5F,KAAK,GAAGqG,iBAAiB,CAACtG,GAAG,EAAE6F,MAAgB,CAAC;;MAGpD,IAAI,CAACU,aAAa,CAACvG,GAAG,EAAEG,aAAa,CAACF,KAAK,CAAC,GAAGA,KAAK,CAACgC,GAAG,EAAE,GAAGhC,KAAK,CAAC;;IAGvE,OAAOE,aAAa,CAACF,KAAK,CAAC,GAAGA,KAAK,CAACgC,GAAG,EAAE,GAAGhC,KAAK;;EAGrD;;;AAGG;EACHsG,aAAaA,CAACvG,GAAW,EAAEC,KAA0B;IACjD,IAAI,CAACV,UAAU,CAACS,GAAG,CAAC,GAAGC,KAAK;;EAGhC;;;AAGG;EACHuG,aAAaA,CAACxG,GAAW;IACrB,MAAM;MAAEP;IAAO,CAAE,GAAG,IAAI,CAACpC,KAAK;IAE9B,IAAIoJ,gBAA2D;IAE/D,IAAI,OAAOhH,OAAO,KAAK,QAAQ,IAAI,OAAOA,OAAO,KAAK,QAAQ,EAAE;MAC5D,MAAMiH,OAAO,GAAGC,uBAAuB,CACnC,IAAI,CAACtJ,KAAK,EACVoC,OAAc,EACd,IAAI,CAACnC,eAAe,EAAEsJ,MAAM,CAC/B;MACD,IAAIF,OAAO,EAAE;QACTD,gBAAgB,GAAGC,OAAO,CACtB1G,GAA2B,CACpB;;;IAInB;;AAEG;IACH,IAAIP,OAAO,IAAIgH,gBAAgB,KAAKvG,SAAS,EAAE;MAC3C,OAAOuG,gBAAgB;;IAG3B;;;AAGG;IACH,MAAMZ,MAAM,GAAG,IAAI,CAACC,sBAAsB,CAAC,IAAI,CAACzI,KAAK,EAAE2C,GAAG,CAAC;IAC3D,IAAI6F,MAAM,KAAK3F,SAAS,IAAI,CAACC,aAAa,CAAC0F,MAAM,CAAC,EAAE,OAAOA,MAAM;IAEjE;;;AAGG;IACH,OAAO,IAAI,CAACrG,aAAa,CAACQ,GAAG,CAAC,KAAKE,SAAS,IACxCuG,gBAAgB,KAAKvG,SAAS,GAC5BA,SAAS,GACT,IAAI,CAACX,UAAU,CAACS,GAAG,CAAC;;EAG9BsC,EAAEA,CACEuE,SAAoB,EACpBC,QAAgD;IAEhD,IAAI,CAAC,IAAI,CAACvI,MAAM,CAACsI,SAAS,CAAC,EAAE;MACzB,IAAI,CAACtI,MAAM,CAACsI,SAAS,CAAC,GAAG,IAAIE,mBAAmB,EAAE;;IAGtD,OAAO,IAAI,CAACxI,MAAM,CAACsI,SAAS,CAAC,CAAChF,GAAG,CAACiF,QAAQ,CAAC;;EAG/CpI,MAAMA,CACFmI,SAAoB,EACpB,GAAGG,IAAS;IAEZ,IAAI,IAAI,CAACzI,MAAM,CAACsI,SAAS,CAAC,EAAE;MACxB,IAAI,CAACtI,MAAM,CAACsI,SAAS,CAAC,CAACnI,MAAM,CAAC,GAAGsI,IAAI,CAAC;;;EAI9CC,uBAAuBA,CAAA;IACnBC,SAAS,CAACtI,MAAM,CAAC,IAAI,CAACA,MAAM,CAAC;;AAEpC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}