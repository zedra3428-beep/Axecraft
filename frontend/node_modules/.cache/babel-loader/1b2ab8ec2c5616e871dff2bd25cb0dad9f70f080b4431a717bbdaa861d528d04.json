{"ast":null,"code":"import { mixNumber } from 'motion-dom';\nimport { progress, clamp } from 'motion-utils';\nimport { calcLength } from '../../../projection/geometry/delta-calc.mjs';\n\n/**\n * Apply constraints to a point. These constraints are both physical along an\n * axis, and an elastic factor that determines how much to constrain the point\n * by if it does lie outside the defined parameters.\n */\nfunction applyConstraints(point, _ref, elastic) {\n  let {\n    min,\n    max\n  } = _ref;\n  if (min !== undefined && point < min) {\n    // If we have a min point defined, and this is outside of that, constrain\n    point = elastic ? mixNumber(min, point, elastic.min) : Math.max(point, min);\n  } else if (max !== undefined && point > max) {\n    // If we have a max point defined, and this is outside of that, constrain\n    point = elastic ? mixNumber(max, point, elastic.max) : Math.min(point, max);\n  }\n  return point;\n}\n/**\n * Calculate constraints in terms of the viewport when defined relatively to the\n * measured axis. This is measured from the nearest edge, so a max constraint of 200\n * on an axis with a max value of 300 would return a constraint of 500 - axis length\n */\nfunction calcRelativeAxisConstraints(axis, min, max) {\n  return {\n    min: min !== undefined ? axis.min + min : undefined,\n    max: max !== undefined ? axis.max + max - (axis.max - axis.min) : undefined\n  };\n}\n/**\n * Calculate constraints in terms of the viewport when\n * defined relatively to the measured bounding box.\n */\nfunction calcRelativeConstraints(layoutBox, _ref2) {\n  let {\n    top,\n    left,\n    bottom,\n    right\n  } = _ref2;\n  return {\n    x: calcRelativeAxisConstraints(layoutBox.x, left, right),\n    y: calcRelativeAxisConstraints(layoutBox.y, top, bottom)\n  };\n}\n/**\n * Calculate viewport constraints when defined as another viewport-relative axis\n */\nfunction calcViewportAxisConstraints(layoutAxis, constraintsAxis) {\n  let min = constraintsAxis.min - layoutAxis.min;\n  let max = constraintsAxis.max - layoutAxis.max;\n  // If the constraints axis is actually smaller than the layout axis then we can\n  // flip the constraints\n  if (constraintsAxis.max - constraintsAxis.min < layoutAxis.max - layoutAxis.min) {\n    [min, max] = [max, min];\n  }\n  return {\n    min,\n    max\n  };\n}\n/**\n * Calculate viewport constraints when defined as another viewport-relative box\n */\nfunction calcViewportConstraints(layoutBox, constraintsBox) {\n  return {\n    x: calcViewportAxisConstraints(layoutBox.x, constraintsBox.x),\n    y: calcViewportAxisConstraints(layoutBox.y, constraintsBox.y)\n  };\n}\n/**\n * Calculate a transform origin relative to the source axis, between 0-1, that results\n * in an asthetically pleasing scale/transform needed to project from source to target.\n */\nfunction calcOrigin(source, target) {\n  let origin = 0.5;\n  const sourceLength = calcLength(source);\n  const targetLength = calcLength(target);\n  if (targetLength > sourceLength) {\n    origin = progress(target.min, target.max - sourceLength, source.min);\n  } else if (sourceLength > targetLength) {\n    origin = progress(source.min, source.max - targetLength, target.min);\n  }\n  return clamp(0, 1, origin);\n}\n/**\n * Rebase the calculated viewport constraints relative to the layout.min point.\n */\nfunction rebaseAxisConstraints(layout, constraints) {\n  const relativeConstraints = {};\n  if (constraints.min !== undefined) {\n    relativeConstraints.min = constraints.min - layout.min;\n  }\n  if (constraints.max !== undefined) {\n    relativeConstraints.max = constraints.max - layout.min;\n  }\n  return relativeConstraints;\n}\nconst defaultElastic = 0.35;\n/**\n * Accepts a dragElastic prop and returns resolved elastic values for each axis.\n */\nfunction resolveDragElastic() {\n  let dragElastic = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultElastic;\n  if (dragElastic === false) {\n    dragElastic = 0;\n  } else if (dragElastic === true) {\n    dragElastic = defaultElastic;\n  }\n  return {\n    x: resolveAxisElastic(dragElastic, \"left\", \"right\"),\n    y: resolveAxisElastic(dragElastic, \"top\", \"bottom\")\n  };\n}\nfunction resolveAxisElastic(dragElastic, minLabel, maxLabel) {\n  return {\n    min: resolvePointElastic(dragElastic, minLabel),\n    max: resolvePointElastic(dragElastic, maxLabel)\n  };\n}\nfunction resolvePointElastic(dragElastic, label) {\n  return typeof dragElastic === \"number\" ? dragElastic : dragElastic[label] || 0;\n}\nexport { applyConstraints, calcOrigin, calcRelativeAxisConstraints, calcRelativeConstraints, calcViewportAxisConstraints, calcViewportConstraints, defaultElastic, rebaseAxisConstraints, resolveAxisElastic, resolveDragElastic, resolvePointElastic };","map":{"version":3,"names":["applyConstraints","point","_ref","elastic","min","max","undefined","mixNumber","Math","calcRelativeAxisConstraints","axis","calcRelativeConstraints","layoutBox","_ref2","top","left","bottom","right","x","y","calcViewportAxisConstraints","layoutAxis","constraintsAxis","calcViewportConstraints","constraintsBox","calcOrigin","source","target","origin","sourceLength","calcLength","targetLength","progress","clamp","rebaseAxisConstraints","layout","constraints","relativeConstraints","defaultElastic","resolveDragElastic","dragElastic","arguments","length","resolveAxisElastic","minLabel","maxLabel","resolvePointElastic","label"],"sources":["/app/frontend/node_modules/framer-motion/src/gestures/drag/utils/constraints.ts"],"sourcesContent":["import type { DragElastic, ResolvedConstraints } from \"motion-dom\"\nimport { mixNumber } from \"motion-dom\"\nimport {\n    Axis,\n    BoundingBox,\n    Box,\n    progress as calcProgress,\n    clamp,\n    Point,\n} from \"motion-utils\"\nimport { calcLength } from \"../../../projection/geometry/delta-calc\"\n\n/**\n * Apply constraints to a point. These constraints are both physical along an\n * axis, and an elastic factor that determines how much to constrain the point\n * by if it does lie outside the defined parameters.\n */\nexport function applyConstraints(\n    point: number,\n    { min, max }: Partial<Axis>,\n    elastic?: Axis\n): number {\n    if (min !== undefined && point < min) {\n        // If we have a min point defined, and this is outside of that, constrain\n        point = elastic\n            ? mixNumber(min, point, elastic.min)\n            : Math.max(point, min)\n    } else if (max !== undefined && point > max) {\n        // If we have a max point defined, and this is outside of that, constrain\n        point = elastic\n            ? mixNumber(max, point, elastic.max)\n            : Math.min(point, max)\n    }\n\n    return point\n}\n\n/**\n * Calculates a min projection point based on a pointer, pointer progress\n * within the drag target, and constraints.\n *\n * For instance if an element was 100px width, we were dragging from 0.25\n * along this axis, the pointer is at 200px, and there were no constraints,\n * we would calculate a min projection point of 175px.\n */\nexport function calcConstrainedMinPoint(\n    point: number,\n    length: number,\n    progress: number,\n    constraints?: Partial<Axis>,\n    elastic?: Axis\n): number {\n    // Calculate a min point for this axis and apply it to the current pointer\n    const min = point - length * progress\n\n    return constraints ? applyConstraints(min, constraints, elastic) : min\n}\n\n/**\n * Calculate constraints in terms of the viewport when defined relatively to the\n * measured axis. This is measured from the nearest edge, so a max constraint of 200\n * on an axis with a max value of 300 would return a constraint of 500 - axis length\n */\nexport function calcRelativeAxisConstraints(\n    axis: Axis,\n    min?: number,\n    max?: number\n): Partial<Axis> {\n    return {\n        min: min !== undefined ? axis.min + min : undefined,\n        max:\n            max !== undefined\n                ? axis.max + max - (axis.max - axis.min)\n                : undefined,\n    }\n}\n\n/**\n * Calculate constraints in terms of the viewport when\n * defined relatively to the measured bounding box.\n */\nexport function calcRelativeConstraints(\n    layoutBox: Box,\n    { top, left, bottom, right }: Partial<BoundingBox>\n): ResolvedConstraints {\n    return {\n        x: calcRelativeAxisConstraints(layoutBox.x, left, right),\n        y: calcRelativeAxisConstraints(layoutBox.y, top, bottom),\n    }\n}\n\n/**\n * Calculate viewport constraints when defined as another viewport-relative axis\n */\nexport function calcViewportAxisConstraints(\n    layoutAxis: Axis,\n    constraintsAxis: Axis\n) {\n    let min = constraintsAxis.min - layoutAxis.min\n    let max = constraintsAxis.max - layoutAxis.max\n\n    // If the constraints axis is actually smaller than the layout axis then we can\n    // flip the constraints\n    if (\n        constraintsAxis.max - constraintsAxis.min <\n        layoutAxis.max - layoutAxis.min\n    ) {\n        ;[min, max] = [max, min]\n    }\n\n    return { min, max }\n}\n\n/**\n * Calculate viewport constraints when defined as another viewport-relative box\n */\nexport function calcViewportConstraints(layoutBox: Box, constraintsBox: Box) {\n    return {\n        x: calcViewportAxisConstraints(layoutBox.x, constraintsBox.x),\n        y: calcViewportAxisConstraints(layoutBox.y, constraintsBox.y),\n    }\n}\n\n/**\n * Calculate a transform origin relative to the source axis, between 0-1, that results\n * in an asthetically pleasing scale/transform needed to project from source to target.\n */\nexport function calcOrigin(source: Axis, target: Axis): number {\n    let origin = 0.5\n    const sourceLength = calcLength(source)\n    const targetLength = calcLength(target)\n\n    if (targetLength > sourceLength) {\n        origin = calcProgress(target.min, target.max - sourceLength, source.min)\n    } else if (sourceLength > targetLength) {\n        origin = calcProgress(source.min, source.max - targetLength, target.min)\n    }\n\n    return clamp(0, 1, origin)\n}\n\n/**\n * Calculate the relative progress of one constraints box relative to another.\n * Imagine a page scroll bar. At the top, this would return 0, at the bottom, 1.\n * Anywhere in-between, a value between 0 and 1.\n *\n * This also handles flipped constraints, for instance a draggable container within\n * a smaller viewport like a scrollable view.\n */\nexport function calcProgressWithinConstraints(\n    layoutBox: Box,\n    constraintsBox: Box\n): Point {\n    return {\n        x: calcOrigin(layoutBox.x, constraintsBox.x),\n        y: calcOrigin(layoutBox.y, constraintsBox.y),\n    }\n}\n\n/**\n * Calculate the an axis position based on two axes and a progress value.\n */\nexport function calcPositionFromProgress(\n    axis: Axis,\n    constraints: Axis,\n    progress: number\n): Axis {\n    const axisLength = axis.max - axis.min\n    const min = mixNumber(\n        constraints.min,\n        constraints.max - axisLength,\n        progress\n    )\n    return { min, max: min + axisLength }\n}\n\n/**\n * Rebase the calculated viewport constraints relative to the layout.min point.\n */\nexport function rebaseAxisConstraints(\n    layout: Axis,\n    constraints: Partial<Axis>\n): Partial<Axis> {\n    const relativeConstraints: Partial<Axis> = {}\n\n    if (constraints.min !== undefined) {\n        relativeConstraints.min = constraints.min - layout.min\n    }\n\n    if (constraints.max !== undefined) {\n        relativeConstraints.max = constraints.max - layout.min\n    }\n\n    return relativeConstraints\n}\n\nexport const defaultElastic = 0.35\n/**\n * Accepts a dragElastic prop and returns resolved elastic values for each axis.\n */\nexport function resolveDragElastic(\n    dragElastic: DragElastic = defaultElastic\n): Box {\n    if (dragElastic === false) {\n        dragElastic = 0\n    } else if (dragElastic === true) {\n        dragElastic = defaultElastic\n    }\n\n    return {\n        x: resolveAxisElastic(dragElastic, \"left\", \"right\"),\n        y: resolveAxisElastic(dragElastic, \"top\", \"bottom\"),\n    }\n}\n\nexport function resolveAxisElastic(\n    dragElastic: DragElastic,\n    minLabel: string,\n    maxLabel: string\n): Axis {\n    return {\n        min: resolvePointElastic(dragElastic, minLabel),\n        max: resolvePointElastic(dragElastic, maxLabel),\n    }\n}\n\nexport function resolvePointElastic(\n    dragElastic: DragElastic,\n    label: string\n): number {\n    return typeof dragElastic === \"number\"\n        ? dragElastic\n        : dragElastic[label as keyof typeof dragElastic] || 0\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}