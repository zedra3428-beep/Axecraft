{"version":3,"file":"index.js","names":["children: any[]","attributes: Record<string, string>","value: string","childNodes: any[]"],"sources":["../src/getElementsByName.ts","../src/parseXml.ts","../src/serializeXml.ts"],"sourcesContent":["import type { XmlNode } from './XmlNode.ts'\n\n/**\n * Recursively finds all elements by name within an XML structure.\n *\n * @param node - The current XML node to search within.\n * @param name - The name of the target nodes to find.\n * @param found - An array to collect matching nodes.\n * @returns An array of all matching XmlNodes.\n *\n *\n * @beta\n *\n */\nexport function getElementsByName(node: XmlNode, name: string, found: XmlNode[] = []): XmlNode[] {\n\tif (!node) {\n\t\treturn found\n\t}\n\n\tif (node.nodeName === name) {\n\t\tfound.push(node)\n\t}\n\n\tif (node.childNodes) {\n\t\tfor (const child of node.childNodes) {\n\t\t\tgetElementsByName(child, name, found)\n\t\t}\n\t}\n\n\treturn found\n}\n","import { unescapeHtml } from '@svta/cml-utils'\nimport type { XmlNode } from './XmlNode.ts'\nimport type { XmlParseOptions } from './XmlParseOptions.ts'\n\n/**\n * Parse XML into a JS object with no validation and some failure tolerance\n *\n * @param input - The input XML string\n * @param options - Optional parsing options\n * @returns The parsed XML\n *\n * @beta\n *\n * @example\n * {@includeCode ../test/decodeXml.test.ts#example}\n */\nexport function parseXml(input: string, options: XmlParseOptions = {}): XmlNode {\n\tlet pos = options.pos || 0\n\n\tconst length = input.length\n\tconst keepComments = !!options.keepComments\n\tconst keepWhitespace = !!options.keepWhitespace\n\n\tconst openBracket = '<'\n\tconst openBracketCC = '<'.charCodeAt(0)\n\tconst closeBracket = '>'\n\tconst closeBracketCC = '>'.charCodeAt(0)\n\tconst minusCC = '-'.charCodeAt(0)\n\tconst slashCC = '/'.charCodeAt(0)\n\tconst questionCC = '?'.charCodeAt(0)\n\tconst exclamationCC = '!'.charCodeAt(0)\n\tconst singleQuoteCC = \"'\".charCodeAt(0)\n\tconst doubleQuoteCC = '\"'.charCodeAt(0)\n\tconst openCornerBracketCC = '['.charCodeAt(0)\n\tconst closeCornerBracketCC = ']'.charCodeAt(0)\n\tconst nameSpacer = '\\r\\n\\t>/= '\n\n\tfunction createTextNode(value: string, nodeName = '#text'): XmlNode {\n\t\treturn {\n\t\t\tnodeName,\n\t\t\tnodeValue: value,\n\t\t\tattributes: {},\n\t\t\tchildNodes: [],\n\t\t}\n\t}\n\n\t/**\n\t * parsing a list of entries\n\t */\n\tfunction parseChildren(tagName: string = ''): XmlNode[] {\n\t\tconst children: any[] = []\n\t\twhile (input[pos]) {\n\t\t\tif (input.charCodeAt(pos) == openBracketCC) {\n\t\t\t\tif (input.charCodeAt(pos + 1) === slashCC) {\n\t\t\t\t\tconst closeStart = pos + 2\n\t\t\t\t\tpos = input.indexOf(closeBracket, pos)\n\t\t\t\t\tif (!input.startsWith(tagName, closeStart)) {\n\t\t\t\t\t\tconst parsedText = input.substring(0, pos).split('\\n')\n\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t'Unexpected close tag\\nLine: ' + (parsedText.length - 1) +\n\t\t\t\t\t\t\t'\\nColumn: ' + (parsedText[parsedText.length - 1].length + 1) +\n\t\t\t\t\t\t\t'\\nChar: ' + input[pos],\n\t\t\t\t\t\t)\n\t\t\t\t\t}\n\n\t\t\t\t\tif (pos + 1) {\n\t\t\t\t\t\tpos += 1\n\t\t\t\t\t}\n\n\t\t\t\t\treturn children\n\t\t\t\t}\n\t\t\t\telse if (input.charCodeAt(pos + 1) === questionCC) {\n\t\t\t\t\t// xml declaration\n\t\t\t\t\tpos = input.indexOf(closeBracket, pos)\n\t\t\t\t\tpos++\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\telse if (input.charCodeAt(pos + 1) === exclamationCC) {\n\t\t\t\t\tif (input.charCodeAt(pos + 2) == minusCC) {\n\t\t\t\t\t\t// comment support\n\t\t\t\t\t\tconst startCommentPos = pos\n\t\t\t\t\t\twhile (pos !== -1 && !(input.charCodeAt(pos) === closeBracketCC && input.charCodeAt(pos - 1) == minusCC && input.charCodeAt(pos - 2) == minusCC && pos != -1)) {\n\t\t\t\t\t\t\tpos = input.indexOf(closeBracket, pos + 1)\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (pos === -1) {\n\t\t\t\t\t\t\tpos = length\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (keepComments) {\n\t\t\t\t\t\t\tchildren.push(createTextNode(input.substring(startCommentPos, pos + 1), '#comment'))\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if (\n\t\t\t\t\t\tinput.charCodeAt(pos + 2) === openCornerBracketCC &&\n\t\t\t\t\t\tinput.charCodeAt(pos + 8) === openCornerBracketCC &&\n\t\t\t\t\t\tinput.startsWith('CDATA', pos + 3)\n\t\t\t\t\t) {\n\t\t\t\t\t\t// cdata\n\t\t\t\t\t\tconst cdataEndIndex = input.indexOf(']]>', pos)\n\t\t\t\t\t\tif (cdataEndIndex == -1) {\n\t\t\t\t\t\t\tchildren.push(createTextNode(input.substr(pos + 9), '#cdata'))\n\t\t\t\t\t\t\tpos = length\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tchildren.push(createTextNode(input.substring(pos + 9, cdataEndIndex), '#cdata'))\n\t\t\t\t\t\t\tpos = cdataEndIndex + 3\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// doctypesupport\n\t\t\t\t\t\tconst startDoctype = pos + 1\n\t\t\t\t\t\tpos += 2\n\t\t\t\t\t\tlet encapsuled = false\n\t\t\t\t\t\twhile ((input.charCodeAt(pos) !== closeBracketCC || encapsuled === true) && input[pos]) {\n\t\t\t\t\t\t\tif (input.charCodeAt(pos) === openCornerBracketCC) {\n\t\t\t\t\t\t\t\tencapsuled = true\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (encapsuled === true && input.charCodeAt(pos) === closeCornerBracketCC) {\n\t\t\t\t\t\t\t\tencapsuled = false\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tpos++\n\t\t\t\t\t\t}\n\t\t\t\t\t\tchildren.push(createTextNode(input.substring(startDoctype, pos), '#doctype'))\n\t\t\t\t\t}\n\n\t\t\t\t\tpos++\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\tconst node = parseNode()\n\t\t\t\tchildren.push(node)\n\t\t\t}\n\t\t\telse {\n\t\t\t\tconst text = parseText()\n\t\t\t\tif (keepWhitespace) {\n\t\t\t\t\tif (text.length > 0) {\n\t\t\t\t\t\tchildren.push(createTextNode(text))\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tconst trimmed = text.trim()\n\t\t\t\t\tif (trimmed.length > 0) {\n\t\t\t\t\t\tchildren.push(createTextNode(trimmed))\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpos++\n\t\t\t}\n\t\t}\n\t\treturn children\n\t}\n\n\t/**\n\t * returns the text outside of texts until the first '&lt;'\n\t */\n\tfunction parseText(): string {\n\t\tconst start = pos\n\t\tpos = input.indexOf(openBracket, pos) - 1\n\t\tif (pos === -2) {\n\t\t\tpos = length\n\t\t}\n\n\t\treturn unescapeHtml(input.slice(start, pos + 1))\n\t}\n\n\t/**\n\t * returns text until the first nonAlphabetic letter\n\t */\n\tfunction parseName(): string {\n\t\tconst start = pos\n\t\twhile (nameSpacer.indexOf(input[pos]) === -1 && input[pos]) {\n\t\t\tpos++\n\t\t}\n\t\treturn input.slice(start, pos)\n\t}\n\n\t/**\n\t * parses the attributes of a node\n\t */\n\tfunction parseAttributes(): Record<string, string> {\n\t\tconst attributes: Record<string, string> = {}\n\n\t\t// parsing attributes\n\t\twhile (input.charCodeAt(pos) !== closeBracketCC && input[pos]) {\n\t\t\tconst c = input.charCodeAt(pos)\n\t\t\tif ((c > 64 && c < 91) || (c > 96 && c < 123)) {\n\t\t\t\tconst name = parseName()\n\t\t\t\tlet value: string = ''\n\t\t\t\t// search beginning of the string\n\t\t\t\tlet code = input.charCodeAt(pos)\n\t\t\t\twhile (code !== singleQuoteCC && code !== doubleQuoteCC) {\n\t\t\t\t\tpos++\n\t\t\t\t\tcode = input.charCodeAt(pos)\n\t\t\t\t}\n\n\t\t\t\tif (code === singleQuoteCC || code === doubleQuoteCC) {\n\t\t\t\t\tvalue = parseString()\n\t\t\t\t\tif (pos === -1) {\n\t\t\t\t\t\tthrow new Error('Missing closing quote')\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tpos--\n\t\t\t\t}\n\n\t\t\t\tattributes[name] = unescapeHtml(value)\n\t\t\t}\n\t\t\tpos++\n\t\t}\n\n\t\treturn attributes\n\t}\n\n\t/**\n\t * parses a node\n\t */\n\tfunction parseNode(): XmlNode {\n\t\tpos++\n\t\tconst nodeName = parseName()\n\t\tlet localName = nodeName\n\t\tlet prefix = null\n\n\t\tconst nsIndex = nodeName.indexOf(':')\n\t\tif (nsIndex !== -1) {\n\t\t\tprefix = nodeName.slice(0, nsIndex)\n\t\t\tlocalName = nodeName.slice(nsIndex + 1)\n\t\t}\n\n\t\tconst attributes = parseAttributes()\n\n\t\tlet childNodes: any[] = []\n\n\t\t// optional parsing of children\n\t\tconst prev = input.charCodeAt(pos - 1)\n\t\tpos++\n\n\t\tif (prev !== slashCC) {\n\t\t\tchildNodes = parseChildren(nodeName)\n\t\t}\n\n\t\treturn {\n\t\t\tnodeName,\n\t\t\tnodeValue: null,\n\t\t\tattributes,\n\t\t\tchildNodes,\n\t\t\tprefix,\n\t\t\tlocalName,\n\t\t}\n\t}\n\n\t/**\n\t * is parsing a string, that starts with a char and with the same usually ' or \"\n\t */\n\tfunction parseString(): string {\n\t\tconst startChar = input[pos]\n\t\tconst startpos = pos + 1\n\t\tpos = input.indexOf(startChar, startpos)\n\t\treturn input.slice(startpos, pos)\n\t}\n\n\treturn {\n\t\tnodeName: '#document',\n\t\tnodeValue: null,\n\t\tchildNodes: parseChildren(''),\n\t\tattributes: {},\n\t}\n}\n","import type { XmlNode } from './XmlNode.ts'\n\n/**\n * Basic xml encoding utility. Encodes XML into a string.\n *\n * @param xml - The XML node to encode\n * @returns The parsed XML\n *\n * @beta\n *\n * @example\n * {@includeCode ../test/serializeXml.test.ts#example}\n */\nexport function serializeXml(xml: XmlNode): string {\n\tconst { nodeName, attributes, childNodes } = xml\n\n\tif (nodeName === '#document') {\n\t\treturn `<?xml version=\"1.0\" encoding=\"UTF-8\"?>${serializeXml(childNodes[0])}`\n\t}\n\n\tif (nodeName === '#text') {\n\t\treturn xml.nodeValue || ''\n\t}\n\n\tlet result = `<${nodeName}`\n\n\tif (attributes) {\n\t\tfor (const key in attributes) {\n\t\t\tresult += ` ${key}=${JSON.stringify(attributes[key])}`\n\t\t}\n\t}\n\n\tlet children = ''\n\n\tconst childCount = childNodes?.length\n\n\tif (childCount) {\n\t\tfor (let i = 0; i < childCount; i++) {\n\t\t\tchildren += serializeXml(childNodes[i])\n\t\t}\n\t}\n\n\tconst close = (!children) ? ' />' : `>${children}</${nodeName}>`\n\tresult += close\n\n\treturn result\n}\n"],"mappings":"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"}