{"ast":null,"code":"import { mixNumber, percent, px } from 'motion-dom';\nimport { progress, circOut, noop } from 'motion-utils';\nconst borders = [\"TopLeft\", \"TopRight\", \"BottomLeft\", \"BottomRight\"];\nconst numBorders = borders.length;\nconst asNumber = value => typeof value === \"string\" ? parseFloat(value) : value;\nconst isPx = value => typeof value === \"number\" || px.test(value);\nfunction mixValues(target, follow, lead, progress, shouldCrossfadeOpacity, isOnlyMember) {\n  if (shouldCrossfadeOpacity) {\n    var _lead$opacity, _follow$opacity;\n    target.opacity = mixNumber(0, (_lead$opacity = lead.opacity) !== null && _lead$opacity !== void 0 ? _lead$opacity : 1, easeCrossfadeIn(progress));\n    target.opacityExit = mixNumber((_follow$opacity = follow.opacity) !== null && _follow$opacity !== void 0 ? _follow$opacity : 1, 0, easeCrossfadeOut(progress));\n  } else if (isOnlyMember) {\n    var _follow$opacity2, _lead$opacity2;\n    target.opacity = mixNumber((_follow$opacity2 = follow.opacity) !== null && _follow$opacity2 !== void 0 ? _follow$opacity2 : 1, (_lead$opacity2 = lead.opacity) !== null && _lead$opacity2 !== void 0 ? _lead$opacity2 : 1, progress);\n  }\n  /**\n   * Mix border radius\n   */\n  for (let i = 0; i < numBorders; i++) {\n    const borderLabel = \"border\".concat(borders[i], \"Radius\");\n    let followRadius = getRadius(follow, borderLabel);\n    let leadRadius = getRadius(lead, borderLabel);\n    if (followRadius === undefined && leadRadius === undefined) continue;\n    followRadius || (followRadius = 0);\n    leadRadius || (leadRadius = 0);\n    const canMix = followRadius === 0 || leadRadius === 0 || isPx(followRadius) === isPx(leadRadius);\n    if (canMix) {\n      target[borderLabel] = Math.max(mixNumber(asNumber(followRadius), asNumber(leadRadius), progress), 0);\n      if (percent.test(leadRadius) || percent.test(followRadius)) {\n        target[borderLabel] += \"%\";\n      }\n    } else {\n      target[borderLabel] = leadRadius;\n    }\n  }\n  /**\n   * Mix rotation\n   */\n  if (follow.rotate || lead.rotate) {\n    target.rotate = mixNumber(follow.rotate || 0, lead.rotate || 0, progress);\n  }\n}\nfunction getRadius(values, radiusName) {\n  return values[radiusName] !== undefined ? values[radiusName] : values.borderRadius;\n}\n// /**\n//  * We only want to mix the background color if there's a follow element\n//  * that we're not crossfading opacity between. For instance with switch\n//  * AnimateSharedLayout animations, this helps the illusion of a continuous\n//  * element being animated but also cuts down on the number of paints triggered\n//  * for elements where opacity is doing that work for us.\n//  */\n// if (\n//     !hasFollowElement &&\n//     latestLeadValues.backgroundColor &&\n//     latestFollowValues.backgroundColor\n// ) {\n//     /**\n//      * This isn't ideal performance-wise as mixColor is creating a new function every frame.\n//      * We could probably create a mixer that runs at the start of the animation but\n//      * the idea behind the crossfader is that it runs dynamically between two potentially\n//      * changing targets (ie opacity or borderRadius may be animating independently via variants)\n//      */\n//     leadState.backgroundColor = followState.backgroundColor = mixColor(\n//         latestFollowValues.backgroundColor as string,\n//         latestLeadValues.backgroundColor as string\n//     )(p)\n// }\nconst easeCrossfadeIn = /*@__PURE__*/compress(0, 0.5, circOut);\nconst easeCrossfadeOut = /*@__PURE__*/compress(0.5, 0.95, noop);\nfunction compress(min, max, easing) {\n  return p => {\n    // Could replace ifs with clamp\n    if (p < min) return 0;\n    if (p > max) return 1;\n    return easing(progress(min, max, p));\n  };\n}\nexport { mixValues };","map":{"version":3,"names":["borders","numBorders","length","asNumber","value","parseFloat","isPx","px","test","mixValues","target","follow","lead","progress","shouldCrossfadeOpacity","isOnlyMember","_lead$opacity","_follow$opacity","opacity","mixNumber","easeCrossfadeIn","opacityExit","easeCrossfadeOut","_follow$opacity2","_lead$opacity2","i","borderLabel","concat","followRadius","getRadius","leadRadius","undefined","canMix","Math","max","percent","rotate","values","radiusName","borderRadius","compress","circOut","noop","min","easing","p"],"sources":["/app/frontend/node_modules/framer-motion/src/projection/animation/mix-values.ts"],"sourcesContent":["import { type AnyResolvedKeyframe, mixNumber, percent, px } from \"motion-dom\"\nimport {\n    progress as calcProgress,\n    circOut,\n    EasingFunction,\n    noop,\n} from \"motion-utils\"\nimport { ResolvedValues } from \"../../render/types\"\n\nconst borders = [\"TopLeft\", \"TopRight\", \"BottomLeft\", \"BottomRight\"]\nconst numBorders = borders.length\n\nconst asNumber = (value: AnyResolvedKeyframe) =>\n    typeof value === \"string\" ? parseFloat(value) : value\n\nconst isPx = (value: AnyResolvedKeyframe) =>\n    typeof value === \"number\" || px.test(value)\n\nexport function mixValues(\n    target: ResolvedValues,\n    follow: ResolvedValues,\n    lead: ResolvedValues,\n    progress: number,\n    shouldCrossfadeOpacity: boolean,\n    isOnlyMember: boolean\n) {\n    if (shouldCrossfadeOpacity) {\n        target.opacity = mixNumber(\n            0,\n            (lead.opacity as number) ?? 1,\n            easeCrossfadeIn(progress)\n        )\n        target.opacityExit = mixNumber(\n            (follow.opacity as number) ?? 1,\n            0,\n            easeCrossfadeOut(progress)\n        )\n    } else if (isOnlyMember) {\n        target.opacity = mixNumber(\n            (follow.opacity as number) ?? 1,\n            (lead.opacity as number) ?? 1,\n            progress\n        )\n    }\n\n    /**\n     * Mix border radius\n     */\n    for (let i = 0; i < numBorders; i++) {\n        const borderLabel = `border${borders[i]}Radius`\n        let followRadius = getRadius(follow, borderLabel)\n        let leadRadius = getRadius(lead, borderLabel)\n\n        if (followRadius === undefined && leadRadius === undefined) continue\n\n        followRadius ||= 0\n        leadRadius ||= 0\n\n        const canMix =\n            followRadius === 0 ||\n            leadRadius === 0 ||\n            isPx(followRadius) === isPx(leadRadius)\n\n        if (canMix) {\n            target[borderLabel] = Math.max(\n                mixNumber(\n                    asNumber(followRadius),\n                    asNumber(leadRadius),\n                    progress\n                ),\n                0\n            )\n\n            if (percent.test(leadRadius) || percent.test(followRadius)) {\n                target[borderLabel] += \"%\"\n            }\n        } else {\n            target[borderLabel] = leadRadius\n        }\n    }\n\n    /**\n     * Mix rotation\n     */\n    if (follow.rotate || lead.rotate) {\n        target.rotate = mixNumber(\n            (follow.rotate as number) || 0,\n            (lead.rotate as number) || 0,\n            progress\n        )\n    }\n}\n\nfunction getRadius(values: ResolvedValues, radiusName: string) {\n    return values[radiusName] !== undefined\n        ? values[radiusName]\n        : values.borderRadius\n}\n\n// /**\n//  * We only want to mix the background color if there's a follow element\n//  * that we're not crossfading opacity between. For instance with switch\n//  * AnimateSharedLayout animations, this helps the illusion of a continuous\n//  * element being animated but also cuts down on the number of paints triggered\n//  * for elements where opacity is doing that work for us.\n//  */\n// if (\n//     !hasFollowElement &&\n//     latestLeadValues.backgroundColor &&\n//     latestFollowValues.backgroundColor\n// ) {\n//     /**\n//      * This isn't ideal performance-wise as mixColor is creating a new function every frame.\n//      * We could probably create a mixer that runs at the start of the animation but\n//      * the idea behind the crossfader is that it runs dynamically between two potentially\n//      * changing targets (ie opacity or borderRadius may be animating independently via variants)\n//      */\n//     leadState.backgroundColor = followState.backgroundColor = mixColor(\n//         latestFollowValues.backgroundColor as string,\n//         latestLeadValues.backgroundColor as string\n//     )(p)\n// }\n\nconst easeCrossfadeIn = /*@__PURE__*/ compress(0, 0.5, circOut)\nconst easeCrossfadeOut = /*@__PURE__*/ compress(0.5, 0.95, noop)\n\nfunction compress(\n    min: number,\n    max: number,\n    easing: EasingFunction\n): EasingFunction {\n    return (p: number) => {\n        // Could replace ifs with clamp\n        if (p < min) return 0\n        if (p > max) return 1\n        return easing(calcProgress(min, max, p))\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}