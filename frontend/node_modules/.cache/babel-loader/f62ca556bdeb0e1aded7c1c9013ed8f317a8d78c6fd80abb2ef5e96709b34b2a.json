{"ast":null,"code":"import { CustomVideoElement } from \"custom-media-element\";\nimport { MediaTracksMixin } from \"media-tracks\";\nclass DashVideoElement extends MediaTracksMixin(CustomVideoElement) {\n  static shadowRootOptions = {\n    ...CustomVideoElement.shadowRootOptions\n  };\n  static getTemplateHTML = attrs => {\n    const {\n      src,\n      ...rest\n    } = attrs;\n    return CustomVideoElement.getTemplateHTML(rest);\n  };\n  #apiInit;\n  attributeChangedCallback(attrName, oldValue, newValue) {\n    if (attrName !== \"src\") {\n      super.attributeChangedCallback(attrName, oldValue, newValue);\n    }\n    if (attrName === \"src\" && oldValue != newValue) {\n      this.load();\n    }\n  }\n  async _initThumbnails(representation) {\n    const generateAllCues = async (totalThumbnails2, thumbnailDuration2) => {\n      const promises = [];\n      const timescale = representation.timescale || 1;\n      const startNumber = representation.startNumber || 1;\n      const pto = representation.presentationTimeOffset ? representation.presentationTimeOffset / timescale : 0;\n      const tduration = representation.segmentDuration;\n      for (let thIndex = 0; thIndex < totalThumbnails2; thIndex++) {\n        const startTime = calculateThumbnailStartTime({\n          thIndex,\n          thduration: thumbnailDuration2,\n          ttiles: totalThumbnails2,\n          tduration,\n          startNumber,\n          pto\n        });\n        const endTime = startTime + thumbnailDuration2;\n        const promise = new Promise((resolve, reject) => {\n          this.api.provideThumbnail(startTime, ({\n            url,\n            width,\n            height,\n            x,\n            y\n          }) => {\n            try {\n              const cue = new VTTCue(startTime, endTime, `${url}#xywh=${x},${y},${width},${height}`);\n              resolve(cue);\n            } catch (err) {\n              reject(err);\n            }\n          });\n        });\n        promises.push(promise);\n      }\n      return await Promise.all(promises).catch(e => console.error(\"Error processing thumbnails\", e));\n    };\n    const {\n      totalThumbnails,\n      thumbnailDuration\n    } = calculateThumbnailTimes(representation);\n    const cues = await generateAllCues(totalThumbnails, thumbnailDuration);\n    let track = this.nativeEl.querySelector('track[label=\"thumbnails\"]');\n    if (!track) {\n      track = createThumbnailTrack();\n      this.nativeEl.appendChild(track);\n      const vttUrl = cuesToVttBlobUrl(cues);\n      track.src = vttUrl;\n      track.dispatchEvent(new Event(\"change\"));\n    }\n  }\n  async load() {\n    if (this.#apiInit) {\n      this.api.attachSource(this.src);\n      return;\n    }\n    this.#apiInit = true;\n    const Dash = await import(\"dashjs\");\n    this.api = Dash.MediaPlayer().create();\n    this.api.initialize(this.nativeEl, this.src, this.autoplay);\n    this.api.on(Dash.MediaPlayer.events.STREAM_INITIALIZED, () => {\n      const bitrateList = this.api.getRepresentationsByType(\"video\");\n      let videoTrack = this.videoTracks.getTrackById(\"main\");\n      if (!videoTrack) {\n        videoTrack = this.addVideoTrack(\"main\");\n        videoTrack.id = \"main\";\n        videoTrack.selected = true;\n      }\n      bitrateList.forEach(rep => {\n        const bitrate = rep.bandwidth ?? rep.bitrate ?? (Number.isFinite(rep.bitrateInKbit) ? rep.bitrateInKbit * 1e3 : void 0);\n        const rendition = videoTrack.addRendition(rep.id, rep.width, rep.height, rep.mimeType ?? rep.codec, bitrate);\n        rendition.id = rep.id;\n      });\n      this.videoRenditions.addEventListener(\"change\", () => {\n        const selected = this.videoRenditions[this.videoRenditions.selectedIndex];\n        if (selected == null ? void 0 : selected.id) {\n          this.api.updateSettings({\n            streaming: {\n              abr: {\n                autoSwitchBitrate: {\n                  video: false\n                }\n              }\n            }\n          });\n          this.api.setRepresentationForTypeById(\"video\", selected.id, true);\n        } else {\n          this.api.updateSettings({\n            streaming: {\n              abr: {\n                autoSwitchBitrate: {\n                  video: true\n                }\n              }\n            }\n          });\n        }\n      });\n      if (!this.api.isDynamic()) {\n        const imageReps = this.api.getRepresentationsByType(\"image\");\n        imageReps.forEach(async (rep, idx) => {\n          if (idx > 0) return;\n          this._initThumbnails(rep);\n        });\n      }\n    });\n  }\n}\nfunction calculateThumbnailTimes(representation) {\n  var _a, _b;\n  const essentialProp = representation.essentialProperties[0];\n  const [htiles, vtiles] = essentialProp.value.split(\"x\").map(Number);\n  const ttiles = htiles * vtiles;\n  const periodDuration = ((_b = (_a = representation.adaptation) == null ? void 0 : _a.period) == null ? void 0 : _b.duration) || null;\n  const tileDuration = representation.segmentDuration;\n  const timescale = representation.timescale || 1;\n  const tduration = tileDuration / timescale;\n  const thduration = tduration / ttiles;\n  const totalThumbnails = periodDuration != null ? Math.ceil(periodDuration / thduration) : Math.ceil(tileDuration / thduration);\n  return {\n    totalThumbnails,\n    thumbnailDuration: thduration\n  };\n}\nfunction calculateThumbnailStartTime({\n  thIndex,\n  tduration,\n  thduration,\n  ttiles,\n  startNumber,\n  pto\n}) {\n  const tnumber = Math.floor(thIndex / ttiles) + startNumber;\n  const thnumber = thIndex % ttiles + 1;\n  const tileStartTime = (tnumber - 1) * tduration - pto;\n  const thumbnailStartTime = (thnumber - 1) * thduration;\n  return tileStartTime + thumbnailStartTime;\n}\nfunction createThumbnailTrack() {\n  const track = document.createElement(\"track\");\n  track.kind = \"metadata\";\n  track.label = \"thumbnails\";\n  track.srclang = \"en\";\n  track.mode = \"hidden\";\n  track.default = true;\n  return track;\n}\nfunction cuesToVttBlobUrl(cues) {\n  let vtt = \"WEBVTT\\n\\n\";\n  for (const cue of cues) {\n    vtt += `${formatTime(cue.startTime)} --> ${formatTime(cue.endTime)}\n`;\n    vtt += `${cue.text}\n\n`;\n  }\n  const blob = new Blob([vtt], {\n    type: \"text/vtt\"\n  });\n  return URL.createObjectURL(blob);\n  function formatTime(t) {\n    const h = String(Math.floor(t / 3600)).padStart(2, \"0\");\n    const m = String(Math.floor(t % 3600 / 60)).padStart(2, \"0\");\n    const s = (t % 60).toFixed(3).padStart(6, \"0\");\n    return `${h}:${m}:${s}`;\n  }\n}\nif (globalThis.customElements && !globalThis.customElements.get(\"dash-video\")) {\n  globalThis.customElements.define(\"dash-video\", DashVideoElement);\n}\nvar dash_video_element_default = DashVideoElement;\nexport { dash_video_element_default as default };","map":{"version":3,"names":["CustomVideoElement","MediaTracksMixin","DashVideoElement","shadowRootOptions","getTemplateHTML","attrs","src","rest","apiInit","attributeChangedCallback","attrName","oldValue","newValue","load","_initThumbnails","representation","generateAllCues","totalThumbnails2","thumbnailDuration2","promises","timescale","startNumber","pto","presentationTimeOffset","tduration","segmentDuration","thIndex","startTime","calculateThumbnailStartTime","thduration","ttiles","endTime","promise","Promise","resolve","reject","api","provideThumbnail","url","width","height","x","y","cue","VTTCue","err","push","all","catch","e","console","error","totalThumbnails","thumbnailDuration","calculateThumbnailTimes","cues","track","nativeEl","querySelector","createThumbnailTrack","appendChild","vttUrl","cuesToVttBlobUrl","dispatchEvent","Event","attachSource","Dash","MediaPlayer","create","initialize","autoplay","on","events","STREAM_INITIALIZED","bitrateList","getRepresentationsByType","videoTrack","videoTracks","getTrackById","addVideoTrack","id","selected","forEach","rep","bitrate","bandwidth","Number","isFinite","bitrateInKbit","rendition","addRendition","mimeType","codec","videoRenditions","addEventListener","selectedIndex","updateSettings","streaming","abr","autoSwitchBitrate","video","setRepresentationForTypeById","isDynamic","imageReps","idx","_a","_b","essentialProp","essentialProperties","htiles","vtiles","value","split","map","periodDuration","adaptation","period","duration","tileDuration","Math","ceil","tnumber","floor","thnumber","tileStartTime","thumbnailStartTime","document","createElement","kind","label","srclang","mode","default","vtt","formatTime","text","blob","Blob","type","URL","createObjectURL","t","h","String","padStart","m","s","toFixed","globalThis","customElements","get","define","dash_video_element_default"],"sources":["/app/frontend/node_modules/dash-video-element/dist/dash-video-element.js"],"sourcesContent":["import { CustomVideoElement } from \"custom-media-element\";\nimport { MediaTracksMixin } from \"media-tracks\";\nclass DashVideoElement extends MediaTracksMixin(CustomVideoElement) {\n  static shadowRootOptions = { ...CustomVideoElement.shadowRootOptions };\n  static getTemplateHTML = (attrs) => {\n    const { src, ...rest } = attrs;\n    return CustomVideoElement.getTemplateHTML(rest);\n  };\n  #apiInit;\n  attributeChangedCallback(attrName, oldValue, newValue) {\n    if (attrName !== \"src\") {\n      super.attributeChangedCallback(attrName, oldValue, newValue);\n    }\n    if (attrName === \"src\" && oldValue != newValue) {\n      this.load();\n    }\n  }\n  async _initThumbnails(representation) {\n    const generateAllCues = async (totalThumbnails2, thumbnailDuration2) => {\n      const promises = [];\n      const timescale = representation.timescale || 1;\n      const startNumber = representation.startNumber || 1;\n      const pto = representation.presentationTimeOffset ? representation.presentationTimeOffset / timescale : 0;\n      const tduration = representation.segmentDuration;\n      for (let thIndex = 0; thIndex < totalThumbnails2; thIndex++) {\n        const startTime = calculateThumbnailStartTime({\n          thIndex,\n          thduration: thumbnailDuration2,\n          ttiles: totalThumbnails2,\n          tduration,\n          startNumber,\n          pto\n        });\n        const endTime = startTime + thumbnailDuration2;\n        const promise = new Promise((resolve, reject) => {\n          this.api.provideThumbnail(startTime, ({ url, width, height, x, y }) => {\n            try {\n              const cue = new VTTCue(\n                startTime,\n                endTime,\n                `${url}#xywh=${x},${y},${width},${height}`\n              );\n              resolve(cue);\n            } catch (err) {\n              reject(err);\n            }\n          });\n        });\n        promises.push(promise);\n      }\n      return await Promise.all(promises).catch((e) => console.error(\"Error processing thumbnails\", e));\n    };\n    const { totalThumbnails, thumbnailDuration } = calculateThumbnailTimes(representation);\n    const cues = await generateAllCues(totalThumbnails, thumbnailDuration);\n    let track = this.nativeEl.querySelector('track[label=\"thumbnails\"]');\n    if (!track) {\n      track = createThumbnailTrack();\n      this.nativeEl.appendChild(track);\n      const vttUrl = cuesToVttBlobUrl(cues);\n      track.src = vttUrl;\n      track.dispatchEvent(new Event(\"change\"));\n    }\n  }\n  async load() {\n    if (this.#apiInit) {\n      this.api.attachSource(this.src);\n      return;\n    }\n    this.#apiInit = true;\n    const Dash = await import(\"dashjs\");\n    this.api = Dash.MediaPlayer().create();\n    this.api.initialize(this.nativeEl, this.src, this.autoplay);\n    this.api.on(Dash.MediaPlayer.events.STREAM_INITIALIZED, () => {\n      const bitrateList = this.api.getRepresentationsByType(\"video\");\n      let videoTrack = this.videoTracks.getTrackById(\"main\");\n      if (!videoTrack) {\n        videoTrack = this.addVideoTrack(\"main\");\n        videoTrack.id = \"main\";\n        videoTrack.selected = true;\n      }\n      bitrateList.forEach((rep) => {\n        const bitrate = rep.bandwidth ?? rep.bitrate ?? (Number.isFinite(rep.bitrateInKbit) ? rep.bitrateInKbit * 1e3 : void 0);\n        const rendition = videoTrack.addRendition(rep.id, rep.width, rep.height, rep.mimeType ?? rep.codec, bitrate);\n        rendition.id = rep.id;\n      });\n      this.videoRenditions.addEventListener(\"change\", () => {\n        const selected = this.videoRenditions[this.videoRenditions.selectedIndex];\n        if (selected == null ? void 0 : selected.id) {\n          this.api.updateSettings({ streaming: { abr: { autoSwitchBitrate: { video: false } } } });\n          this.api.setRepresentationForTypeById(\"video\", selected.id, true);\n        } else {\n          this.api.updateSettings({ streaming: { abr: { autoSwitchBitrate: { video: true } } } });\n        }\n      });\n      if (!this.api.isDynamic()) {\n        const imageReps = this.api.getRepresentationsByType(\"image\");\n        imageReps.forEach(async (rep, idx) => {\n          if (idx > 0) return;\n          this._initThumbnails(rep);\n        });\n      }\n    });\n  }\n}\nfunction calculateThumbnailTimes(representation) {\n  var _a, _b;\n  const essentialProp = representation.essentialProperties[0];\n  const [htiles, vtiles] = essentialProp.value.split(\"x\").map(Number);\n  const ttiles = htiles * vtiles;\n  const periodDuration = ((_b = (_a = representation.adaptation) == null ? void 0 : _a.period) == null ? void 0 : _b.duration) || null;\n  const tileDuration = representation.segmentDuration;\n  const timescale = representation.timescale || 1;\n  const tduration = tileDuration / timescale;\n  const thduration = tduration / ttiles;\n  const totalThumbnails = periodDuration != null ? Math.ceil(periodDuration / thduration) : Math.ceil(tileDuration / thduration);\n  return { totalThumbnails, thumbnailDuration: thduration };\n}\nfunction calculateThumbnailStartTime({ thIndex, tduration, thduration, ttiles, startNumber, pto }) {\n  const tnumber = Math.floor(thIndex / ttiles) + startNumber;\n  const thnumber = thIndex % ttiles + 1;\n  const tileStartTime = (tnumber - 1) * tduration - pto;\n  const thumbnailStartTime = (thnumber - 1) * thduration;\n  return tileStartTime + thumbnailStartTime;\n}\nfunction createThumbnailTrack() {\n  const track = document.createElement(\"track\");\n  track.kind = \"metadata\";\n  track.label = \"thumbnails\";\n  track.srclang = \"en\";\n  track.mode = \"hidden\";\n  track.default = true;\n  return track;\n}\nfunction cuesToVttBlobUrl(cues) {\n  let vtt = \"WEBVTT\\n\\n\";\n  for (const cue of cues) {\n    vtt += `${formatTime(cue.startTime)} --> ${formatTime(cue.endTime)}\n`;\n    vtt += `${cue.text}\n\n`;\n  }\n  const blob = new Blob([vtt], { type: \"text/vtt\" });\n  return URL.createObjectURL(blob);\n  function formatTime(t) {\n    const h = String(Math.floor(t / 3600)).padStart(2, \"0\");\n    const m = String(Math.floor(t % 3600 / 60)).padStart(2, \"0\");\n    const s = (t % 60).toFixed(3).padStart(6, \"0\");\n    return `${h}:${m}:${s}`;\n  }\n}\nif (globalThis.customElements && !globalThis.customElements.get(\"dash-video\")) {\n  globalThis.customElements.define(\"dash-video\", DashVideoElement);\n}\nvar dash_video_element_default = DashVideoElement;\nexport {\n  dash_video_element_default as default\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}