{"ast":null,"code":"import _classPrivateMethodInitSpec from \"/app/frontend/node_modules/@babel/runtime/helpers/esm/classPrivateMethodInitSpec.js\";\nimport _classPrivateFieldInitSpec from \"/app/frontend/node_modules/@babel/runtime/helpers/esm/classPrivateFieldInitSpec.js\";\nimport _classPrivateFieldGet from \"/app/frontend/node_modules/@babel/runtime/helpers/esm/classPrivateFieldGet2.js\";\nimport _classPrivateGetter from \"/app/frontend/node_modules/@babel/runtime/helpers/esm/classPrivateGetter.js\";\nimport _assertClassBrand from \"/app/frontend/node_modules/@babel/runtime/helpers/esm/assertClassBrand.js\";\nimport _classPrivateFieldSet from \"/app/frontend/node_modules/@babel/runtime/helpers/esm/classPrivateFieldSet2.js\";\n/* global chrome, cast */\nimport { privateProps, IterableWeakSet, InvalidStateError, NotSupportedError, onCastApiAvailable, castContext, currentSession, currentMedia, editTracksInfo, getMediaStatus, setCastOptions } from './castable-utils.js';\nconst remoteInstances = new IterableWeakSet();\nconst castElementRef = new WeakSet();\nlet cf;\nonCastApiAvailable(() => {\n  var _globalThis$chrome;\n  if (!((_globalThis$chrome = globalThis.chrome) !== null && _globalThis$chrome !== void 0 && (_globalThis$chrome = _globalThis$chrome.cast) !== null && _globalThis$chrome !== void 0 && _globalThis$chrome.isAvailable)) {\n    var _globalThis$chrome2;\n    // Useful to see in verbose logs if this shows undefined or false.\n    console.debug('chrome.cast.isAvailable', (_globalThis$chrome2 = globalThis.chrome) === null || _globalThis$chrome2 === void 0 || (_globalThis$chrome2 = _globalThis$chrome2.cast) === null || _globalThis$chrome2 === void 0 ? void 0 : _globalThis$chrome2.isAvailable);\n    return;\n  }\n  if (!cf) {\n    cf = cast.framework;\n    castContext().addEventListener(cf.CastContextEventType.CAST_STATE_CHANGED, e => {\n      remoteInstances.forEach(r => {\n        var _privateProps$get$onC, _privateProps$get;\n        return (_privateProps$get$onC = (_privateProps$get = privateProps.get(r)).onCastStateChanged) === null || _privateProps$get$onC === void 0 ? void 0 : _privateProps$get$onC.call(_privateProps$get, e);\n      });\n    });\n    castContext().addEventListener(cf.CastContextEventType.SESSION_STATE_CHANGED, e => {\n      remoteInstances.forEach(r => {\n        var _privateProps$get$onS, _privateProps$get2;\n        return (_privateProps$get$onS = (_privateProps$get2 = privateProps.get(r)).onSessionStateChanged) === null || _privateProps$get$onS === void 0 ? void 0 : _privateProps$get$onS.call(_privateProps$get2, e);\n      });\n    });\n    remoteInstances.forEach(r => {\n      var _privateProps$get$ini, _privateProps$get3;\n      return (_privateProps$get$ini = (_privateProps$get3 = privateProps.get(r)).init) === null || _privateProps$get$ini === void 0 ? void 0 : _privateProps$get$ini.call(_privateProps$get3);\n    });\n  }\n});\nlet remotePlaybackCallbackIdCount = 0;\n\n/**\n * Remote Playback shim for the Google cast SDK.\n * https://w3c.github.io/remote-playback/\n */\nvar _media = /*#__PURE__*/new WeakMap();\nvar _isInit = /*#__PURE__*/new WeakMap();\nvar _remotePlayer = /*#__PURE__*/new WeakMap();\nvar _remoteListeners = /*#__PURE__*/new WeakMap();\nvar _state = /*#__PURE__*/new WeakMap();\nvar _available = /*#__PURE__*/new WeakMap();\nvar _callbacks = /*#__PURE__*/new WeakMap();\nvar _callbackIds = /*#__PURE__*/new WeakMap();\nvar _RemotePlayback_brand = /*#__PURE__*/new WeakSet();\nexport class RemotePlayback extends EventTarget {\n  constructor(media) {\n    super();\n    _classPrivateMethodInitSpec(this, _RemotePlayback_brand);\n    _classPrivateFieldInitSpec(this, _media, void 0);\n    _classPrivateFieldInitSpec(this, _isInit, void 0);\n    _classPrivateFieldInitSpec(this, _remotePlayer, void 0);\n    _classPrivateFieldInitSpec(this, _remoteListeners, void 0);\n    _classPrivateFieldInitSpec(this, _state, 'disconnected');\n    _classPrivateFieldInitSpec(this, _available, false);\n    _classPrivateFieldInitSpec(this, _callbacks, new Set());\n    _classPrivateFieldInitSpec(this, _callbackIds, new WeakMap());\n    _classPrivateFieldSet(_media, this, media);\n    remoteInstances.add(this);\n    privateProps.set(this, {\n      init: () => _assertClassBrand(_RemotePlayback_brand, this, _init).call(this),\n      onCastStateChanged: () => _assertClassBrand(_RemotePlayback_brand, this, _onCastStateChanged).call(this),\n      onSessionStateChanged: () => _assertClassBrand(_RemotePlayback_brand, this, _onSessionStateChanged).call(this),\n      getCastPlayer: () => _classPrivateGetter(_RemotePlayback_brand, this, _get_castPlayer)\n    });\n    _assertClassBrand(_RemotePlayback_brand, this, _init).call(this);\n  }\n  /**\n   * https://developer.mozilla.org/en-US/docs/Web/API/RemotePlayback/state\n   * @return {'disconnected'|'connecting'|'connected'}\n   */\n  get state() {\n    return _classPrivateFieldGet(_state, this);\n  }\n  async watchAvailability(callback) {\n    if (_classPrivateFieldGet(_media, this).disableRemotePlayback) {\n      throw new InvalidStateError('disableRemotePlayback attribute is present.');\n    }\n    _classPrivateFieldGet(_callbackIds, this).set(callback, ++remotePlaybackCallbackIdCount);\n    _classPrivateFieldGet(_callbacks, this).add(callback);\n\n    // https://w3c.github.io/remote-playback/#getting-the-remote-playback-devices-availability-information\n    queueMicrotask(() => callback(_assertClassBrand(_RemotePlayback_brand, this, _hasDevicesAvailable).call(this)));\n    return remotePlaybackCallbackIdCount;\n  }\n  async cancelWatchAvailability(callback) {\n    if (_classPrivateFieldGet(_media, this).disableRemotePlayback) {\n      throw new InvalidStateError('disableRemotePlayback attribute is present.');\n    }\n    if (callback) {\n      _classPrivateFieldGet(_callbacks, this).delete(callback);\n    } else {\n      _classPrivateFieldGet(_callbacks, this).clear();\n    }\n  }\n  async prompt() {\n    var _globalThis$chrome3, _privateProps$get4, _privateProps$get4$lo;\n    if (_classPrivateFieldGet(_media, this).disableRemotePlayback) {\n      throw new InvalidStateError('disableRemotePlayback attribute is present.');\n    }\n    if (!((_globalThis$chrome3 = globalThis.chrome) !== null && _globalThis$chrome3 !== void 0 && (_globalThis$chrome3 = _globalThis$chrome3.cast) !== null && _globalThis$chrome3 !== void 0 && _globalThis$chrome3.isAvailable)) {\n      throw new NotSupportedError('The RemotePlayback API is disabled on this platform.');\n    }\n    const willDisconnect = castElementRef.has(_classPrivateFieldGet(_media, this));\n    castElementRef.add(_classPrivateFieldGet(_media, this));\n    setCastOptions(_classPrivateFieldGet(_media, this).castOptions);\n    Object.entries(_classPrivateFieldGet(_remoteListeners, this)).forEach(_ref => {\n      let [event, listener] = _ref;\n      _classPrivateFieldGet(_remotePlayer, this).controller.addEventListener(event, listener);\n    });\n    try {\n      // Open browser cast menu.\n      await castContext().requestSession();\n    } catch (err) {\n      // If there will be no disconnect, reset some state here.\n      if (!willDisconnect) {\n        castElementRef.delete(_classPrivateFieldGet(_media, this));\n      }\n\n      // Don't throw an error if disconnecting or cancelling.\n      if (err === 'cancel') {\n        return;\n      }\n      throw new Error(err);\n    }\n    (_privateProps$get4 = privateProps.get(_classPrivateFieldGet(_media, this))) === null || _privateProps$get4 === void 0 || (_privateProps$get4$lo = _privateProps$get4.loadOnPrompt) === null || _privateProps$get4$lo === void 0 || _privateProps$get4$lo.call(_privateProps$get4);\n  }\n}\nfunction _get_castPlayer(_this) {\n  if (castElementRef.has(_classPrivateFieldGet(_media, _this))) return _classPrivateFieldGet(_remotePlayer, _this);\n  return undefined;\n}\nfunction _disconnect() {\n  if (!castElementRef.has(_classPrivateFieldGet(_media, this))) return;\n  Object.entries(_classPrivateFieldGet(_remoteListeners, this)).forEach(_ref2 => {\n    let [event, listener] = _ref2;\n    _classPrivateFieldGet(_remotePlayer, this).controller.removeEventListener(event, listener);\n  });\n  castElementRef.delete(_classPrivateFieldGet(_media, this));\n\n  // isMuted is not in savedPlayerState. should we sync this back to local?\n  _classPrivateFieldGet(_media, this).muted = _classPrivateFieldGet(_remotePlayer, this).isMuted;\n  _classPrivateFieldGet(_media, this).currentTime = _classPrivateFieldGet(_remotePlayer, this).savedPlayerState.currentTime;\n  if (_classPrivateFieldGet(_remotePlayer, this).savedPlayerState.isPaused === false) {\n    _classPrivateFieldGet(_media, this).play();\n  }\n}\nfunction _hasDevicesAvailable() {\n  var _castContext;\n  // Cast state: NO_DEVICES_AVAILABLE, NOT_CONNECTED, CONNECTING, CONNECTED\n  // https://developers.google.com/cast/docs/reference/web_sender/cast.framework#.CastState\n  const castState = (_castContext = castContext()) === null || _castContext === void 0 ? void 0 : _castContext.getCastState();\n  return castState && castState !== 'NO_DEVICES_AVAILABLE';\n}\nfunction _onCastStateChanged() {\n  // Cast state: NO_DEVICES_AVAILABLE, NOT_CONNECTED, CONNECTING, CONNECTED\n  // https://developers.google.com/cast/docs/reference/web_sender/cast.framework#.CastState\n  const castState = castContext().getCastState();\n  if (castElementRef.has(_classPrivateFieldGet(_media, this))) {\n    if (castState === 'CONNECTING') {\n      _classPrivateFieldSet(_state, this, 'connecting');\n      this.dispatchEvent(new Event('connecting'));\n    }\n  }\n  if (!_classPrivateFieldGet(_available, this) && castState !== null && castState !== void 0 && castState.includes('CONNECT')) {\n    _classPrivateFieldSet(_available, this, true);\n    for (let callback of _classPrivateFieldGet(_callbacks, this)) callback(true);\n  } else if (_classPrivateFieldGet(_available, this) && (!castState || castState === 'NO_DEVICES_AVAILABLE')) {\n    _classPrivateFieldSet(_available, this, false);\n    for (let callback of _classPrivateFieldGet(_callbacks, this)) callback(false);\n  }\n}\nasync function _onSessionStateChanged() {\n  // Session states: NO_SESSION, SESSION_STARTING, SESSION_STARTED, SESSION_START_FAILED,\n  //                 SESSION_ENDING, SESSION_ENDED, SESSION_RESUMED\n  // https://developers.google.com/cast/docs/reference/web_sender/cast.framework#.SessionState\n\n  const {\n    SESSION_RESUMED\n  } = cf.SessionState;\n  if (castContext().getSessionState() === SESSION_RESUMED) {\n    var _currentMedia;\n    /**\n     * Figure out if this was the video that started the resumed session.\n     * @TODO make this more specific than just checking against the video src!! (WL)\n     *\n     * If this video element can get the same unique id on each browser refresh\n     * it would be possible to pass this unique id w/ `LoadRequest.customData`\n     * and verify against currentMedia().customData below.\n     */\n    if (_classPrivateFieldGet(_media, this).castSrc === ((_currentMedia = currentMedia()) === null || _currentMedia === void 0 ? void 0 : _currentMedia.media.contentId)) {\n      castElementRef.add(_classPrivateFieldGet(_media, this));\n      Object.entries(_classPrivateFieldGet(_remoteListeners, this)).forEach(_ref3 => {\n        let [event, listener] = _ref3;\n        _classPrivateFieldGet(_remotePlayer, this).controller.addEventListener(event, listener);\n      });\n\n      /**\n       * There is cast framework resume session bug when you refresh the page a few\n       * times the this.#remotePlayer.currentTime will not be in sync with the receiver :(\n       * The below status request syncs it back up.\n       */\n      try {\n        await getMediaStatus(new chrome.cast.media.GetStatusRequest());\n      } catch (error) {\n        console.error(error);\n      }\n\n      // Dispatch the play, playing events manually to sync remote playing state.\n      _classPrivateFieldGet(_remoteListeners, this)[cf.RemotePlayerEventType.IS_PAUSED_CHANGED]();\n      _classPrivateFieldGet(_remoteListeners, this)[cf.RemotePlayerEventType.PLAYER_STATE_CHANGED]();\n    }\n  }\n}\nfunction _init() {\n  if (!cf || _classPrivateFieldGet(_isInit, this)) return;\n  _classPrivateFieldSet(_isInit, this, true);\n  setCastOptions(_classPrivateFieldGet(_media, this).castOptions);\n\n  /**\n   * @TODO add listeners for addtrack, removetrack (WL)\n   * This only has an impact on <track> with a `src` because these have to be\n   * loaded manually in the load() method. This will require a new load() call\n   * for each added/removed track w/ src.\n   */\n  _classPrivateFieldGet(_media, this).textTracks.addEventListener('change', () => _assertClassBrand(_RemotePlayback_brand, this, _updateRemoteTextTrack).call(this));\n  _assertClassBrand(_RemotePlayback_brand, this, _onCastStateChanged).call(this);\n  _classPrivateFieldSet(_remotePlayer, this, new cf.RemotePlayer());\n  new cf.RemotePlayerController(_classPrivateFieldGet(_remotePlayer, this));\n  _classPrivateFieldSet(_remoteListeners, this, {\n    [cf.RemotePlayerEventType.IS_CONNECTED_CHANGED]: _ref4 => {\n      let {\n        value\n      } = _ref4;\n      if (value === true) {\n        _classPrivateFieldSet(_state, this, 'connected');\n        this.dispatchEvent(new Event('connect'));\n      } else {\n        _assertClassBrand(_RemotePlayback_brand, this, _disconnect).call(this);\n        _classPrivateFieldSet(_state, this, 'disconnected');\n        this.dispatchEvent(new Event('disconnect'));\n      }\n    },\n    [cf.RemotePlayerEventType.DURATION_CHANGED]: () => {\n      _classPrivateFieldGet(_media, this).dispatchEvent(new Event('durationchange'));\n    },\n    [cf.RemotePlayerEventType.VOLUME_LEVEL_CHANGED]: () => {\n      _classPrivateFieldGet(_media, this).dispatchEvent(new Event('volumechange'));\n    },\n    [cf.RemotePlayerEventType.IS_MUTED_CHANGED]: () => {\n      _classPrivateFieldGet(_media, this).dispatchEvent(new Event('volumechange'));\n    },\n    [cf.RemotePlayerEventType.CURRENT_TIME_CHANGED]: () => {\n      var _classPrivateGetter2;\n      if (!((_classPrivateGetter2 = _classPrivateGetter(_RemotePlayback_brand, this, _get_castPlayer)) !== null && _classPrivateGetter2 !== void 0 && _classPrivateGetter2.isMediaLoaded)) return;\n      _classPrivateFieldGet(_media, this).dispatchEvent(new Event('timeupdate'));\n    },\n    [cf.RemotePlayerEventType.VIDEO_INFO_CHANGED]: () => {\n      _classPrivateFieldGet(_media, this).dispatchEvent(new Event('resize'));\n    },\n    [cf.RemotePlayerEventType.IS_PAUSED_CHANGED]: () => {\n      _classPrivateFieldGet(_media, this).dispatchEvent(new Event(this.paused ? 'pause' : 'play'));\n    },\n    [cf.RemotePlayerEventType.PLAYER_STATE_CHANGED]: () => {\n      var _classPrivateGetter3, _classPrivateGetter4;\n      // Player states: IDLE, PLAYING, PAUSED, BUFFERING\n      // https://developers.google.com/cast/docs/reference/web_sender/chrome.cast.media#.PlayerState\n\n      // pause event is handled above.\n      if (((_classPrivateGetter3 = _classPrivateGetter(_RemotePlayback_brand, this, _get_castPlayer)) === null || _classPrivateGetter3 === void 0 ? void 0 : _classPrivateGetter3.playerState) === chrome.cast.media.PlayerState.PAUSED) {\n        return;\n      }\n      _classPrivateFieldGet(_media, this).dispatchEvent(new Event({\n        [chrome.cast.media.PlayerState.PLAYING]: 'playing',\n        [chrome.cast.media.PlayerState.BUFFERING]: 'waiting',\n        [chrome.cast.media.PlayerState.IDLE]: 'emptied'\n      }[(_classPrivateGetter4 = _classPrivateGetter(_RemotePlayback_brand, this, _get_castPlayer)) === null || _classPrivateGetter4 === void 0 ? void 0 : _classPrivateGetter4.playerState]));\n    },\n    [cf.RemotePlayerEventType.IS_MEDIA_LOADED_CHANGED]: async () => {\n      var _classPrivateGetter5;\n      if (!((_classPrivateGetter5 = _classPrivateGetter(_RemotePlayback_brand, this, _get_castPlayer)) !== null && _classPrivateGetter5 !== void 0 && _classPrivateGetter5.isMediaLoaded)) return;\n\n      // mediaInfo is not immediately available due to a bug? wait one tick\n      await Promise.resolve();\n      _assertClassBrand(_RemotePlayback_brand, this, _onRemoteMediaLoaded).call(this);\n    }\n  });\n}\nfunction _onRemoteMediaLoaded() {\n  _assertClassBrand(_RemotePlayback_brand, this, _updateRemoteTextTrack).call(this);\n}\nasync function _updateRemoteTextTrack() {\n  var _classPrivateFieldGet2, _classPrivateFieldGet3, _currentSession$getSe, _currentSession;\n  if (!_classPrivateGetter(_RemotePlayback_brand, this, _get_castPlayer)) return;\n\n  // Get the tracks w/ trackId's that have been loaded; manually or via a playlist like a M3U8 or MPD.\n  const remoteTracks = (_classPrivateFieldGet2 = (_classPrivateFieldGet3 = _classPrivateFieldGet(_remotePlayer, this).mediaInfo) === null || _classPrivateFieldGet3 === void 0 ? void 0 : _classPrivateFieldGet3.tracks) !== null && _classPrivateFieldGet2 !== void 0 ? _classPrivateFieldGet2 : [];\n  const remoteSubtitles = remoteTracks.filter(_ref5 => {\n    let {\n      type\n    } = _ref5;\n    return type === chrome.cast.media.TrackType.TEXT;\n  });\n  const localSubtitles = [..._classPrivateFieldGet(_media, this).textTracks].filter(_ref6 => {\n    let {\n      kind\n    } = _ref6;\n    return kind === 'subtitles' || kind === 'captions';\n  });\n\n  // Create a new array from the local subs w/ the trackId's from the remote subs.\n  const subtitles = remoteSubtitles.map(_ref7 => {\n    var _localSubtitles$find;\n    let {\n      language,\n      name,\n      trackId\n    } = _ref7;\n    // Find the corresponding local text track and assign the trackId.\n    const {\n      mode\n    } = (_localSubtitles$find = localSubtitles.find(local => local.language === language && local.label === name)) !== null && _localSubtitles$find !== void 0 ? _localSubtitles$find : {};\n    if (mode) return {\n      mode,\n      trackId\n    };\n    return false;\n  }).filter(Boolean);\n  const hiddenSubtitles = subtitles.filter(_ref8 => {\n    let {\n      mode\n    } = _ref8;\n    return mode !== 'showing';\n  });\n  const hiddenTrackIds = hiddenSubtitles.map(_ref9 => {\n    let {\n      trackId\n    } = _ref9;\n    return trackId;\n  });\n  const showingSubtitle = subtitles.find(_ref0 => {\n    let {\n      mode\n    } = _ref0;\n    return mode === 'showing';\n  });\n\n  // Note this could also include audio or video tracks, diff against local state.\n  const activeTrackIds = (_currentSession$getSe = (_currentSession = currentSession()) === null || _currentSession === void 0 || (_currentSession = _currentSession.getSessionObj().media[0]) === null || _currentSession === void 0 ? void 0 : _currentSession.activeTrackIds) !== null && _currentSession$getSe !== void 0 ? _currentSession$getSe : [];\n  let requestTrackIds = activeTrackIds;\n  if (activeTrackIds.length) {\n    // Filter out all local hidden subtitle trackId's.\n    requestTrackIds = requestTrackIds.filter(id => !hiddenTrackIds.includes(id));\n  }\n  if (showingSubtitle !== null && showingSubtitle !== void 0 && showingSubtitle.trackId) {\n    requestTrackIds = [...requestTrackIds, showingSubtitle.trackId];\n  }\n\n  // Remove duplicate ids.\n  requestTrackIds = [...new Set(requestTrackIds)];\n  const arrayEquals = (a, b) => a.length === b.length && a.every(a => b.includes(a));\n  if (!arrayEquals(activeTrackIds, requestTrackIds)) {\n    try {\n      const request = new chrome.cast.media.EditTracksInfoRequest(requestTrackIds);\n      await editTracksInfo(request);\n    } catch (error) {\n      console.error(error);\n    }\n  }\n}","map":{"version":3,"names":["privateProps","IterableWeakSet","InvalidStateError","NotSupportedError","onCastApiAvailable","castContext","currentSession","currentMedia","editTracksInfo","getMediaStatus","setCastOptions","remoteInstances","castElementRef","WeakSet","cf","_globalThis$chrome","globalThis","chrome","cast","isAvailable","_globalThis$chrome2","console","debug","framework","addEventListener","CastContextEventType","CAST_STATE_CHANGED","e","forEach","r","_privateProps$get$onC","_privateProps$get","get","onCastStateChanged","call","SESSION_STATE_CHANGED","_privateProps$get$onS","_privateProps$get2","onSessionStateChanged","_privateProps$get$ini","_privateProps$get3","init","remotePlaybackCallbackIdCount","_media","WeakMap","_isInit","_remotePlayer","_remoteListeners","_state","_available","_callbacks","_callbackIds","_RemotePlayback_brand","RemotePlayback","EventTarget","constructor","media","_classPrivateMethodInitSpec","_classPrivateFieldInitSpec","Set","_classPrivateFieldSet","add","set","_assertClassBrand","_init","_onCastStateChanged","_onSessionStateChanged","getCastPlayer","_classPrivateGetter","_get_castPlayer","state","_classPrivateFieldGet","watchAvailability","callback","disableRemotePlayback","queueMicrotask","_hasDevicesAvailable","cancelWatchAvailability","delete","clear","prompt","_globalThis$chrome3","_privateProps$get4","_privateProps$get4$lo","willDisconnect","has","castOptions","Object","entries","_ref","event","listener","controller","requestSession","err","Error","loadOnPrompt","_this","undefined","_disconnect","_ref2","removeEventListener","muted","isMuted","currentTime","savedPlayerState","isPaused","play","_castContext","castState","getCastState","dispatchEvent","Event","includes","SESSION_RESUMED","SessionState","getSessionState","_currentMedia","castSrc","contentId","_ref3","GetStatusRequest","error","RemotePlayerEventType","IS_PAUSED_CHANGED","PLAYER_STATE_CHANGED","textTracks","_updateRemoteTextTrack","RemotePlayer","RemotePlayerController","IS_CONNECTED_CHANGED","_ref4","value","DURATION_CHANGED","VOLUME_LEVEL_CHANGED","IS_MUTED_CHANGED","CURRENT_TIME_CHANGED","_classPrivateGetter2","isMediaLoaded","VIDEO_INFO_CHANGED","paused","_classPrivateGetter3","_classPrivateGetter4","playerState","PlayerState","PAUSED","PLAYING","BUFFERING","IDLE","IS_MEDIA_LOADED_CHANGED","_classPrivateGetter5","Promise","resolve","_onRemoteMediaLoaded","_classPrivateFieldGet2","_classPrivateFieldGet3","_currentSession$getSe","_currentSession","remoteTracks","mediaInfo","tracks","remoteSubtitles","filter","_ref5","type","TrackType","TEXT","localSubtitles","_ref6","kind","subtitles","map","_ref7","_localSubtitles$find","language","name","trackId","mode","find","local","label","Boolean","hiddenSubtitles","_ref8","hiddenTrackIds","_ref9","showingSubtitle","_ref0","activeTrackIds","getSessionObj","requestTrackIds","length","id","arrayEquals","a","b","every","request","EditTracksInfoRequest"],"sources":["/app/frontend/node_modules/castable-video/castable-remote-playback.js"],"sourcesContent":["/* global chrome, cast */\nimport {\n  privateProps,\n  IterableWeakSet,\n  InvalidStateError,\n  NotSupportedError,\n  onCastApiAvailable,\n  castContext,\n  currentSession,\n  currentMedia,\n  editTracksInfo,\n  getMediaStatus,\n  setCastOptions\n} from './castable-utils.js';\n\nconst remoteInstances = new IterableWeakSet();\nconst castElementRef = new WeakSet();\n\nlet cf;\n\nonCastApiAvailable(() => {\n  if (!globalThis.chrome?.cast?.isAvailable) {\n    // Useful to see in verbose logs if this shows undefined or false.\n    console.debug('chrome.cast.isAvailable', globalThis.chrome?.cast?.isAvailable);\n    return;\n  }\n\n  if (!cf) {\n    cf = cast.framework;\n\n    castContext().addEventListener(cf.CastContextEventType.CAST_STATE_CHANGED, (e) => {\n      remoteInstances.forEach((r) => privateProps.get(r).onCastStateChanged?.(e));\n    });\n\n    castContext().addEventListener(cf.CastContextEventType.SESSION_STATE_CHANGED, (e) => {\n      remoteInstances.forEach((r) => privateProps.get(r).onSessionStateChanged?.(e));\n    });\n\n    remoteInstances.forEach((r) => privateProps.get(r).init?.());\n  }\n});\n\n\nlet remotePlaybackCallbackIdCount = 0;\n\n/**\n * Remote Playback shim for the Google cast SDK.\n * https://w3c.github.io/remote-playback/\n */\nexport class RemotePlayback extends EventTarget {\n  #media;\n  #isInit;\n  #remotePlayer;\n  #remoteListeners;\n  #state = 'disconnected';\n  #available = false;\n  #callbacks = new Set();\n  #callbackIds = new WeakMap();\n\n  constructor(media) {\n    super();\n\n    this.#media = media;\n\n    remoteInstances.add(this);\n    privateProps.set(this, {\n      init: () => this.#init(),\n      onCastStateChanged: () => this.#onCastStateChanged(),\n      onSessionStateChanged: () => this.#onSessionStateChanged(),\n      getCastPlayer: () => this.#castPlayer,\n    });\n\n    this.#init();\n  }\n\n  get #castPlayer() {\n    if (castElementRef.has(this.#media)) return this.#remotePlayer;\n    return undefined;\n  }\n\n  /**\n   * https://developer.mozilla.org/en-US/docs/Web/API/RemotePlayback/state\n   * @return {'disconnected'|'connecting'|'connected'}\n   */\n  get state() {\n    return this.#state;\n  }\n\n  async watchAvailability(callback) {\n    if (this.#media.disableRemotePlayback) {\n      throw new InvalidStateError('disableRemotePlayback attribute is present.');\n    }\n\n    this.#callbackIds.set(callback, ++remotePlaybackCallbackIdCount);\n    this.#callbacks.add(callback);\n\n    // https://w3c.github.io/remote-playback/#getting-the-remote-playback-devices-availability-information\n    queueMicrotask(() => callback(this.#hasDevicesAvailable()));\n\n    return remotePlaybackCallbackIdCount;\n  }\n\n  async cancelWatchAvailability(callback) {\n    if (this.#media.disableRemotePlayback) {\n      throw new InvalidStateError('disableRemotePlayback attribute is present.');\n    }\n\n    if (callback) {\n      this.#callbacks.delete(callback);\n    } else {\n      this.#callbacks.clear();\n    }\n  }\n\n  async prompt() {\n    if (this.#media.disableRemotePlayback) {\n      throw new InvalidStateError('disableRemotePlayback attribute is present.');\n    }\n\n    if (!globalThis.chrome?.cast?.isAvailable) {\n      throw new NotSupportedError('The RemotePlayback API is disabled on this platform.');\n    }\n\n    const willDisconnect = castElementRef.has(this.#media);\n    castElementRef.add(this.#media);\n\n    setCastOptions(this.#media.castOptions);\n\n    Object.entries(this.#remoteListeners).forEach(([event, listener]) => {\n      this.#remotePlayer.controller.addEventListener(event, listener);\n    });\n\n    try {\n      // Open browser cast menu.\n      await castContext().requestSession();\n    } catch (err) {\n      // If there will be no disconnect, reset some state here.\n      if (!willDisconnect) {\n        castElementRef.delete(this.#media);\n      }\n\n      // Don't throw an error if disconnecting or cancelling.\n      if (err === 'cancel') {\n        return;\n      }\n\n      throw new Error(err);\n    }\n\n    privateProps.get(this.#media)?.loadOnPrompt?.();\n  }\n\n  #disconnect() {\n    if (!castElementRef.has(this.#media)) return;\n\n    Object.entries(this.#remoteListeners).forEach(([event, listener]) => {\n      this.#remotePlayer.controller.removeEventListener(event, listener);\n    });\n\n    castElementRef.delete(this.#media);\n\n    // isMuted is not in savedPlayerState. should we sync this back to local?\n    this.#media.muted = this.#remotePlayer.isMuted;\n    this.#media.currentTime = this.#remotePlayer.savedPlayerState.currentTime;\n    if (this.#remotePlayer.savedPlayerState.isPaused === false) {\n      this.#media.play();\n    }\n  }\n\n  #hasDevicesAvailable() {\n    // Cast state: NO_DEVICES_AVAILABLE, NOT_CONNECTED, CONNECTING, CONNECTED\n    // https://developers.google.com/cast/docs/reference/web_sender/cast.framework#.CastState\n    const castState = castContext()?.getCastState();\n    return castState && castState !== 'NO_DEVICES_AVAILABLE';\n  }\n\n  #onCastStateChanged() {\n    // Cast state: NO_DEVICES_AVAILABLE, NOT_CONNECTED, CONNECTING, CONNECTED\n    // https://developers.google.com/cast/docs/reference/web_sender/cast.framework#.CastState\n    const castState = castContext().getCastState();\n\n    if (castElementRef.has(this.#media)) {\n      if (castState === 'CONNECTING') {\n        this.#state = 'connecting';\n        this.dispatchEvent(new Event('connecting'));\n      }\n    }\n\n    if (!this.#available && castState?.includes('CONNECT')) {\n      this.#available = true;\n      for (let callback of this.#callbacks) callback(true);\n    }\n    else if (this.#available && (!castState || castState === 'NO_DEVICES_AVAILABLE')) {\n      this.#available = false;\n      for (let callback of this.#callbacks) callback(false);\n    }\n  }\n\n  async #onSessionStateChanged() {\n    // Session states: NO_SESSION, SESSION_STARTING, SESSION_STARTED, SESSION_START_FAILED,\n    //                 SESSION_ENDING, SESSION_ENDED, SESSION_RESUMED\n    // https://developers.google.com/cast/docs/reference/web_sender/cast.framework#.SessionState\n\n    const { SESSION_RESUMED } = cf.SessionState;\n    if (castContext().getSessionState() === SESSION_RESUMED) {\n      /**\n       * Figure out if this was the video that started the resumed session.\n       * @TODO make this more specific than just checking against the video src!! (WL)\n       *\n       * If this video element can get the same unique id on each browser refresh\n       * it would be possible to pass this unique id w/ `LoadRequest.customData`\n       * and verify against currentMedia().customData below.\n       */\n      if (this.#media.castSrc === currentMedia()?.media.contentId) {\n        castElementRef.add(this.#media);\n\n        Object.entries(this.#remoteListeners).forEach(([event, listener]) => {\n          this.#remotePlayer.controller.addEventListener(event, listener);\n        });\n\n        /**\n         * There is cast framework resume session bug when you refresh the page a few\n         * times the this.#remotePlayer.currentTime will not be in sync with the receiver :(\n         * The below status request syncs it back up.\n         */\n        try {\n          await getMediaStatus(new chrome.cast.media.GetStatusRequest());\n        } catch (error) {\n          console.error(error);\n        }\n\n        // Dispatch the play, playing events manually to sync remote playing state.\n        this.#remoteListeners[cf.RemotePlayerEventType.IS_PAUSED_CHANGED]();\n        this.#remoteListeners[cf.RemotePlayerEventType.PLAYER_STATE_CHANGED]();\n      }\n    }\n  }\n\n  #init() {\n    if (!cf || this.#isInit) return;\n    this.#isInit = true;\n\n    setCastOptions(this.#media.castOptions);\n\n    /**\n     * @TODO add listeners for addtrack, removetrack (WL)\n     * This only has an impact on <track> with a `src` because these have to be\n     * loaded manually in the load() method. This will require a new load() call\n     * for each added/removed track w/ src.\n     */\n    this.#media.textTracks.addEventListener('change', () => this.#updateRemoteTextTrack());\n\n    this.#onCastStateChanged();\n\n    this.#remotePlayer = new cf.RemotePlayer();\n    new cf.RemotePlayerController(this.#remotePlayer);\n\n    this.#remoteListeners = {\n      [cf.RemotePlayerEventType.IS_CONNECTED_CHANGED]: ({ value }) => {\n        if (value === true) {\n          this.#state = 'connected';\n          this.dispatchEvent(new Event('connect'));\n        } else {\n          this.#disconnect();\n          this.#state = 'disconnected';\n          this.dispatchEvent(new Event('disconnect'));\n        }\n      },\n      [cf.RemotePlayerEventType.DURATION_CHANGED]: () => {\n        this.#media.dispatchEvent(new Event('durationchange'));\n      },\n      [cf.RemotePlayerEventType.VOLUME_LEVEL_CHANGED]: () => {\n        this.#media.dispatchEvent(new Event('volumechange'));\n      },\n      [cf.RemotePlayerEventType.IS_MUTED_CHANGED]: () => {\n        this.#media.dispatchEvent(new Event('volumechange'));\n      },\n      [cf.RemotePlayerEventType.CURRENT_TIME_CHANGED]: () => {\n        if (!this.#castPlayer?.isMediaLoaded) return;\n        this.#media.dispatchEvent(new Event('timeupdate'));\n      },\n      [cf.RemotePlayerEventType.VIDEO_INFO_CHANGED]: () => {\n        this.#media.dispatchEvent(new Event('resize'));\n      },\n      [cf.RemotePlayerEventType.IS_PAUSED_CHANGED]: () => {\n        this.#media.dispatchEvent(new Event(this.paused ? 'pause' : 'play'));\n      },\n      [cf.RemotePlayerEventType.PLAYER_STATE_CHANGED]: () => {\n        // Player states: IDLE, PLAYING, PAUSED, BUFFERING\n        // https://developers.google.com/cast/docs/reference/web_sender/chrome.cast.media#.PlayerState\n\n        // pause event is handled above.\n        if (this.#castPlayer?.playerState === chrome.cast.media.PlayerState.PAUSED) {\n          return;\n        }\n\n        this.#media.dispatchEvent(\n          new Event(\n            {\n              [chrome.cast.media.PlayerState.PLAYING]: 'playing',\n              [chrome.cast.media.PlayerState.BUFFERING]: 'waiting',\n              [chrome.cast.media.PlayerState.IDLE]: 'emptied',\n            }[this.#castPlayer?.playerState]\n          )\n        );\n      },\n      [cf.RemotePlayerEventType.IS_MEDIA_LOADED_CHANGED]: async () => {\n        if (!this.#castPlayer?.isMediaLoaded) return;\n\n        // mediaInfo is not immediately available due to a bug? wait one tick\n        await Promise.resolve();\n        this.#onRemoteMediaLoaded();\n      },\n    };\n  }\n\n  #onRemoteMediaLoaded() {\n    this.#updateRemoteTextTrack();\n  }\n\n  async #updateRemoteTextTrack() {\n    if (!this.#castPlayer) return;\n\n    // Get the tracks w/ trackId's that have been loaded; manually or via a playlist like a M3U8 or MPD.\n    const remoteTracks = this.#remotePlayer.mediaInfo?.tracks ?? [];\n    const remoteSubtitles = remoteTracks.filter(\n      ({ type }) => type === chrome.cast.media.TrackType.TEXT\n    );\n\n    const localSubtitles = [...this.#media.textTracks].filter(\n      ({ kind }) => kind === 'subtitles' || kind === 'captions'\n    );\n\n    // Create a new array from the local subs w/ the trackId's from the remote subs.\n    const subtitles = remoteSubtitles\n      .map(({ language, name, trackId }) => {\n        // Find the corresponding local text track and assign the trackId.\n        const { mode } =\n          localSubtitles.find(\n            (local) => local.language === language && local.label === name\n          ) ?? {};\n        if (mode) return { mode, trackId };\n        return false;\n      })\n      .filter(Boolean);\n\n    const hiddenSubtitles = subtitles.filter(\n      ({ mode }) => mode !== 'showing'\n    );\n    const hiddenTrackIds = hiddenSubtitles.map(({ trackId }) => trackId);\n    const showingSubtitle = subtitles.find(({ mode }) => mode === 'showing');\n\n    // Note this could also include audio or video tracks, diff against local state.\n    const activeTrackIds =\n      currentSession()?.getSessionObj().media[0]\n        ?.activeTrackIds ?? [];\n    let requestTrackIds = activeTrackIds;\n\n    if (activeTrackIds.length) {\n      // Filter out all local hidden subtitle trackId's.\n      requestTrackIds = requestTrackIds.filter(\n        (id) => !hiddenTrackIds.includes(id)\n      );\n    }\n\n    if (showingSubtitle?.trackId) {\n      requestTrackIds = [...requestTrackIds, showingSubtitle.trackId];\n    }\n\n    // Remove duplicate ids.\n    requestTrackIds = [...new Set(requestTrackIds)];\n\n    const arrayEquals = (a, b) =>\n      a.length === b.length && a.every((a) => b.includes(a));\n    if (!arrayEquals(activeTrackIds, requestTrackIds)) {\n      try {\n        const request = new chrome.cast.media.EditTracksInfoRequest(\n          requestTrackIds\n        );\n        await editTracksInfo(request);\n      } catch (error) {\n        console.error(error);\n      }\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}