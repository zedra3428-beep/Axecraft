{"ast":null,"code":"\"use client\";\n\nimport _objectSpread from \"/app/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { jsxs, jsx } from 'react/jsx-runtime';\nimport { warning, invariant } from 'motion-utils';\nimport { forwardRef, useContext } from 'react';\nimport { LayoutGroupContext } from '../context/LayoutGroupContext.mjs';\nimport { LazyContext } from '../context/LazyContext.mjs';\nimport { MotionConfigContext } from '../context/MotionConfigContext.mjs';\nimport { MotionContext } from '../context/MotionContext/index.mjs';\nimport { useCreateMotionContext } from '../context/MotionContext/create.mjs';\nimport { useRender } from '../render/dom/use-render.mjs';\nimport { isSVGComponent } from '../render/dom/utils/is-svg-component.mjs';\nimport { useHTMLVisualState } from '../render/html/use-html-visual-state.mjs';\nimport { useSVGVisualState } from '../render/svg/use-svg-visual-state.mjs';\nimport { isBrowser } from '../utils/is-browser.mjs';\nimport { featureDefinitions } from './features/definitions.mjs';\nimport { loadFeatures } from './features/load-features.mjs';\nimport { motionComponentSymbol } from './utils/symbol.mjs';\nimport { useMotionRef } from './utils/use-motion-ref.mjs';\nimport { useVisualElement } from './utils/use-visual-element.mjs';\n\n/**\n * Create a `motion` component.\n *\n * This function accepts a Component argument, which can be either a string (ie \"div\"\n * for `motion.div`), or an actual React component.\n *\n * Alongside this is a config option which provides a way of rendering the provided\n * component \"offline\", or outside the React render cycle.\n */\nfunction createMotionComponent(Component) {\n  var _ref, _Component$displayNam;\n  let {\n    forwardMotionProps = false,\n    type\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let preloadedFeatures = arguments.length > 2 ? arguments[2] : undefined;\n  let createVisualElement = arguments.length > 3 ? arguments[3] : undefined;\n  preloadedFeatures && loadFeatures(preloadedFeatures);\n  /**\n   * Determine whether to use SVG or HTML rendering based on:\n   * 1. Explicit `type` option (highest priority)\n   * 2. Auto-detection via `isSVGComponent`\n   */\n  const isSVG = type ? type === \"svg\" : isSVGComponent(Component);\n  const useVisualState = isSVG ? useSVGVisualState : useHTMLVisualState;\n  function MotionDOMComponent(props, externalRef) {\n    /**\n     * If we need to measure the element we load this functionality in a\n     * separate class component in order to gain access to getSnapshotBeforeUpdate.\n     */\n    let MeasureLayout;\n    const configAndProps = _objectSpread(_objectSpread(_objectSpread({}, useContext(MotionConfigContext)), props), {}, {\n      layoutId: useLayoutId(props)\n    });\n    const {\n      isStatic\n    } = configAndProps;\n    const context = useCreateMotionContext(props);\n    const visualState = useVisualState(props, isStatic);\n    if (!isStatic && isBrowser) {\n      useStrictMode(configAndProps, preloadedFeatures);\n      const layoutProjection = getProjectionFunctionality(configAndProps);\n      MeasureLayout = layoutProjection.MeasureLayout;\n      /**\n       * Create a VisualElement for this component. A VisualElement provides a common\n       * interface to renderer-specific APIs (ie DOM/Three.js etc) as well as\n       * providing a way of rendering to these APIs outside of the React render loop\n       * for more performant animations and interactions\n       */\n      context.visualElement = useVisualElement(Component, visualState, configAndProps, createVisualElement, layoutProjection.ProjectionNode, isSVG);\n    }\n    /**\n     * The mount order and hierarchy is specific to ensure our element ref\n     * is hydrated by the time features fire their effects.\n     */\n    return jsxs(MotionContext.Provider, {\n      value: context,\n      children: [MeasureLayout && context.visualElement ? jsx(MeasureLayout, _objectSpread({\n        visualElement: context.visualElement\n      }, configAndProps)) : null, useRender(Component, props, useMotionRef(visualState, context.visualElement, externalRef), visualState, isStatic, forwardMotionProps, isSVG)]\n    });\n  }\n  MotionDOMComponent.displayName = \"motion.\".concat(typeof Component === \"string\" ? Component : \"create(\".concat((_ref = (_Component$displayNam = Component.displayName) !== null && _Component$displayNam !== void 0 ? _Component$displayNam : Component.name) !== null && _ref !== void 0 ? _ref : \"\", \")\"));\n  const ForwardRefMotionComponent = forwardRef(MotionDOMComponent);\n  ForwardRefMotionComponent[motionComponentSymbol] = Component;\n  return ForwardRefMotionComponent;\n}\nfunction useLayoutId(_ref2) {\n  let {\n    layoutId\n  } = _ref2;\n  const layoutGroupId = useContext(LayoutGroupContext).id;\n  return layoutGroupId && layoutId !== undefined ? layoutGroupId + \"-\" + layoutId : layoutId;\n}\nfunction useStrictMode(configAndProps, preloadedFeatures) {\n  const isStrict = useContext(LazyContext).strict;\n  /**\n   * If we're in development mode, check to make sure we're not rendering a motion component\n   * as a child of LazyMotion, as this will break the file-size benefits of using it.\n   */\n  if (process.env.NODE_ENV !== \"production\" && preloadedFeatures && isStrict) {\n    const strictMessage = \"You have rendered a `motion` component within a `LazyMotion` component. This will break tree shaking. Import and render a `m` component instead.\";\n    configAndProps.ignoreStrict ? warning(false, strictMessage, \"lazy-strict-mode\") : invariant(false, strictMessage, \"lazy-strict-mode\");\n  }\n}\nfunction getProjectionFunctionality(props) {\n  const {\n    drag,\n    layout\n  } = featureDefinitions;\n  if (!drag && !layout) return {};\n  const combined = _objectSpread(_objectSpread({}, drag), layout);\n  return {\n    MeasureLayout: drag !== null && drag !== void 0 && drag.isEnabled(props) || layout !== null && layout !== void 0 && layout.isEnabled(props) ? combined.MeasureLayout : undefined,\n    ProjectionNode: combined.ProjectionNode\n  };\n}\nexport { createMotionComponent };","map":{"version":3,"names":["preloadedFeatures","loadFeatures","isSVG","type","isSVGComponent","Component","MotionDOMComponent","props","externalRef","MeasureLayout","configAndProps","_objectSpread","layoutId","useLayoutId","isStatic","context","useCreateMotionContext","isBrowser","useStrictMode","layoutProjection","getProjectionFunctionality","visualElement","useVisualElement","visualState","createVisualElement","ProjectionNode","jsxs","MotionContext","Provider","value","children","jsx","useRender","useMotionRef","forwardMotionProps","displayName","concat","_ref","_Component$displayNam","name","ForwardRefMotionComponent","forwardRef","motionComponentSymbol","_ref2","layoutGroupId","undefined","process","env","NODE_ENV","isStrict","ignoreStrict","drag","layout","featureDefinitions","isEnabled"],"sources":["/app/frontend/node_modules/framer-motion/src/motion/index.tsx"],"sourcesContent":["\"use client\"\n\nimport { invariant, warning } from \"motion-utils\"\nimport * as React from \"react\"\nimport { forwardRef, useContext } from \"react\"\nimport { LayoutGroupContext } from \"../context/LayoutGroupContext\"\nimport { LazyContext } from \"../context/LazyContext\"\nimport { MotionConfigContext } from \"../context/MotionConfigContext\"\nimport { MotionContext } from \"../context/MotionContext\"\nimport { useCreateMotionContext } from \"../context/MotionContext/create\"\nimport { DOMMotionComponents } from \"../render/dom/types\"\nimport { useRender } from \"../render/dom/use-render\"\nimport { isSVGComponent } from \"../render/dom/utils/is-svg-component\"\nimport { HTMLRenderState } from \"../render/html/types\"\nimport { useHTMLVisualState } from \"../render/html/use-html-visual-state\"\nimport { SVGRenderState } from \"../render/svg/types\"\nimport { useSVGVisualState } from \"../render/svg/use-svg-visual-state\"\nimport { CreateVisualElement } from \"../render/types\"\nimport { isBrowser } from \"../utils/is-browser\"\nimport { featureDefinitions } from \"./features/definitions\"\nimport { loadFeatures } from \"./features/load-features\"\nimport { FeatureBundle, FeaturePackages } from \"./features/types\"\nimport { MotionProps } from \"./types\"\nimport { motionComponentSymbol } from \"./utils/symbol\"\nimport { useMotionRef } from \"./utils/use-motion-ref\"\nimport { useVisualElement } from \"./utils/use-visual-element\"\n\nexport interface MotionComponentConfig<\n    TagName extends keyof DOMMotionComponents | string = \"div\"\n> {\n    preloadedFeatures?: FeatureBundle\n    createVisualElement?: CreateVisualElement\n    Component: TagName | React.ComponentType<React.PropsWithChildren<unknown>>\n    forwardMotionProps?: boolean\n}\n\nexport type MotionComponentProps<Props> = {\n    [K in Exclude<keyof Props, keyof MotionProps>]?: Props[K]\n} & MotionProps\n\nexport type MotionComponent<T, P> = T extends keyof DOMMotionComponents\n    ? DOMMotionComponents[T]\n    : React.ComponentType<\n          Omit<MotionComponentProps<P>, \"children\"> & {\n              children?: \"children\" extends keyof P\n                  ? P[\"children\"] | MotionComponentProps<P>[\"children\"]\n                  : MotionComponentProps<P>[\"children\"]\n          }\n      >\n\nexport interface MotionComponentOptions {\n    forwardMotionProps?: boolean\n    /**\n     * Specify whether the component renders an HTML or SVG element.\n     * This is useful when wrapping custom SVG components that need\n     * SVG-specific attribute handling (like viewBox animation).\n     * By default, Motion auto-detects based on the component name,\n     * but custom React components are always treated as HTML.\n     */\n    type?: \"html\" | \"svg\"\n}\n\n/**\n * Create a `motion` component.\n *\n * This function accepts a Component argument, which can be either a string (ie \"div\"\n * for `motion.div`), or an actual React component.\n *\n * Alongside this is a config option which provides a way of rendering the provided\n * component \"offline\", or outside the React render cycle.\n */\nexport function createMotionComponent<\n    Props,\n    TagName extends keyof DOMMotionComponents | string = \"div\"\n>(\n    Component: TagName | string | React.ComponentType<Props>,\n    { forwardMotionProps = false, type }: MotionComponentOptions = {},\n    preloadedFeatures?: FeaturePackages,\n    createVisualElement?: CreateVisualElement<Props, TagName>\n) {\n    preloadedFeatures && loadFeatures(preloadedFeatures)\n\n    /**\n     * Determine whether to use SVG or HTML rendering based on:\n     * 1. Explicit `type` option (highest priority)\n     * 2. Auto-detection via `isSVGComponent`\n     */\n    const isSVG = type ? type === \"svg\" : isSVGComponent(Component)\n    const useVisualState = isSVG ? useSVGVisualState : useHTMLVisualState\n\n    function MotionDOMComponent(\n        props: MotionComponentProps<Props>,\n        externalRef?: React.Ref<HTMLElement | SVGElement>\n    ) {\n        /**\n         * If we need to measure the element we load this functionality in a\n         * separate class component in order to gain access to getSnapshotBeforeUpdate.\n         */\n        let MeasureLayout: undefined | React.ComponentType<MotionProps>\n\n        const configAndProps = {\n            ...useContext(MotionConfigContext),\n            ...props,\n            layoutId: useLayoutId(props),\n        }\n\n        const { isStatic } = configAndProps\n\n        const context = useCreateMotionContext<HTMLElement | SVGElement>(props)\n\n        const visualState = useVisualState(props, isStatic)\n\n        if (!isStatic && isBrowser) {\n            useStrictMode(configAndProps, preloadedFeatures)\n\n            const layoutProjection = getProjectionFunctionality(configAndProps)\n            MeasureLayout = layoutProjection.MeasureLayout\n\n            /**\n             * Create a VisualElement for this component. A VisualElement provides a common\n             * interface to renderer-specific APIs (ie DOM/Three.js etc) as well as\n             * providing a way of rendering to these APIs outside of the React render loop\n             * for more performant animations and interactions\n             */\n            context.visualElement = useVisualElement(\n                Component,\n                visualState,\n                configAndProps,\n                createVisualElement,\n                layoutProjection.ProjectionNode,\n                isSVG\n            )\n        }\n\n        /**\n         * The mount order and hierarchy is specific to ensure our element ref\n         * is hydrated by the time features fire their effects.\n         */\n        return (\n            <MotionContext.Provider value={context}>\n                {MeasureLayout && context.visualElement ? (\n                    <MeasureLayout\n                        visualElement={context.visualElement}\n                        {...configAndProps}\n                    />\n                ) : null}\n                {useRender<Props, TagName>(\n                    Component,\n                    props,\n                    useMotionRef<\n                        HTMLElement | SVGElement,\n                        HTMLRenderState | SVGRenderState\n                    >(visualState, context.visualElement, externalRef),\n                    visualState,\n                    isStatic,\n                    forwardMotionProps,\n                    isSVG\n                )}\n            </MotionContext.Provider>\n        )\n    }\n\n    MotionDOMComponent.displayName = `motion.${\n        typeof Component === \"string\"\n            ? Component\n            : `create(${Component.displayName ?? Component.name ?? \"\"})`\n    }`\n\n    const ForwardRefMotionComponent = forwardRef(MotionDOMComponent as any)\n    ;(ForwardRefMotionComponent as any)[motionComponentSymbol] = Component\n\n    return ForwardRefMotionComponent as MotionComponent<TagName, Props>\n}\n\nfunction useLayoutId({ layoutId }: MotionProps) {\n    const layoutGroupId = useContext(LayoutGroupContext).id\n    return layoutGroupId && layoutId !== undefined\n        ? layoutGroupId + \"-\" + layoutId\n        : layoutId\n}\n\nfunction useStrictMode(\n    configAndProps: MotionProps,\n    preloadedFeatures?: FeaturePackages\n) {\n    const isStrict = useContext(LazyContext).strict\n\n    /**\n     * If we're in development mode, check to make sure we're not rendering a motion component\n     * as a child of LazyMotion, as this will break the file-size benefits of using it.\n     */\n    if (\n        process.env.NODE_ENV !== \"production\" &&\n        preloadedFeatures &&\n        isStrict\n    ) {\n        const strictMessage =\n            \"You have rendered a `motion` component within a `LazyMotion` component. This will break tree shaking. Import and render a `m` component instead.\"\n        configAndProps.ignoreStrict\n            ? warning(false, strictMessage, \"lazy-strict-mode\")\n            : invariant(false, strictMessage, \"lazy-strict-mode\")\n    }\n}\n\nfunction getProjectionFunctionality(props: MotionProps) {\n    const { drag, layout } = featureDefinitions\n\n    if (!drag && !layout) return {}\n\n    const combined = { ...drag, ...layout }\n\n    return {\n        MeasureLayout:\n            drag?.isEnabled(props) || layout?.isEnabled(props)\n                ? combined.MeasureLayout\n                : undefined,\n        ProjectionNode: combined.ProjectionNode,\n    }\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;AA8DA;;;;;;;;AAQG;;;;;;;;;EAUCA,iBAAA,IAAAC,YAAA,CAAAD,iBAAA;EAEA;;;;AAIG;EACH,MAAAE,KAAA,GAAAC,IAAA,GAAAA,IAAA,aAAAC,cAAA,CAAAC,SAAA;;EAGA,SAAAC,mBAAAC,KAAA,EAAAC,WAAA;IAII;;;AAGG;IACH,IAAAC,aAAA;IAEA,MAAAC,cAAA,GAAAC,aAAA,CAAAA,aAAA,CAAAA,aAAA,K,kCAEIJ,KAAA;MACAK,QAAA,EAAAC,WAAA,CAAAN,KAAA;IAAA,E;IAGJ;MAAAO;IAAA,IAAAJ,cAAA;IAEA,MAAAK,OAAA,GAAAC,sBAAA,CAAAT,KAAA;;IAIA,KAAAO,QAAA,IAAAG,SAAA;MACIC,aAAA,CAAAR,cAAA,EAAAV,iBAAA;MAEA,MAAAmB,gBAAA,GAAAC,0BAAA,CAAAV,cAAA;MACAD,aAAA,GAAAU,gBAAA,CAAAV,aAAA;MAEA;;;;;AAKG;MACHM,OAAA,CAAAM,aAAA,GAAAC,gBAAA,CAAAjB,SAAA,EAAAkB,WAAA,EAAAb,cAAA,EAAAc,mBAAA,EAAAL,gBAAA,CAAAM,cAAA,EAAAvB,KAAA;;IAUJ;;;AAGG;IACH,OAAAwB,IAAA,CAAAC,aAAA,CAAAC,QAAA;MAAAC,KAAA,EAAAd,OAAA;MAAAe,QAAA,GAAArB,aAAA,IAAAM,OAAA,CAAAM,aAAA,GAAAU,GAAA,CAAAtB,aAAA,EAAAE,aAAA;QAAAU,aAAA,EAAAN,OAAA,CAAAM;MAAA,GAAAX,cAAA,WAAAsB,SAAA,CAAA3B,SAAA,EAAAE,KAAA,EAAA0B,YAAA,CAAAV,WAAA,EAAAR,OAAA,CAAAM,aAAA,EAAAb,WAAA,GAAAe,WAAA,EAAAT,QAAA,EAAAoB,kBAAA,EAAAhC,KAAA;IAAA;;EAwBJI,kBAAA,CAAA6B,WAAA,aAAAC,MAAA,QAAA/B,SAAA,gBAEQA,SAAA,aAAA+B,MAAA,EAAAC,IAAA,IAAAC,qBAAA,GACAjC,SAAA,CAAA8B,WAAA,cAAAG,qBAAA,cAAAA,qBAAA,GAAAjC,SAAA,CAAAkC,IAAA,cAAAF,IAAA,cAAAA,IAAA;EAGR,MAAAG,yBAAA,GAAAC,UAAA,CAAAnC,kBAAA;EACEkC,yBAAA,CAAAE,qBAAA,IAAArC,SAAA;EAEF,OAAAmC,yBAAA;AACJ;AAEA,SAAA3B,YAAA8B,KAAA;EAAA;IAAA/B;EAAA,IAAA+B,KAAA;;EAEI,OAAAC,aAAA,IAAAhC,QAAA,KAAAiC,SAAA,GACID,aAAA,SAAAhC,QAAA,G;AAER;AAEA,SAAAM,cAAAR,cAAA,EAAAV,iBAAA;;EAMI;;;AAGG;EACH,IAAA8C,OAAA,CAAAC,GAAA,CAAAC,QAAA,qB,qBAGIC,QAAA;;IAIAvC,cAAA,CAAAwC,YAAA,G;;AAIR;AAEA,SAAA9B,2BAAAb,KAAA;EACI;IAAA4C,IAAA;IAAAC;EAAA,IAAAC,kBAAA;EAEA,KAAAF,IAAA,KAAAC,MAAA,EAAsB;;;IAKlB3C,aAAA,EAAA0C,IAAA,aAAAA,IAAA,eAAAA,IAAA,CAAAG,SAAA,CAAA/C,KAAA,KAAA6C,MAAA,aAAAA,MAAA,eAAAA,MAAA,CAAAE,SAAA,CAAA/C,KAAA,I,yBAGQsC,SAAA;;;AAGhB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}