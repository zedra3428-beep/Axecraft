{"ast":null,"code":"import _objectSpread from \"/app/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _objectWithoutProperties from \"/app/frontend/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nconst _excluded = [\"defaultTransition\"],\n  _excluded2 = [\"delay\", \"times\", \"type\", \"repeat\", \"repeatType\", \"repeatDelay\"];\nimport { isMotionValue, defaultOffset, isGenerator, createGeneratorEasing, fillOffset } from 'motion-dom';\nimport { progress, secondsToMilliseconds, invariant, getEasingForSegment } from 'motion-utils';\nimport { resolveSubjects } from '../animate/resolve-subjects.mjs';\nimport { calculateRepeatDuration } from './utils/calc-repeat-duration.mjs';\nimport { calcNextTime } from './utils/calc-time.mjs';\nimport { addKeyframes } from './utils/edit.mjs';\nimport { normalizeTimes } from './utils/normalize-times.mjs';\nimport { compareByTime } from './utils/sort.mjs';\nconst defaultSegmentEasing = \"easeInOut\";\nconst MAX_REPEAT = 20;\nfunction createAnimationsFromSequence(sequence) {\n  let _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n    {\n      defaultTransition = {}\n    } = _ref,\n    sequenceTransition = _objectWithoutProperties(_ref, _excluded);\n  let scope = arguments.length > 2 ? arguments[2] : undefined;\n  let generators = arguments.length > 3 ? arguments[3] : undefined;\n  const defaultDuration = defaultTransition.duration || 0.3;\n  const animationDefinitions = new Map();\n  const sequences = new Map();\n  const elementCache = {};\n  const timeLabels = new Map();\n  let prevTime = 0;\n  let currentTime = 0;\n  let totalDuration = 0;\n  /**\n   * Build the timeline by mapping over the sequence array and converting\n   * the definitions into keyframes and offsets with absolute time values.\n   * These will later get converted into relative offsets in a second pass.\n   */\n  for (let i = 0; i < sequence.length; i++) {\n    const segment = sequence[i];\n    /**\n     * If this is a timeline label, mark it and skip the rest of this iteration.\n     */\n    if (typeof segment === \"string\") {\n      timeLabels.set(segment, currentTime);\n      continue;\n    } else if (!Array.isArray(segment)) {\n      timeLabels.set(segment.name, calcNextTime(currentTime, segment.at, prevTime, timeLabels));\n      continue;\n    }\n    let [subject, keyframes, transition = {}] = segment;\n    /**\n     * If a relative or absolute time value has been specified we need to resolve\n     * it in relation to the currentTime.\n     */\n    if (transition.at !== undefined) {\n      currentTime = calcNextTime(currentTime, transition.at, prevTime, timeLabels);\n    }\n    /**\n     * Keep track of the maximum duration in this definition. This will be\n     * applied to currentTime once the definition has been parsed.\n     */\n    let maxDuration = 0;\n    const resolveValueSequence = function (valueKeyframes, valueTransition, valueSequence) {\n      let elementIndex = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n      let numSubjects = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n      const valueKeyframesAsList = keyframesAsList(valueKeyframes);\n      const {\n          delay = 0,\n          times = defaultOffset(valueKeyframesAsList),\n          type = \"keyframes\",\n          repeat,\n          repeatType,\n          repeatDelay = 0\n        } = valueTransition,\n        remainingTransition = _objectWithoutProperties(valueTransition, _excluded2);\n      let {\n        ease = defaultTransition.ease || \"easeOut\",\n        duration\n      } = valueTransition;\n      /**\n       * Resolve stagger() if defined.\n       */\n      const calculatedDelay = typeof delay === \"function\" ? delay(elementIndex, numSubjects) : delay;\n      /**\n       * If this animation should and can use a spring, generate a spring easing function.\n       */\n      const numKeyframes = valueKeyframesAsList.length;\n      const createGenerator = isGenerator(type) ? type : generators === null || generators === void 0 ? void 0 : generators[type || \"keyframes\"];\n      if (numKeyframes <= 2 && createGenerator) {\n        /**\n         * As we're creating an easing function from a spring,\n         * ideally we want to generate it using the real distance\n         * between the two keyframes. However this isn't always\n         * possible - in these situations we use 0-100.\n         */\n        let absoluteDelta = 100;\n        if (numKeyframes === 2 && isNumberKeyframesArray(valueKeyframesAsList)) {\n          const delta = valueKeyframesAsList[1] - valueKeyframesAsList[0];\n          absoluteDelta = Math.abs(delta);\n        }\n        const springTransition = _objectSpread({}, remainingTransition);\n        if (duration !== undefined) {\n          springTransition.duration = secondsToMilliseconds(duration);\n        }\n        const springEasing = createGeneratorEasing(springTransition, absoluteDelta, createGenerator);\n        ease = springEasing.ease;\n        duration = springEasing.duration;\n      }\n      duration !== null && duration !== void 0 ? duration : duration = defaultDuration;\n      const startTime = currentTime + calculatedDelay;\n      /**\n       * If there's only one time offset of 0, fill in a second with length 1\n       */\n      if (times.length === 1 && times[0] === 0) {\n        times[1] = 1;\n      }\n      /**\n       * Fill out if offset if fewer offsets than keyframes\n       */\n      const remainder = times.length - valueKeyframesAsList.length;\n      remainder > 0 && fillOffset(times, remainder);\n      /**\n       * If only one value has been set, ie [1], push a null to the start of\n       * the keyframe array. This will let us mark a keyframe at this point\n       * that will later be hydrated with the previous value.\n       */\n      valueKeyframesAsList.length === 1 && valueKeyframesAsList.unshift(null);\n      /**\n       * Handle repeat options\n       */\n      if (repeat) {\n        invariant(repeat < MAX_REPEAT, \"Repeat count too high, must be less than 20\", \"repeat-count-high\");\n        duration = calculateRepeatDuration(duration, repeat);\n        const originalKeyframes = [...valueKeyframesAsList];\n        const originalTimes = [...times];\n        ease = Array.isArray(ease) ? [...ease] : [ease];\n        const originalEase = [...ease];\n        for (let repeatIndex = 0; repeatIndex < repeat; repeatIndex++) {\n          valueKeyframesAsList.push(...originalKeyframes);\n          for (let keyframeIndex = 0; keyframeIndex < originalKeyframes.length; keyframeIndex++) {\n            times.push(originalTimes[keyframeIndex] + (repeatIndex + 1));\n            ease.push(keyframeIndex === 0 ? \"linear\" : getEasingForSegment(originalEase, keyframeIndex - 1));\n          }\n        }\n        normalizeTimes(times, repeat);\n      }\n      const targetTime = startTime + duration;\n      /**\n       * Add keyframes, mapping offsets to absolute time.\n       */\n      addKeyframes(valueSequence, valueKeyframesAsList, ease, times, startTime, targetTime);\n      maxDuration = Math.max(calculatedDelay + duration, maxDuration);\n      totalDuration = Math.max(targetTime, totalDuration);\n    };\n    if (isMotionValue(subject)) {\n      const subjectSequence = getSubjectSequence(subject, sequences);\n      resolveValueSequence(keyframes, transition, getValueSequence(\"default\", subjectSequence));\n    } else {\n      const subjects = resolveSubjects(subject, keyframes, scope, elementCache);\n      const numSubjects = subjects.length;\n      /**\n       * For every element in this segment, process the defined values.\n       */\n      for (let subjectIndex = 0; subjectIndex < numSubjects; subjectIndex++) {\n        /**\n         * Cast necessary, but we know these are of this type\n         */\n        keyframes = keyframes;\n        transition = transition;\n        const thisSubject = subjects[subjectIndex];\n        const subjectSequence = getSubjectSequence(thisSubject, sequences);\n        for (const key in keyframes) {\n          resolveValueSequence(keyframes[key], getValueTransition(transition, key), getValueSequence(key, subjectSequence), subjectIndex, numSubjects);\n        }\n      }\n    }\n    prevTime = currentTime;\n    currentTime += maxDuration;\n  }\n  /**\n   * For every element and value combination create a new animation.\n   */\n  sequences.forEach((valueSequences, element) => {\n    for (const key in valueSequences) {\n      const valueSequence = valueSequences[key];\n      /**\n       * Arrange all the keyframes in ascending time order.\n       */\n      valueSequence.sort(compareByTime);\n      const keyframes = [];\n      const valueOffset = [];\n      const valueEasing = [];\n      /**\n       * For each keyframe, translate absolute times into\n       * relative offsets based on the total duration of the timeline.\n       */\n      for (let i = 0; i < valueSequence.length; i++) {\n        const {\n          at,\n          value,\n          easing\n        } = valueSequence[i];\n        keyframes.push(value);\n        valueOffset.push(progress(0, totalDuration, at));\n        valueEasing.push(easing || \"easeOut\");\n      }\n      /**\n       * If the first keyframe doesn't land on offset: 0\n       * provide one by duplicating the initial keyframe. This ensures\n       * it snaps to the first keyframe when the animation starts.\n       */\n      if (valueOffset[0] !== 0) {\n        valueOffset.unshift(0);\n        keyframes.unshift(keyframes[0]);\n        valueEasing.unshift(defaultSegmentEasing);\n      }\n      /**\n       * If the last keyframe doesn't land on offset: 1\n       * provide one with a null wildcard value. This will ensure it\n       * stays static until the end of the animation.\n       */\n      if (valueOffset[valueOffset.length - 1] !== 1) {\n        valueOffset.push(1);\n        keyframes.push(null);\n      }\n      if (!animationDefinitions.has(element)) {\n        animationDefinitions.set(element, {\n          keyframes: {},\n          transition: {}\n        });\n      }\n      const definition = animationDefinitions.get(element);\n      definition.keyframes[key] = keyframes;\n      definition.transition[key] = _objectSpread(_objectSpread({}, defaultTransition), {}, {\n        duration: totalDuration,\n        ease: valueEasing,\n        times: valueOffset\n      }, sequenceTransition);\n    }\n  });\n  return animationDefinitions;\n}\nfunction getSubjectSequence(subject, sequences) {\n  !sequences.has(subject) && sequences.set(subject, {});\n  return sequences.get(subject);\n}\nfunction getValueSequence(name, sequences) {\n  if (!sequences[name]) sequences[name] = [];\n  return sequences[name];\n}\nfunction keyframesAsList(keyframes) {\n  return Array.isArray(keyframes) ? keyframes : [keyframes];\n}\nfunction getValueTransition(transition, key) {\n  return transition && transition[key] ? _objectSpread(_objectSpread({}, transition), transition[key]) : _objectSpread({}, transition);\n}\nconst isNumber = keyframe => typeof keyframe === \"number\";\nconst isNumberKeyframesArray = keyframes => keyframes.every(isNumber);\nexport { createAnimationsFromSequence, getValueTransition };","map":{"version":3,"names":["defaultSegmentEasing","MAX_REPEAT","createAnimationsFromSequence","sequence","_ref","arguments","length","undefined","defaultTransition","sequenceTransition","_objectWithoutProperties","_excluded","scope","generators","defaultDuration","duration","animationDefinitions","Map","sequences","elementCache","timeLabels","prevTime","currentTime","totalDuration","i","segment","set","Array","isArray","name","calcNextTime","at","subject","keyframes","transition","maxDuration","resolveValueSequence","valueKeyframes","valueTransition","valueSequence","elementIndex","numSubjects","valueKeyframesAsList","keyframesAsList","delay","times","defaultOffset","type","repeat","repeatType","repeatDelay","remainingTransition","_excluded2","ease","calculatedDelay","numKeyframes","createGenerator","isGenerator","absoluteDelta","isNumberKeyframesArray","delta","Math","abs","springTransition","_objectSpread","secondsToMilliseconds","springEasing","createGeneratorEasing","startTime","remainder","fillOffset","unshift","invariant","calculateRepeatDuration","originalKeyframes","originalTimes","originalEase","repeatIndex","push","keyframeIndex","getEasingForSegment","normalizeTimes","targetTime","addKeyframes","max","isMotionValue","subjectSequence","getSubjectSequence","getValueSequence","subjects","resolveSubjects","subjectIndex","thisSubject","key","getValueTransition","forEach","valueSequences","element","sort","compareByTime","valueOffset","valueEasing","value","easing","progress","has","definition","get","isNumber","keyframe","every"],"sources":["/app/frontend/node_modules/framer-motion/src/animation/sequence/create.ts"],"sourcesContent":["import {\n    AnimationScope,\n    createGeneratorEasing,\n    defaultOffset,\n    DOMKeyframesDefinition,\n    AnimationOptions as DynamicAnimationOptions,\n    fillOffset,\n    GeneratorFactory,\n    isGenerator,\n    isMotionValue,\n    Transition,\n    UnresolvedValueKeyframe,\n    type AnyResolvedKeyframe,\n    type MotionValue,\n} from \"motion-dom\"\nimport {\n    Easing,\n    getEasingForSegment,\n    invariant,\n    progress,\n    secondsToMilliseconds,\n} from \"motion-utils\"\nimport { resolveSubjects } from \"../animate/resolve-subjects\"\nimport {\n    AnimationSequence,\n    At,\n    ResolvedAnimationDefinitions,\n    SequenceMap,\n    SequenceOptions,\n    ValueSequence,\n} from \"./types\"\nimport { calculateRepeatDuration } from \"./utils/calc-repeat-duration\"\nimport { calcNextTime } from \"./utils/calc-time\"\nimport { addKeyframes } from \"./utils/edit\"\nimport { normalizeTimes } from \"./utils/normalize-times\"\nimport { compareByTime } from \"./utils/sort\"\n\nconst defaultSegmentEasing = \"easeInOut\"\n\nconst MAX_REPEAT = 20\n\nexport function createAnimationsFromSequence(\n    sequence: AnimationSequence,\n    { defaultTransition = {}, ...sequenceTransition }: SequenceOptions = {},\n    scope?: AnimationScope,\n    generators?: { [key: string]: GeneratorFactory }\n): ResolvedAnimationDefinitions {\n    const defaultDuration = defaultTransition.duration || 0.3\n    const animationDefinitions: ResolvedAnimationDefinitions = new Map()\n    const sequences = new Map<Element | MotionValue, SequenceMap>()\n    const elementCache = {}\n    const timeLabels = new Map<string, number>()\n\n    let prevTime = 0\n    let currentTime = 0\n    let totalDuration = 0\n\n    /**\n     * Build the timeline by mapping over the sequence array and converting\n     * the definitions into keyframes and offsets with absolute time values.\n     * These will later get converted into relative offsets in a second pass.\n     */\n    for (let i = 0; i < sequence.length; i++) {\n        const segment = sequence[i]\n\n        /**\n         * If this is a timeline label, mark it and skip the rest of this iteration.\n         */\n        if (typeof segment === \"string\") {\n            timeLabels.set(segment, currentTime)\n            continue\n        } else if (!Array.isArray(segment)) {\n            timeLabels.set(\n                segment.name,\n                calcNextTime(currentTime, segment.at, prevTime, timeLabels)\n            )\n            continue\n        }\n\n        let [subject, keyframes, transition = {}] = segment\n\n        /**\n         * If a relative or absolute time value has been specified we need to resolve\n         * it in relation to the currentTime.\n         */\n        if (transition.at !== undefined) {\n            currentTime = calcNextTime(\n                currentTime,\n                transition.at,\n                prevTime,\n                timeLabels\n            )\n        }\n\n        /**\n         * Keep track of the maximum duration in this definition. This will be\n         * applied to currentTime once the definition has been parsed.\n         */\n        let maxDuration = 0\n\n        const resolveValueSequence = (\n            valueKeyframes: UnresolvedValueKeyframe | UnresolvedValueKeyframe[],\n            valueTransition: Transition | DynamicAnimationOptions,\n            valueSequence: ValueSequence,\n            elementIndex = 0,\n            numSubjects = 0\n        ) => {\n            const valueKeyframesAsList = keyframesAsList(valueKeyframes)\n            const {\n                delay = 0,\n                times = defaultOffset(valueKeyframesAsList),\n                type = \"keyframes\",\n                repeat,\n                repeatType,\n                repeatDelay = 0,\n                ...remainingTransition\n            } = valueTransition\n            let { ease = defaultTransition.ease || \"easeOut\", duration } =\n                valueTransition\n\n            /**\n             * Resolve stagger() if defined.\n             */\n            const calculatedDelay =\n                typeof delay === \"function\"\n                    ? delay(elementIndex, numSubjects)\n                    : delay\n\n            /**\n             * If this animation should and can use a spring, generate a spring easing function.\n             */\n            const numKeyframes = valueKeyframesAsList.length\n            const createGenerator = isGenerator(type)\n                ? type\n                : generators?.[type || \"keyframes\"]\n\n            if (numKeyframes <= 2 && createGenerator) {\n                /**\n                 * As we're creating an easing function from a spring,\n                 * ideally we want to generate it using the real distance\n                 * between the two keyframes. However this isn't always\n                 * possible - in these situations we use 0-100.\n                 */\n                let absoluteDelta = 100\n                if (\n                    numKeyframes === 2 &&\n                    isNumberKeyframesArray(valueKeyframesAsList)\n                ) {\n                    const delta =\n                        valueKeyframesAsList[1] - valueKeyframesAsList[0]\n                    absoluteDelta = Math.abs(delta)\n                }\n\n                const springTransition = { ...remainingTransition }\n                if (duration !== undefined) {\n                    springTransition.duration = secondsToMilliseconds(duration)\n                }\n\n                const springEasing = createGeneratorEasing(\n                    springTransition,\n                    absoluteDelta,\n                    createGenerator\n                )\n\n                ease = springEasing.ease\n                duration = springEasing.duration\n            }\n\n            duration ??= defaultDuration\n\n            const startTime = currentTime + calculatedDelay\n\n            /**\n             * If there's only one time offset of 0, fill in a second with length 1\n             */\n            if (times.length === 1 && times[0] === 0) {\n                times[1] = 1\n            }\n\n            /**\n             * Fill out if offset if fewer offsets than keyframes\n             */\n            const remainder = times.length - valueKeyframesAsList.length\n            remainder > 0 && fillOffset(times, remainder)\n\n            /**\n             * If only one value has been set, ie [1], push a null to the start of\n             * the keyframe array. This will let us mark a keyframe at this point\n             * that will later be hydrated with the previous value.\n             */\n            valueKeyframesAsList.length === 1 &&\n                valueKeyframesAsList.unshift(null)\n\n            /**\n             * Handle repeat options\n             */\n            if (repeat) {\n                invariant(\n                    repeat < MAX_REPEAT,\n                    \"Repeat count too high, must be less than 20\",\n                    \"repeat-count-high\"\n                )\n\n                duration = calculateRepeatDuration(\n                    duration,\n                    repeat,\n                    repeatDelay\n                )\n\n                const originalKeyframes = [...valueKeyframesAsList]\n                const originalTimes = [...times]\n                ease = Array.isArray(ease) ? [...ease] : [ease]\n                const originalEase = [...ease]\n\n                for (let repeatIndex = 0; repeatIndex < repeat; repeatIndex++) {\n                    valueKeyframesAsList.push(...originalKeyframes)\n\n                    for (\n                        let keyframeIndex = 0;\n                        keyframeIndex < originalKeyframes.length;\n                        keyframeIndex++\n                    ) {\n                        times.push(\n                            originalTimes[keyframeIndex] + (repeatIndex + 1)\n                        )\n                        ease.push(\n                            keyframeIndex === 0\n                                ? \"linear\"\n                                : getEasingForSegment(\n                                      originalEase,\n                                      keyframeIndex - 1\n                                  )\n                        )\n                    }\n                }\n\n                normalizeTimes(times, repeat)\n            }\n\n            const targetTime = startTime + duration\n\n            /**\n             * Add keyframes, mapping offsets to absolute time.\n             */\n            addKeyframes(\n                valueSequence,\n                valueKeyframesAsList,\n                ease as Easing | Easing[],\n                times,\n                startTime,\n                targetTime\n            )\n\n            maxDuration = Math.max(calculatedDelay + duration, maxDuration)\n            totalDuration = Math.max(targetTime, totalDuration)\n        }\n\n        if (isMotionValue(subject)) {\n            const subjectSequence = getSubjectSequence(subject, sequences)\n            resolveValueSequence(\n                keyframes as AnyResolvedKeyframe,\n                transition,\n                getValueSequence(\"default\", subjectSequence)\n            )\n        } else {\n            const subjects = resolveSubjects(\n                subject,\n                keyframes as DOMKeyframesDefinition,\n                scope,\n                elementCache\n            )\n\n            const numSubjects = subjects.length\n\n            /**\n             * For every element in this segment, process the defined values.\n             */\n            for (\n                let subjectIndex = 0;\n                subjectIndex < numSubjects;\n                subjectIndex++\n            ) {\n                /**\n                 * Cast necessary, but we know these are of this type\n                 */\n                keyframes = keyframes as DOMKeyframesDefinition\n                transition = transition as DynamicAnimationOptions\n\n                const thisSubject = subjects[subjectIndex]\n                const subjectSequence = getSubjectSequence(\n                    thisSubject,\n                    sequences\n                )\n\n                for (const key in keyframes) {\n                    resolveValueSequence(\n                        keyframes[\n                            key as keyof typeof keyframes\n                        ] as UnresolvedValueKeyframe,\n                        getValueTransition(transition, key),\n                        getValueSequence(key, subjectSequence),\n                        subjectIndex,\n                        numSubjects\n                    )\n                }\n            }\n        }\n\n        prevTime = currentTime\n        currentTime += maxDuration\n    }\n\n    /**\n     * For every element and value combination create a new animation.\n     */\n    sequences.forEach((valueSequences, element) => {\n        for (const key in valueSequences) {\n            const valueSequence = valueSequences[key]\n\n            /**\n             * Arrange all the keyframes in ascending time order.\n             */\n            valueSequence.sort(compareByTime)\n\n            const keyframes: UnresolvedValueKeyframe[] = []\n            const valueOffset: number[] = []\n            const valueEasing: Easing[] = []\n\n            /**\n             * For each keyframe, translate absolute times into\n             * relative offsets based on the total duration of the timeline.\n             */\n            for (let i = 0; i < valueSequence.length; i++) {\n                const { at, value, easing } = valueSequence[i]\n                keyframes.push(value)\n                valueOffset.push(progress(0, totalDuration, at))\n                valueEasing.push(easing || \"easeOut\")\n            }\n\n            /**\n             * If the first keyframe doesn't land on offset: 0\n             * provide one by duplicating the initial keyframe. This ensures\n             * it snaps to the first keyframe when the animation starts.\n             */\n            if (valueOffset[0] !== 0) {\n                valueOffset.unshift(0)\n                keyframes.unshift(keyframes[0])\n                valueEasing.unshift(defaultSegmentEasing)\n            }\n\n            /**\n             * If the last keyframe doesn't land on offset: 1\n             * provide one with a null wildcard value. This will ensure it\n             * stays static until the end of the animation.\n             */\n            if (valueOffset[valueOffset.length - 1] !== 1) {\n                valueOffset.push(1)\n                keyframes.push(null)\n            }\n\n            if (!animationDefinitions.has(element)) {\n                animationDefinitions.set(element, {\n                    keyframes: {},\n                    transition: {},\n                })\n            }\n\n            const definition = animationDefinitions.get(element)!\n\n            definition.keyframes[key] = keyframes\n            definition.transition[key] = {\n                ...defaultTransition,\n                duration: totalDuration,\n                ease: valueEasing,\n                times: valueOffset,\n                ...sequenceTransition,\n            }\n        }\n    })\n\n    return animationDefinitions\n}\n\nfunction getSubjectSequence<O extends {}>(\n    subject: Element | MotionValue | O,\n    sequences: Map<Element | MotionValue | O, SequenceMap>\n): SequenceMap {\n    !sequences.has(subject) && sequences.set(subject, {})\n    return sequences.get(subject)!\n}\n\nfunction getValueSequence(name: string, sequences: SequenceMap): ValueSequence {\n    if (!sequences[name]) sequences[name] = []\n    return sequences[name]\n}\n\nfunction keyframesAsList(\n    keyframes: UnresolvedValueKeyframe | UnresolvedValueKeyframe[]\n): UnresolvedValueKeyframe[] {\n    return Array.isArray(keyframes) ? keyframes : [keyframes]\n}\n\nexport function getValueTransition(\n    transition: DynamicAnimationOptions & At,\n    key: string\n): DynamicAnimationOptions {\n    return transition && transition[key as keyof typeof transition]\n        ? {\n              ...transition,\n              ...(transition[key as keyof typeof transition] as Transition),\n          }\n        : { ...transition }\n}\n\nconst isNumber = (keyframe: unknown) => typeof keyframe === \"number\"\nconst isNumberKeyframesArray = (\n    keyframes: UnresolvedValueKeyframe[]\n): keyframes is number[] => keyframes.every(isNumber)\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}