{"ast":null,"code":"import _objectSpread from \"/app/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { getValueTransition, makeAnimationInstant, frame, JSAnimation, AsyncMotionValueAnimation } from 'motion-dom';\nimport { secondsToMilliseconds, MotionGlobalConfig } from 'motion-utils';\nimport { getFinalKeyframe } from '../animators/waapi/utils/get-final-keyframe.mjs';\nimport { getDefaultTransition } from '../utils/default-transitions.mjs';\nimport { isTransitionDefined } from '../utils/is-transition-defined.mjs';\nconst animateMotionValue = function (name, value, target) {\n  let transition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  let element = arguments.length > 4 ? arguments[4] : undefined;\n  let isHandoff = arguments.length > 5 ? arguments[5] : undefined;\n  return onComplete => {\n    const valueTransition = getValueTransition(transition, name) || {};\n    /**\n     * Most transition values are currently completely overwritten by value-specific\n     * transitions. In the future it'd be nicer to blend these transitions. But for now\n     * delay actually does inherit from the root transition if not value-specific.\n     */\n    const delay = valueTransition.delay || transition.delay || 0;\n    /**\n     * Elapsed isn't a public transition option but can be passed through from\n     * optimized appear effects in milliseconds.\n     */\n    let {\n      elapsed = 0\n    } = transition;\n    elapsed = elapsed - secondsToMilliseconds(delay);\n    const options = _objectSpread(_objectSpread({\n      keyframes: Array.isArray(target) ? target : [null, target],\n      ease: \"easeOut\",\n      velocity: value.getVelocity()\n    }, valueTransition), {}, {\n      delay: -elapsed,\n      onUpdate: v => {\n        value.set(v);\n        valueTransition.onUpdate && valueTransition.onUpdate(v);\n      },\n      onComplete: () => {\n        onComplete();\n        valueTransition.onComplete && valueTransition.onComplete();\n      },\n      name,\n      motionValue: value,\n      element: isHandoff ? undefined : element\n    });\n    /**\n     * If there's no transition defined for this value, we can generate\n     * unique transition settings for this value.\n     */\n    if (!isTransitionDefined(valueTransition)) {\n      Object.assign(options, getDefaultTransition(name, options));\n    }\n    /**\n     * Both WAAPI and our internal animation functions use durations\n     * as defined by milliseconds, while our external API defines them\n     * as seconds.\n     */\n    options.duration && (options.duration = secondsToMilliseconds(options.duration));\n    options.repeatDelay && (options.repeatDelay = secondsToMilliseconds(options.repeatDelay));\n    /**\n     * Support deprecated way to set initial value. Prefer keyframe syntax.\n     */\n    if (options.from !== undefined) {\n      options.keyframes[0] = options.from;\n    }\n    let shouldSkip = false;\n    if (options.type === false || options.duration === 0 && !options.repeatDelay) {\n      makeAnimationInstant(options);\n      if (options.delay === 0) {\n        shouldSkip = true;\n      }\n    }\n    if (MotionGlobalConfig.instantAnimations || MotionGlobalConfig.skipAnimations) {\n      shouldSkip = true;\n      makeAnimationInstant(options);\n      options.delay = 0;\n    }\n    /**\n     * If the transition type or easing has been explicitly set by the user\n     * then we don't want to allow flattening the animation.\n     */\n    options.allowFlatten = !valueTransition.type && !valueTransition.ease;\n    /**\n     * If we can or must skip creating the animation, and apply only\n     * the final keyframe, do so. We also check once keyframes are resolved but\n     * this early check prevents the need to create an animation at all.\n     */\n    if (shouldSkip && !isHandoff && value.get() !== undefined) {\n      const finalKeyframe = getFinalKeyframe(options.keyframes, valueTransition);\n      if (finalKeyframe !== undefined) {\n        frame.update(() => {\n          options.onUpdate(finalKeyframe);\n          options.onComplete();\n        });\n        return;\n      }\n    }\n    return valueTransition.isSync ? new JSAnimation(options) : new AsyncMotionValueAnimation(options);\n  };\n};\nexport { animateMotionValue };","map":{"version":3,"names":["animateMotionValue","name","value","target","transition","arguments","length","undefined","element","isHandoff","onComplete","valueTransition","getValueTransition","delay","elapsed","secondsToMilliseconds","options","_objectSpread","keyframes","Array","isArray","ease","velocity","getVelocity","onUpdate","v","set","motionValue","isTransitionDefined","Object","assign","getDefaultTransition","duration","repeatDelay","from","shouldSkip","type","makeAnimationInstant","MotionGlobalConfig","instantAnimations","skipAnimations","allowFlatten","get","finalKeyframe","getFinalKeyframe","frame","update","isSync","JSAnimation","AsyncMotionValueAnimation"],"sources":["/app/frontend/node_modules/framer-motion/src/animation/interfaces/motion-value.ts"],"sourcesContent":["import type {\n    AnyResolvedKeyframe,\n    MotionValue,\n    StartAnimation,\n    UnresolvedKeyframes,\n    ValueTransition,\n} from \"motion-dom\"\nimport {\n    AsyncMotionValueAnimation,\n    frame,\n    getValueTransition,\n    JSAnimation,\n    makeAnimationInstant,\n    ValueAnimationOptions,\n} from \"motion-dom\"\nimport { MotionGlobalConfig, secondsToMilliseconds } from \"motion-utils\"\nimport type { VisualElement } from \"../../render/VisualElement\"\nimport { getFinalKeyframe } from \"../animators/waapi/utils/get-final-keyframe\"\nimport { getDefaultTransition } from \"../utils/default-transitions\"\nimport { isTransitionDefined } from \"../utils/is-transition-defined\"\n\nexport const animateMotionValue =\n    <V extends AnyResolvedKeyframe>(\n        name: string,\n        value: MotionValue<V>,\n        target: V | UnresolvedKeyframes<V>,\n        transition: ValueTransition & { elapsed?: number } = {},\n        element?: VisualElement<any>,\n        isHandoff?: boolean\n    ): StartAnimation =>\n    (onComplete) => {\n        const valueTransition = getValueTransition(transition, name) || {}\n\n        /**\n         * Most transition values are currently completely overwritten by value-specific\n         * transitions. In the future it'd be nicer to blend these transitions. But for now\n         * delay actually does inherit from the root transition if not value-specific.\n         */\n        const delay = valueTransition.delay || transition.delay || 0\n\n        /**\n         * Elapsed isn't a public transition option but can be passed through from\n         * optimized appear effects in milliseconds.\n         */\n        let { elapsed = 0 } = transition\n        elapsed = elapsed - secondsToMilliseconds(delay)\n\n        const options: ValueAnimationOptions = {\n            keyframes: Array.isArray(target) ? target : [null, target],\n            ease: \"easeOut\",\n            velocity: value.getVelocity(),\n            ...valueTransition,\n            delay: -elapsed,\n            onUpdate: (v) => {\n                value.set(v)\n                valueTransition.onUpdate && valueTransition.onUpdate(v)\n            },\n            onComplete: () => {\n                onComplete()\n                valueTransition.onComplete && valueTransition.onComplete()\n            },\n            name,\n            motionValue: value,\n            element: isHandoff ? undefined : element,\n        }\n\n        /**\n         * If there's no transition defined for this value, we can generate\n         * unique transition settings for this value.\n         */\n        if (!isTransitionDefined(valueTransition)) {\n            Object.assign(options, getDefaultTransition(name, options))\n        }\n\n        /**\n         * Both WAAPI and our internal animation functions use durations\n         * as defined by milliseconds, while our external API defines them\n         * as seconds.\n         */\n        options.duration &&= secondsToMilliseconds(options.duration)\n        options.repeatDelay &&= secondsToMilliseconds(options.repeatDelay)\n\n        /**\n         * Support deprecated way to set initial value. Prefer keyframe syntax.\n         */\n        if (options.from !== undefined) {\n            options.keyframes[0] = options.from as any\n        }\n\n        let shouldSkip = false\n\n        if (\n            (options as any).type === false ||\n            (options.duration === 0 && !options.repeatDelay)\n        ) {\n            makeAnimationInstant(options)\n\n            if (options.delay === 0) {\n                shouldSkip = true\n            }\n        }\n\n        if (\n            MotionGlobalConfig.instantAnimations ||\n            MotionGlobalConfig.skipAnimations\n        ) {\n            shouldSkip = true\n            makeAnimationInstant(options)\n            options.delay = 0\n        }\n\n        /**\n         * If the transition type or easing has been explicitly set by the user\n         * then we don't want to allow flattening the animation.\n         */\n        options.allowFlatten = !valueTransition.type && !valueTransition.ease\n\n        /**\n         * If we can or must skip creating the animation, and apply only\n         * the final keyframe, do so. We also check once keyframes are resolved but\n         * this early check prevents the need to create an animation at all.\n         */\n        if (shouldSkip && !isHandoff && value.get() !== undefined) {\n            const finalKeyframe = getFinalKeyframe<V>(\n                options.keyframes as V[],\n                valueTransition\n            )\n\n            if (finalKeyframe !== undefined) {\n                frame.update(() => {\n                    options.onUpdate!(finalKeyframe)\n                    options.onComplete!()\n                })\n\n                return\n            }\n        }\n\n        return valueTransition.isSync\n            ? new JSAnimation(options)\n            : new AsyncMotionValueAnimation(options)\n    }\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}