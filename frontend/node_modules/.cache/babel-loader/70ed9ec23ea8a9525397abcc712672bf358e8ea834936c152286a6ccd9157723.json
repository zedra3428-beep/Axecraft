{"ast":null,"code":"import { document, globalThis } from \"../utils/server-safe-globals.js\";\nimport { AvailabilityStates, StreamTypes, TextTrackKinds } from \"../constants.js\";\nimport { containsComposedNode } from \"../utils/element-utils.js\";\nimport { enterFullscreen, exitFullscreen, isFullscreen } from \"../utils/fullscreen-api.js\";\nimport { airplaySupported, castSupported, fullscreenSupported, hasFullscreenSupport, hasPipSupport, hasVolumeSupportAsync, pipSupported } from \"../utils/platform-tests.js\";\nimport { getShowingSubtitleTracks, getSubtitleTracks, toggleSubtitleTracks } from \"./util.js\";\nimport { getTextTracksList } from \"../utils/captions.js\";\nimport { isValidNumber } from \"../utils/utils.js\";\nconst StreamTypeValues = Object.values(StreamTypes);\nlet volumeSupported;\nconst volumeSupportPromise = hasVolumeSupportAsync().then(supported => {\n  volumeSupported = supported;\n  return volumeSupported;\n});\nconst prepareStateOwners = async (...stateOwners) => {\n  await Promise.all(stateOwners.filter(x => x).map(async stateOwner => {\n    if (!(\"localName\" in stateOwner && stateOwner instanceof globalThis.HTMLElement)) {\n      return;\n    }\n    const name = stateOwner.localName;\n    if (!name.includes(\"-\")) return;\n    const classDef = globalThis.customElements.get(name);\n    if (classDef && stateOwner instanceof classDef) return;\n    await globalThis.customElements.whenDefined(name);\n    globalThis.customElements.upgrade(stateOwner);\n  }));\n};\nconst domParser = new globalThis.DOMParser();\nconst parseHtmlToText = text => text ? domParser.parseFromString(text, \"text/html\").body.textContent || text : text;\nconst stateMediator = {\n  mediaError: {\n    get(stateOwners, event) {\n      const {\n        media\n      } = stateOwners;\n      if ((event == null ? void 0 : event.type) === \"playing\") return;\n      return media == null ? void 0 : media.error;\n    },\n    mediaEvents: [\"emptied\", \"error\", \"playing\"]\n  },\n  mediaErrorCode: {\n    get(stateOwners, event) {\n      var _a;\n      const {\n        media\n      } = stateOwners;\n      if ((event == null ? void 0 : event.type) === \"playing\") return;\n      return (_a = media == null ? void 0 : media.error) == null ? void 0 : _a.code;\n    },\n    mediaEvents: [\"emptied\", \"error\", \"playing\"]\n  },\n  mediaErrorMessage: {\n    get(stateOwners, event) {\n      var _a, _b;\n      const {\n        media\n      } = stateOwners;\n      if ((event == null ? void 0 : event.type) === \"playing\") return;\n      return (_b = (_a = media == null ? void 0 : media.error) == null ? void 0 : _a.message) != null ? _b : \"\";\n    },\n    mediaEvents: [\"emptied\", \"error\", \"playing\"]\n  },\n  mediaWidth: {\n    get(stateOwners) {\n      var _a;\n      const {\n        media\n      } = stateOwners;\n      return (_a = media == null ? void 0 : media.videoWidth) != null ? _a : 0;\n    },\n    mediaEvents: [\"resize\"]\n  },\n  mediaHeight: {\n    get(stateOwners) {\n      var _a;\n      const {\n        media\n      } = stateOwners;\n      return (_a = media == null ? void 0 : media.videoHeight) != null ? _a : 0;\n    },\n    mediaEvents: [\"resize\"]\n  },\n  mediaPaused: {\n    get(stateOwners) {\n      var _a;\n      const {\n        media\n      } = stateOwners;\n      return (_a = media == null ? void 0 : media.paused) != null ? _a : true;\n    },\n    set(value, stateOwners) {\n      var _a;\n      const {\n        media\n      } = stateOwners;\n      if (!media) return;\n      if (value) {\n        media.pause();\n      } else {\n        (_a = media.play()) == null ? void 0 : _a.catch(() => {});\n      }\n    },\n    mediaEvents: [\"play\", \"playing\", \"pause\", \"emptied\"]\n  },\n  mediaHasPlayed: {\n    // We want to let the user know that the media started playing at any point (`media-has-played`).\n    // Since these propagators are all called when boostrapping state, let's verify this is\n    // a real playing event by checking that 1) there's media and 2) it isn't currently paused.\n    get(stateOwners, event) {\n      const {\n        media\n      } = stateOwners;\n      if (!media) return false;\n      if (!event) return !media.paused;\n      return event.type === \"playing\";\n    },\n    mediaEvents: [\"playing\", \"emptied\"]\n  },\n  mediaEnded: {\n    get(stateOwners) {\n      var _a;\n      const {\n        media\n      } = stateOwners;\n      return (_a = media == null ? void 0 : media.ended) != null ? _a : false;\n    },\n    mediaEvents: [\"seeked\", \"ended\", \"emptied\"]\n  },\n  mediaPlaybackRate: {\n    get(stateOwners) {\n      var _a;\n      const {\n        media\n      } = stateOwners;\n      return (_a = media == null ? void 0 : media.playbackRate) != null ? _a : 1;\n    },\n    set(value, stateOwners) {\n      const {\n        media\n      } = stateOwners;\n      if (!media) return;\n      if (!Number.isFinite(+value)) return;\n      media.playbackRate = +value;\n    },\n    mediaEvents: [\"ratechange\", \"loadstart\"]\n  },\n  mediaMuted: {\n    get(stateOwners) {\n      var _a;\n      const {\n        media\n      } = stateOwners;\n      return (_a = media == null ? void 0 : media.muted) != null ? _a : false;\n    },\n    set(value, stateOwners) {\n      const {\n        media,\n        options: {\n          noMutedPref\n        } = {}\n      } = stateOwners;\n      if (!media) return;\n      media.muted = value;\n      try {\n        const hasLocalStoragePrefMuted = globalThis.localStorage.getItem(\"media-chrome-pref-muted\") !== null;\n        const hasMutedAttribute = media.hasAttribute(\"muted\");\n        if (noMutedPref) {\n          if (hasLocalStoragePrefMuted) globalThis.localStorage.removeItem(\"media-chrome-pref-muted\");\n          return;\n        }\n        if (hasMutedAttribute && !hasLocalStoragePrefMuted) {\n          return;\n        }\n        globalThis.localStorage.setItem(\"media-chrome-pref-muted\", value ? \"true\" : \"false\");\n      } catch (e) {\n        console.debug(\"Error setting muted pref\", e);\n      }\n    },\n    mediaEvents: [\"volumechange\"],\n    stateOwnersUpdateHandlers: [(handler, stateOwners) => {\n      const {\n        options: {\n          noMutedPref\n        }\n      } = stateOwners;\n      const {\n        media\n      } = stateOwners;\n      if (!media || media.muted || noMutedPref) return;\n      try {\n        const mutedPref = globalThis.localStorage.getItem(\"media-chrome-pref-muted\") === \"true\";\n        stateMediator.mediaMuted.set(mutedPref, stateOwners);\n        handler(mutedPref);\n      } catch (e) {\n        console.debug(\"Error getting muted pref\", e);\n      }\n    }]\n  },\n  mediaLoop: {\n    get(stateOwners) {\n      const {\n        media\n      } = stateOwners;\n      return media == null ? void 0 : media.loop;\n    },\n    set(value, stateOwners) {\n      const {\n        media\n      } = stateOwners;\n      if (!media) return;\n      media.loop = value;\n    },\n    mediaEvents: [\"medialooprequest\"]\n  },\n  mediaVolume: {\n    get(stateOwners) {\n      var _a;\n      const {\n        media\n      } = stateOwners;\n      return (_a = media == null ? void 0 : media.volume) != null ? _a : 1;\n    },\n    set(value, stateOwners) {\n      const {\n        media,\n        options: {\n          noVolumePref\n        } = {}\n      } = stateOwners;\n      if (!media) return;\n      try {\n        if (value == null) {\n          globalThis.localStorage.removeItem(\"media-chrome-pref-volume\");\n        } else if (!media.hasAttribute(\"muted\") && !noVolumePref) {\n          globalThis.localStorage.setItem(\"media-chrome-pref-volume\", value.toString());\n        }\n      } catch (e) {\n        console.debug(\"Error setting volume pref\", e);\n      }\n      if (!Number.isFinite(+value)) return;\n      media.volume = +value;\n    },\n    mediaEvents: [\"volumechange\"],\n    stateOwnersUpdateHandlers: [(handler, stateOwners) => {\n      const {\n        options: {\n          noVolumePref\n        }\n      } = stateOwners;\n      if (noVolumePref) return;\n      try {\n        const {\n          media\n        } = stateOwners;\n        if (!media) return;\n        const volumePref = globalThis.localStorage.getItem(\"media-chrome-pref-volume\");\n        if (volumePref == null) return;\n        stateMediator.mediaVolume.set(+volumePref, stateOwners);\n        handler(+volumePref);\n      } catch (e) {\n        console.debug(\"Error getting volume pref\", e);\n      }\n    }]\n  },\n  // NOTE: Keeping this roughly equivalent to prior impl to reduce number of changes,\n  // however we may want to model \"derived\" state differently from \"primary\" state\n  // (in this case, derived === mediaVolumeLevel, primary === mediaMuted, mediaVolume) (CJP)\n  mediaVolumeLevel: {\n    get(stateOwners) {\n      const {\n        media\n      } = stateOwners;\n      if (typeof (media == null ? void 0 : media.volume) == \"undefined\") return \"high\";\n      if (media.muted || media.volume === 0) return \"off\";\n      if (media.volume < 0.5) return \"low\";\n      if (media.volume < 0.75) return \"medium\";\n      return \"high\";\n    },\n    mediaEvents: [\"volumechange\"]\n  },\n  mediaCurrentTime: {\n    get(stateOwners) {\n      var _a;\n      const {\n        media\n      } = stateOwners;\n      return (_a = media == null ? void 0 : media.currentTime) != null ? _a : 0;\n    },\n    set(value, stateOwners) {\n      const {\n        media\n      } = stateOwners;\n      if (!media || !isValidNumber(value)) return;\n      media.currentTime = value;\n    },\n    mediaEvents: [\"timeupdate\", \"loadedmetadata\"]\n  },\n  mediaDuration: {\n    get(stateOwners) {\n      const {\n        media,\n        options: {\n          defaultDuration\n        } = {}\n      } = stateOwners;\n      if (defaultDuration && (!media || !media.duration || Number.isNaN(media.duration) || !Number.isFinite(media.duration))) {\n        return defaultDuration;\n      }\n      return Number.isFinite(media == null ? void 0 : media.duration) ? media.duration : Number.NaN;\n    },\n    mediaEvents: [\"durationchange\", \"loadedmetadata\", \"emptied\"]\n  },\n  mediaLoading: {\n    get(stateOwners) {\n      const {\n        media\n      } = stateOwners;\n      return (media == null ? void 0 : media.readyState) < 3;\n    },\n    mediaEvents: [\"waiting\", \"playing\", \"emptied\"]\n  },\n  mediaSeekable: {\n    get(stateOwners) {\n      var _a;\n      const {\n        media\n      } = stateOwners;\n      if (!((_a = media == null ? void 0 : media.seekable) == null ? void 0 : _a.length)) return void 0;\n      const start = media.seekable.start(0);\n      const end = media.seekable.end(media.seekable.length - 1);\n      if (!start && !end) return void 0;\n      return [Number(start.toFixed(3)), Number(end.toFixed(3))];\n    },\n    mediaEvents: [\"loadedmetadata\", \"emptied\", \"progress\", \"seekablechange\"]\n  },\n  mediaBuffered: {\n    get(stateOwners) {\n      var _a;\n      const {\n        media\n      } = stateOwners;\n      const timeRanges = (_a = media == null ? void 0 : media.buffered) != null ? _a : [];\n      return Array.from(timeRanges).map((_, i) => [Number(timeRanges.start(i).toFixed(3)), Number(timeRanges.end(i).toFixed(3))]);\n    },\n    mediaEvents: [\"progress\", \"emptied\"]\n  },\n  mediaStreamType: {\n    get(stateOwners) {\n      const {\n        media,\n        options: {\n          defaultStreamType\n        } = {}\n      } = stateOwners;\n      const usedDefaultStreamType = [StreamTypes.LIVE, StreamTypes.ON_DEMAND].includes(defaultStreamType) ? defaultStreamType : void 0;\n      if (!media) return usedDefaultStreamType;\n      const {\n        streamType\n      } = media;\n      if (StreamTypeValues.includes(streamType)) {\n        if (streamType === StreamTypes.UNKNOWN) {\n          return usedDefaultStreamType;\n        }\n        return streamType;\n      }\n      const duration = media.duration;\n      if (duration === Infinity) {\n        return StreamTypes.LIVE;\n      } else if (Number.isFinite(duration)) {\n        return StreamTypes.ON_DEMAND;\n      }\n      return usedDefaultStreamType;\n    },\n    mediaEvents: [\"emptied\", \"durationchange\", \"loadedmetadata\", \"streamtypechange\"]\n  },\n  mediaTargetLiveWindow: {\n    get(stateOwners) {\n      const {\n        media\n      } = stateOwners;\n      if (!media) return Number.NaN;\n      const {\n        targetLiveWindow\n      } = media;\n      const streamType = stateMediator.mediaStreamType.get(stateOwners);\n      if ((targetLiveWindow == null || Number.isNaN(targetLiveWindow)) && streamType === StreamTypes.LIVE) {\n        return 0;\n      }\n      return targetLiveWindow;\n    },\n    mediaEvents: [\"emptied\", \"durationchange\", \"loadedmetadata\", \"streamtypechange\", \"targetlivewindowchange\"]\n  },\n  mediaTimeIsLive: {\n    get(stateOwners) {\n      const {\n        media,\n        // Default to 10 seconds\n        options: {\n          liveEdgeOffset = 10\n        } = {}\n      } = stateOwners;\n      if (!media) return false;\n      if (typeof media.liveEdgeStart === \"number\") {\n        if (Number.isNaN(media.liveEdgeStart)) return false;\n        return media.currentTime >= media.liveEdgeStart;\n      }\n      const live = stateMediator.mediaStreamType.get(stateOwners) === StreamTypes.LIVE;\n      if (!live) return false;\n      const seekable = media.seekable;\n      if (!seekable) return true;\n      if (!seekable.length) return false;\n      const liveEdgeStart = seekable.end(seekable.length - 1) - liveEdgeOffset;\n      return media.currentTime >= liveEdgeStart;\n    },\n    mediaEvents: [\"playing\", \"timeupdate\", \"progress\", \"waiting\", \"emptied\"]\n  },\n  // Text Tracks modeling\n  mediaSubtitlesList: {\n    get(stateOwners) {\n      return getSubtitleTracks(stateOwners).map(({\n        kind,\n        label,\n        language\n      }) => ({\n        kind,\n        label,\n        language\n      }));\n    },\n    mediaEvents: [\"loadstart\"],\n    textTracksEvents: [\"addtrack\", \"removetrack\"]\n  },\n  mediaSubtitlesShowing: {\n    get(stateOwners) {\n      return getShowingSubtitleTracks(stateOwners).map(({\n        kind,\n        label,\n        language\n      }) => ({\n        kind,\n        label,\n        language\n      }));\n    },\n    mediaEvents: [\"loadstart\"],\n    textTracksEvents: [\"addtrack\", \"removetrack\", \"change\"],\n    stateOwnersUpdateHandlers: [(_handler, stateOwners) => {\n      var _a, _b;\n      const {\n        media,\n        options\n      } = stateOwners;\n      if (!media) return;\n      const updateDefaultSubtitlesCallback = event => {\n        var _a2;\n        if (!options.defaultSubtitles) return;\n        const nonSubsEvent = event && ![TextTrackKinds.CAPTIONS, TextTrackKinds.SUBTITLES].includes(\n        // @ts-ignore\n        (_a2 = event == null ? void 0 : event.track) == null ? void 0 : _a2.kind);\n        if (nonSubsEvent) return;\n        toggleSubtitleTracks(stateOwners, true);\n      };\n      media.addEventListener(\"loadstart\", updateDefaultSubtitlesCallback);\n      (_a = media.textTracks) == null ? void 0 : _a.addEventListener(\"addtrack\", updateDefaultSubtitlesCallback);\n      (_b = media.textTracks) == null ? void 0 : _b.addEventListener(\"removetrack\", updateDefaultSubtitlesCallback);\n      return () => {\n        var _a2, _b2;\n        media.removeEventListener(\"loadstart\", updateDefaultSubtitlesCallback);\n        (_a2 = media.textTracks) == null ? void 0 : _a2.removeEventListener(\"addtrack\", updateDefaultSubtitlesCallback);\n        (_b2 = media.textTracks) == null ? void 0 : _b2.removeEventListener(\"removetrack\", updateDefaultSubtitlesCallback);\n      };\n    }]\n  },\n  mediaChaptersCues: {\n    get(stateOwners) {\n      var _a;\n      const {\n        media\n      } = stateOwners;\n      if (!media) return [];\n      const [chaptersTrack] = getTextTracksList(media, {\n        kind: TextTrackKinds.CHAPTERS\n      });\n      return Array.from((_a = chaptersTrack == null ? void 0 : chaptersTrack.cues) != null ? _a : []).map(({\n        text,\n        startTime,\n        endTime\n      }) => ({\n        text: parseHtmlToText(text),\n        startTime,\n        endTime\n      }));\n    },\n    mediaEvents: [\"loadstart\", \"loadedmetadata\"],\n    textTracksEvents: [\"addtrack\", \"removetrack\", \"change\"],\n    stateOwnersUpdateHandlers: [(handler, stateOwners) => {\n      var _a;\n      const {\n        media\n      } = stateOwners;\n      if (!media) return;\n      const chaptersTrack = media.querySelector('track[kind=\"chapters\"][default][src]');\n      const shadowChaptersTrack = (_a = media.shadowRoot) == null ? void 0 : _a.querySelector(':is(video,audio) > track[kind=\"chapters\"][default][src]');\n      chaptersTrack == null ? void 0 : chaptersTrack.addEventListener(\"load\", handler);\n      shadowChaptersTrack == null ? void 0 : shadowChaptersTrack.addEventListener(\"load\", handler);\n      return () => {\n        chaptersTrack == null ? void 0 : chaptersTrack.removeEventListener(\"load\", handler);\n        shadowChaptersTrack == null ? void 0 : shadowChaptersTrack.removeEventListener(\"load\", handler);\n      };\n    }]\n  },\n  // Modeling state tied to root node\n  mediaIsPip: {\n    get(stateOwners) {\n      var _a, _b;\n      const {\n        media,\n        documentElement\n      } = stateOwners;\n      if (!media || !documentElement) return false;\n      if (!documentElement.pictureInPictureElement) return false;\n      if (documentElement.pictureInPictureElement === media) return true;\n      if (documentElement.pictureInPictureElement instanceof HTMLMediaElement) {\n        if (!((_a = media.localName) == null ? void 0 : _a.includes(\"-\"))) return false;\n        return containsComposedNode(media, documentElement.pictureInPictureElement);\n      }\n      if (documentElement.pictureInPictureElement.localName.includes(\"-\")) {\n        let currentRoot = documentElement.pictureInPictureElement.shadowRoot;\n        while (currentRoot == null ? void 0 : currentRoot.pictureInPictureElement) {\n          if (currentRoot.pictureInPictureElement === media) return true;\n          currentRoot = (_b = currentRoot.pictureInPictureElement) == null ? void 0 : _b.shadowRoot;\n        }\n      }\n      return false;\n    },\n    set(value, stateOwners) {\n      const {\n        media\n      } = stateOwners;\n      if (!media) return;\n      if (value) {\n        if (!document.pictureInPictureEnabled) {\n          console.warn(\"MediaChrome: Picture-in-picture is not enabled\");\n          return;\n        }\n        if (!media.requestPictureInPicture) {\n          console.warn(\"MediaChrome: The current media does not support picture-in-picture\");\n          return;\n        }\n        const warnNotReady = () => {\n          console.warn(\"MediaChrome: The media is not ready for picture-in-picture. It must have a readyState > 0.\");\n        };\n        media.requestPictureInPicture().catch(err => {\n          if (err.code === 11) {\n            if (!media.src) {\n              console.warn(\"MediaChrome: The media is not ready for picture-in-picture. It must have a src set.\");\n              return;\n            }\n            if (media.readyState === 0 && media.preload === \"none\") {\n              const cleanup = () => {\n                media.removeEventListener(\"loadedmetadata\", tryPip);\n                media.preload = \"none\";\n              };\n              const tryPip = () => {\n                media.requestPictureInPicture().catch(warnNotReady);\n                cleanup();\n              };\n              media.addEventListener(\"loadedmetadata\", tryPip);\n              media.preload = \"metadata\";\n              setTimeout(() => {\n                if (media.readyState === 0) warnNotReady();\n                cleanup();\n              }, 1e3);\n            } else {\n              throw err;\n            }\n          } else {\n            throw err;\n          }\n        });\n      } else if (document.pictureInPictureElement) {\n        document.exitPictureInPicture();\n      }\n    },\n    mediaEvents: [\"enterpictureinpicture\", \"leavepictureinpicture\"]\n  },\n  mediaRenditionList: {\n    get(stateOwners) {\n      var _a;\n      const {\n        media\n      } = stateOwners;\n      return [...((_a = media == null ? void 0 : media.videoRenditions) != null ? _a : [])].map(videoRendition => ({\n        ...videoRendition\n      }));\n    },\n    mediaEvents: [\"emptied\", \"loadstart\"],\n    videoRenditionsEvents: [\"addrendition\", \"removerendition\"]\n  },\n  /** @TODO Model this as a derived value? (CJP) */\n  mediaRenditionSelected: {\n    get(stateOwners) {\n      var _a, _b, _c;\n      const {\n        media\n      } = stateOwners;\n      return (_c = (_b = media == null ? void 0 : media.videoRenditions) == null ? void 0 : _b[(_a = media.videoRenditions) == null ? void 0 : _a.selectedIndex]) == null ? void 0 : _c.id;\n    },\n    set(value, stateOwners) {\n      const {\n        media\n      } = stateOwners;\n      if (!(media == null ? void 0 : media.videoRenditions)) {\n        console.warn(\"MediaController: Rendition selection not supported by this media.\");\n        return;\n      }\n      const renditionId = value;\n      const index = Array.prototype.findIndex.call(media.videoRenditions, r => r.id == renditionId);\n      if (media.videoRenditions.selectedIndex != index) {\n        media.videoRenditions.selectedIndex = index;\n      }\n    },\n    mediaEvents: [\"emptied\"],\n    videoRenditionsEvents: [\"addrendition\", \"removerendition\", \"change\"]\n  },\n  mediaAudioTrackList: {\n    get(stateOwners) {\n      var _a;\n      const {\n        media\n      } = stateOwners;\n      return [...((_a = media == null ? void 0 : media.audioTracks) != null ? _a : [])];\n    },\n    mediaEvents: [\"emptied\", \"loadstart\"],\n    audioTracksEvents: [\"addtrack\", \"removetrack\"]\n  },\n  mediaAudioTrackEnabled: {\n    get(stateOwners) {\n      var _a, _b;\n      const {\n        media\n      } = stateOwners;\n      return (_b = [...((_a = media == null ? void 0 : media.audioTracks) != null ? _a : [])].find(audioTrack => audioTrack.enabled)) == null ? void 0 : _b.id;\n    },\n    set(value, stateOwners) {\n      const {\n        media\n      } = stateOwners;\n      if (!(media == null ? void 0 : media.audioTracks)) {\n        console.warn(\"MediaChrome: Audio track selection not supported by this media.\");\n        return;\n      }\n      const audioTrackId = value;\n      for (const track of media.audioTracks) {\n        track.enabled = audioTrackId == track.id;\n      }\n    },\n    mediaEvents: [\"emptied\"],\n    audioTracksEvents: [\"addtrack\", \"removetrack\", \"change\"]\n  },\n  mediaIsFullscreen: {\n    get(stateOwners) {\n      return isFullscreen(stateOwners);\n    },\n    set(value, stateOwners, event) {\n      var _a;\n      if (!value) {\n        exitFullscreen(stateOwners);\n      } else {\n        enterFullscreen(stateOwners);\n        const isPointer = event.detail;\n        if (isPointer) (_a = stateOwners.media) == null ? void 0 : _a.focus();\n      }\n    },\n    // older Safari version may require webkit-specific events\n    rootEvents: [\"fullscreenchange\", \"webkitfullscreenchange\"],\n    // iOS requires webkit-specific events on the video.\n    mediaEvents: [\"webkitbeginfullscreen\", \"webkitendfullscreen\", \"webkitpresentationmodechanged\"]\n  },\n  mediaIsCasting: {\n    // Note this relies on a customized castable-video element.\n    get(stateOwners) {\n      var _a;\n      const {\n        media\n      } = stateOwners;\n      if (!(media == null ? void 0 : media.remote) || ((_a = media.remote) == null ? void 0 : _a.state) === \"disconnected\") return false;\n      return !!media.remote.state;\n    },\n    set(value, stateOwners) {\n      var _a, _b;\n      const {\n        media\n      } = stateOwners;\n      if (!media) return;\n      if (value && ((_a = media.remote) == null ? void 0 : _a.state) !== \"disconnected\") return;\n      if (!value && ((_b = media.remote) == null ? void 0 : _b.state) !== \"connected\") return;\n      if (typeof media.remote.prompt !== \"function\") {\n        console.warn(\"MediaChrome: Casting is not supported in this environment\");\n        return;\n      }\n      media.remote.prompt().catch(() => {});\n    },\n    remoteEvents: [\"connect\", \"connecting\", \"disconnect\"]\n  },\n  // NOTE: Newly added state for tracking airplaying\n  mediaIsAirplaying: {\n    // NOTE: Cannot know if airplaying since Safari doesn't fully support HTMLMediaElement::remote yet (e.g. remote::state) (CJP)\n    get() {\n      return false;\n    },\n    set(_value, stateOwners) {\n      const {\n        media\n      } = stateOwners;\n      if (!media) return;\n      if (!(media.webkitShowPlaybackTargetPicker && globalThis.WebKitPlaybackTargetAvailabilityEvent)) {\n        console.error(\"MediaChrome: received a request to select AirPlay but AirPlay is not supported in this environment\");\n        return;\n      }\n      media.webkitShowPlaybackTargetPicker();\n    },\n    mediaEvents: [\"webkitcurrentplaybacktargetiswirelesschanged\"]\n  },\n  mediaFullscreenUnavailable: {\n    get(stateOwners) {\n      const {\n        media\n      } = stateOwners;\n      if (!fullscreenSupported || !hasFullscreenSupport(media)) return AvailabilityStates.UNSUPPORTED;\n      return void 0;\n    }\n  },\n  mediaPipUnavailable: {\n    get(stateOwners) {\n      const {\n        media\n      } = stateOwners;\n      if (!pipSupported || !hasPipSupport(media)) return AvailabilityStates.UNSUPPORTED;else if (media == null ? void 0 : media.disablePictureInPicture) return AvailabilityStates.UNAVAILABLE;\n      return void 0;\n    }\n  },\n  mediaVolumeUnavailable: {\n    get(stateOwners) {\n      const {\n        media\n      } = stateOwners;\n      if (volumeSupported === false || (media == null ? void 0 : media.volume) == void 0) {\n        return AvailabilityStates.UNSUPPORTED;\n      }\n      return void 0;\n    },\n    // NOTE: Slightly different impl here. Added generic support for\n    // \"stateOwnersUpdateHandlers\" since the original impl had to hack around\n    // race conditions. (CJP)\n    stateOwnersUpdateHandlers: [handler => {\n      if (volumeSupported == null) {\n        volumeSupportPromise.then(supported => handler(supported ? void 0 : AvailabilityStates.UNSUPPORTED));\n      }\n    }]\n  },\n  mediaCastUnavailable: {\n    // @ts-ignore\n    get(stateOwners, {\n      availability = \"not-available\"\n    } = {}) {\n      var _a;\n      const {\n        media\n      } = stateOwners;\n      if (!castSupported || !((_a = media == null ? void 0 : media.remote) == null ? void 0 : _a.state)) {\n        return AvailabilityStates.UNSUPPORTED;\n      }\n      if (availability == null || availability === \"available\") return void 0;\n      return AvailabilityStates.UNAVAILABLE;\n    },\n    stateOwnersUpdateHandlers: [(handler, stateOwners) => {\n      var _a;\n      const {\n        media\n      } = stateOwners;\n      if (!media) return;\n      const remotePlaybackDisabled = media.disableRemotePlayback || media.hasAttribute(\"disableremoteplayback\");\n      if (!remotePlaybackDisabled) {\n        (_a = media == null ? void 0 : media.remote) == null ? void 0 : _a.watchAvailability(availabilityBool => {\n          const availability = availabilityBool ? \"available\" : \"not-available\";\n          handler({\n            availability\n          });\n        }).catch(error => {\n          if (error.name === \"NotSupportedError\") {\n            handler({\n              availability: null\n            });\n          } else {\n            handler({\n              availability: \"not-available\"\n            });\n          }\n        });\n      }\n      return () => {\n        var _a2;\n        (_a2 = media == null ? void 0 : media.remote) == null ? void 0 : _a2.cancelWatchAvailability().catch(() => {});\n      };\n    }]\n  },\n  mediaAirplayUnavailable: {\n    get(_stateOwners, event) {\n      if (!airplaySupported) return AvailabilityStates.UNSUPPORTED;\n      if ((event == null ? void 0 : event.availability) === \"not-available\") {\n        return AvailabilityStates.UNAVAILABLE;\n      }\n      return void 0;\n    },\n    // NOTE: Keeping this event, as it's still the documented way of monitoring\n    // for AirPlay availability from Apple.\n    // See: https://developer.apple.com/documentation/webkitjs/adding_an_airplay_button_to_your_safari_media_controls#2940021 (CJP)\n    mediaEvents: [\"webkitplaybacktargetavailabilitychanged\"],\n    stateOwnersUpdateHandlers: [(handler, stateOwners) => {\n      var _a;\n      const {\n        media\n      } = stateOwners;\n      if (!media) return;\n      const remotePlaybackDisabled = media.disableRemotePlayback || media.hasAttribute(\"disableremoteplayback\");\n      if (!remotePlaybackDisabled) {\n        (_a = media == null ? void 0 : media.remote) == null ? void 0 : _a.watchAvailability(availabilityBool => {\n          const availability = availabilityBool ? \"available\" : \"not-available\";\n          handler({\n            availability\n          });\n        }).catch(error => {\n          if (error.name === \"NotSupportedError\") {\n            handler({\n              availability: null\n            });\n          } else {\n            handler({\n              availability: \"not-available\"\n            });\n          }\n        });\n      }\n      return () => {\n        var _a2;\n        (_a2 = media == null ? void 0 : media.remote) == null ? void 0 : _a2.cancelWatchAvailability().catch(() => {});\n      };\n    }]\n  },\n  mediaRenditionUnavailable: {\n    get(stateOwners) {\n      var _a;\n      const {\n        media\n      } = stateOwners;\n      if (!(media == null ? void 0 : media.videoRenditions)) {\n        return AvailabilityStates.UNSUPPORTED;\n      }\n      if (!((_a = media.videoRenditions) == null ? void 0 : _a.length)) {\n        return AvailabilityStates.UNAVAILABLE;\n      }\n      return void 0;\n    },\n    mediaEvents: [\"emptied\", \"loadstart\"],\n    videoRenditionsEvents: [\"addrendition\", \"removerendition\"]\n  },\n  mediaAudioTrackUnavailable: {\n    get(stateOwners) {\n      var _a, _b;\n      const {\n        media\n      } = stateOwners;\n      if (!(media == null ? void 0 : media.audioTracks)) {\n        return AvailabilityStates.UNSUPPORTED;\n      }\n      if (((_b = (_a = media.audioTracks) == null ? void 0 : _a.length) != null ? _b : 0) <= 1) {\n        return AvailabilityStates.UNAVAILABLE;\n      }\n      return void 0;\n    },\n    mediaEvents: [\"emptied\", \"loadstart\"],\n    audioTracksEvents: [\"addtrack\", \"removetrack\"]\n  },\n  mediaLang: {\n    get(stateOwners) {\n      const {\n        options: {\n          mediaLang\n        } = {}\n      } = stateOwners;\n      return mediaLang != null ? mediaLang : \"en\";\n    }\n  }\n};\nexport { prepareStateOwners, stateMediator, volumeSupportPromise };","map":{"version":3,"names":["document","globalThis","AvailabilityStates","StreamTypes","TextTrackKinds","containsComposedNode","enterFullscreen","exitFullscreen","isFullscreen","airplaySupported","castSupported","fullscreenSupported","hasFullscreenSupport","hasPipSupport","hasVolumeSupportAsync","pipSupported","getShowingSubtitleTracks","getSubtitleTracks","toggleSubtitleTracks","getTextTracksList","isValidNumber","StreamTypeValues","Object","values","volumeSupported","volumeSupportPromise","then","supported","prepareStateOwners","stateOwners","Promise","all","filter","x","map","stateOwner","HTMLElement","name","localName","includes","classDef","customElements","get","whenDefined","upgrade","domParser","DOMParser","parseHtmlToText","text","parseFromString","body","textContent","stateMediator","mediaError","event","media","type","error","mediaEvents","mediaErrorCode","_a","code","mediaErrorMessage","_b","message","mediaWidth","videoWidth","mediaHeight","videoHeight","mediaPaused","paused","set","value","pause","play","catch","mediaHasPlayed","mediaEnded","ended","mediaPlaybackRate","playbackRate","Number","isFinite","mediaMuted","muted","options","noMutedPref","hasLocalStoragePrefMuted","localStorage","getItem","hasMutedAttribute","hasAttribute","removeItem","setItem","e","console","debug","stateOwnersUpdateHandlers","handler","mutedPref","mediaLoop","loop","mediaVolume","volume","noVolumePref","toString","volumePref","mediaVolumeLevel","mediaCurrentTime","currentTime","mediaDuration","defaultDuration","duration","isNaN","NaN","mediaLoading","readyState","mediaSeekable","seekable","length","start","end","toFixed","mediaBuffered","timeRanges","buffered","Array","from","_","i","mediaStreamType","defaultStreamType","usedDefaultStreamType","LIVE","ON_DEMAND","streamType","UNKNOWN","Infinity","mediaTargetLiveWindow","targetLiveWindow","mediaTimeIsLive","liveEdgeOffset","liveEdgeStart","live","mediaSubtitlesList","kind","label","language","textTracksEvents","mediaSubtitlesShowing","_handler","updateDefaultSubtitlesCallback","_a2","defaultSubtitles","nonSubsEvent","CAPTIONS","SUBTITLES","track","addEventListener","textTracks","_b2","removeEventListener","mediaChaptersCues","chaptersTrack","CHAPTERS","cues","startTime","endTime","querySelector","shadowChaptersTrack","shadowRoot","mediaIsPip","documentElement","pictureInPictureElement","HTMLMediaElement","currentRoot","pictureInPictureEnabled","warn","requestPictureInPicture","warnNotReady","err","src","preload","cleanup","tryPip","setTimeout","exitPictureInPicture","mediaRenditionList","videoRenditions","videoRendition","videoRenditionsEvents","mediaRenditionSelected","_c","selectedIndex","id","renditionId","index","prototype","findIndex","call","r","mediaAudioTrackList","audioTracks","audioTracksEvents","mediaAudioTrackEnabled","find","audioTrack","enabled","audioTrackId","mediaIsFullscreen","isPointer","detail","focus","rootEvents","mediaIsCasting","remote","state","prompt","remoteEvents","mediaIsAirplaying","_value","webkitShowPlaybackTargetPicker","WebKitPlaybackTargetAvailabilityEvent","mediaFullscreenUnavailable","UNSUPPORTED","mediaPipUnavailable","disablePictureInPicture","UNAVAILABLE","mediaVolumeUnavailable","mediaCastUnavailable","availability","remotePlaybackDisabled","disableRemotePlayback","watchAvailability","availabilityBool","cancelWatchAvailability","mediaAirplayUnavailable","_stateOwners","mediaRenditionUnavailable","mediaAudioTrackUnavailable","mediaLang"],"sources":["/app/frontend/node_modules/media-chrome/dist/media-store/state-mediator.js"],"sourcesContent":["import { document, globalThis } from \"../utils/server-safe-globals.js\";\nimport {\n  AvailabilityStates,\n  StreamTypes,\n  TextTrackKinds\n} from \"../constants.js\";\nimport { containsComposedNode } from \"../utils/element-utils.js\";\nimport {\n  enterFullscreen,\n  exitFullscreen,\n  isFullscreen\n} from \"../utils/fullscreen-api.js\";\nimport {\n  airplaySupported,\n  castSupported,\n  fullscreenSupported,\n  hasFullscreenSupport,\n  hasPipSupport,\n  hasVolumeSupportAsync,\n  pipSupported\n} from \"../utils/platform-tests.js\";\nimport {\n  getShowingSubtitleTracks,\n  getSubtitleTracks,\n  toggleSubtitleTracks\n} from \"./util.js\";\nimport { getTextTracksList } from \"../utils/captions.js\";\nimport { isValidNumber } from \"../utils/utils.js\";\nconst StreamTypeValues = Object.values(StreamTypes);\nlet volumeSupported;\nconst volumeSupportPromise = hasVolumeSupportAsync().then((supported) => {\n  volumeSupported = supported;\n  return volumeSupported;\n});\nconst prepareStateOwners = async (...stateOwners) => {\n  await Promise.all(\n    stateOwners.filter((x) => x).map(async (stateOwner) => {\n      if (!(\"localName\" in stateOwner && stateOwner instanceof globalThis.HTMLElement)) {\n        return;\n      }\n      const name = stateOwner.localName;\n      if (!name.includes(\"-\"))\n        return;\n      const classDef = globalThis.customElements.get(name);\n      if (classDef && stateOwner instanceof classDef)\n        return;\n      await globalThis.customElements.whenDefined(name);\n      globalThis.customElements.upgrade(stateOwner);\n    })\n  );\n};\nconst domParser = new globalThis.DOMParser();\nconst parseHtmlToText = (text) => text ? domParser.parseFromString(text, \"text/html\").body.textContent || text : text;\nconst stateMediator = {\n  mediaError: {\n    get(stateOwners, event) {\n      const { media } = stateOwners;\n      if ((event == null ? void 0 : event.type) === \"playing\")\n        return;\n      return media == null ? void 0 : media.error;\n    },\n    mediaEvents: [\"emptied\", \"error\", \"playing\"]\n  },\n  mediaErrorCode: {\n    get(stateOwners, event) {\n      var _a;\n      const { media } = stateOwners;\n      if ((event == null ? void 0 : event.type) === \"playing\")\n        return;\n      return (_a = media == null ? void 0 : media.error) == null ? void 0 : _a.code;\n    },\n    mediaEvents: [\"emptied\", \"error\", \"playing\"]\n  },\n  mediaErrorMessage: {\n    get(stateOwners, event) {\n      var _a, _b;\n      const { media } = stateOwners;\n      if ((event == null ? void 0 : event.type) === \"playing\")\n        return;\n      return (_b = (_a = media == null ? void 0 : media.error) == null ? void 0 : _a.message) != null ? _b : \"\";\n    },\n    mediaEvents: [\"emptied\", \"error\", \"playing\"]\n  },\n  mediaWidth: {\n    get(stateOwners) {\n      var _a;\n      const { media } = stateOwners;\n      return (_a = media == null ? void 0 : media.videoWidth) != null ? _a : 0;\n    },\n    mediaEvents: [\"resize\"]\n  },\n  mediaHeight: {\n    get(stateOwners) {\n      var _a;\n      const { media } = stateOwners;\n      return (_a = media == null ? void 0 : media.videoHeight) != null ? _a : 0;\n    },\n    mediaEvents: [\"resize\"]\n  },\n  mediaPaused: {\n    get(stateOwners) {\n      var _a;\n      const { media } = stateOwners;\n      return (_a = media == null ? void 0 : media.paused) != null ? _a : true;\n    },\n    set(value, stateOwners) {\n      var _a;\n      const { media } = stateOwners;\n      if (!media)\n        return;\n      if (value) {\n        media.pause();\n      } else {\n        (_a = media.play()) == null ? void 0 : _a.catch(() => {\n        });\n      }\n    },\n    mediaEvents: [\"play\", \"playing\", \"pause\", \"emptied\"]\n  },\n  mediaHasPlayed: {\n    // We want to let the user know that the media started playing at any point (`media-has-played`).\n    // Since these propagators are all called when boostrapping state, let's verify this is\n    // a real playing event by checking that 1) there's media and 2) it isn't currently paused.\n    get(stateOwners, event) {\n      const { media } = stateOwners;\n      if (!media)\n        return false;\n      if (!event)\n        return !media.paused;\n      return event.type === \"playing\";\n    },\n    mediaEvents: [\"playing\", \"emptied\"]\n  },\n  mediaEnded: {\n    get(stateOwners) {\n      var _a;\n      const { media } = stateOwners;\n      return (_a = media == null ? void 0 : media.ended) != null ? _a : false;\n    },\n    mediaEvents: [\"seeked\", \"ended\", \"emptied\"]\n  },\n  mediaPlaybackRate: {\n    get(stateOwners) {\n      var _a;\n      const { media } = stateOwners;\n      return (_a = media == null ? void 0 : media.playbackRate) != null ? _a : 1;\n    },\n    set(value, stateOwners) {\n      const { media } = stateOwners;\n      if (!media)\n        return;\n      if (!Number.isFinite(+value))\n        return;\n      media.playbackRate = +value;\n    },\n    mediaEvents: [\"ratechange\", \"loadstart\"]\n  },\n  mediaMuted: {\n    get(stateOwners) {\n      var _a;\n      const { media } = stateOwners;\n      return (_a = media == null ? void 0 : media.muted) != null ? _a : false;\n    },\n    set(value, stateOwners) {\n      const { media, options: { noMutedPref } = {} } = stateOwners;\n      if (!media)\n        return;\n      media.muted = value;\n      try {\n        const hasLocalStoragePrefMuted = globalThis.localStorage.getItem(\"media-chrome-pref-muted\") !== null;\n        const hasMutedAttribute = media.hasAttribute(\"muted\");\n        if (noMutedPref) {\n          if (hasLocalStoragePrefMuted)\n            globalThis.localStorage.removeItem(\"media-chrome-pref-muted\");\n          return;\n        }\n        if (hasMutedAttribute && !hasLocalStoragePrefMuted) {\n          return;\n        }\n        globalThis.localStorage.setItem(\n          \"media-chrome-pref-muted\",\n          value ? \"true\" : \"false\"\n        );\n      } catch (e) {\n        console.debug(\"Error setting muted pref\", e);\n      }\n    },\n    mediaEvents: [\"volumechange\"],\n    stateOwnersUpdateHandlers: [\n      (handler, stateOwners) => {\n        const {\n          options: { noMutedPref }\n        } = stateOwners;\n        const { media } = stateOwners;\n        if (!media || media.muted || noMutedPref)\n          return;\n        try {\n          const mutedPref = globalThis.localStorage.getItem(\"media-chrome-pref-muted\") === \"true\";\n          stateMediator.mediaMuted.set(mutedPref, stateOwners);\n          handler(mutedPref);\n        } catch (e) {\n          console.debug(\"Error getting muted pref\", e);\n        }\n      }\n    ]\n  },\n  mediaLoop: {\n    get(stateOwners) {\n      const { media } = stateOwners;\n      return media == null ? void 0 : media.loop;\n    },\n    set(value, stateOwners) {\n      const { media } = stateOwners;\n      if (!media)\n        return;\n      media.loop = value;\n    },\n    mediaEvents: [\"medialooprequest\"]\n  },\n  mediaVolume: {\n    get(stateOwners) {\n      var _a;\n      const { media } = stateOwners;\n      return (_a = media == null ? void 0 : media.volume) != null ? _a : 1;\n    },\n    set(value, stateOwners) {\n      const { media, options: { noVolumePref } = {} } = stateOwners;\n      if (!media)\n        return;\n      try {\n        if (value == null) {\n          globalThis.localStorage.removeItem(\"media-chrome-pref-volume\");\n        } else if (!media.hasAttribute(\"muted\") && !noVolumePref) {\n          globalThis.localStorage.setItem(\n            \"media-chrome-pref-volume\",\n            value.toString()\n          );\n        }\n      } catch (e) {\n        console.debug(\"Error setting volume pref\", e);\n      }\n      if (!Number.isFinite(+value))\n        return;\n      media.volume = +value;\n    },\n    mediaEvents: [\"volumechange\"],\n    stateOwnersUpdateHandlers: [\n      (handler, stateOwners) => {\n        const {\n          options: { noVolumePref }\n        } = stateOwners;\n        if (noVolumePref)\n          return;\n        try {\n          const { media } = stateOwners;\n          if (!media)\n            return;\n          const volumePref = globalThis.localStorage.getItem(\n            \"media-chrome-pref-volume\"\n          );\n          if (volumePref == null)\n            return;\n          stateMediator.mediaVolume.set(+volumePref, stateOwners);\n          handler(+volumePref);\n        } catch (e) {\n          console.debug(\"Error getting volume pref\", e);\n        }\n      }\n    ]\n  },\n  // NOTE: Keeping this roughly equivalent to prior impl to reduce number of changes,\n  // however we may want to model \"derived\" state differently from \"primary\" state\n  // (in this case, derived === mediaVolumeLevel, primary === mediaMuted, mediaVolume) (CJP)\n  mediaVolumeLevel: {\n    get(stateOwners) {\n      const { media } = stateOwners;\n      if (typeof (media == null ? void 0 : media.volume) == \"undefined\")\n        return \"high\";\n      if (media.muted || media.volume === 0)\n        return \"off\";\n      if (media.volume < 0.5)\n        return \"low\";\n      if (media.volume < 0.75)\n        return \"medium\";\n      return \"high\";\n    },\n    mediaEvents: [\"volumechange\"]\n  },\n  mediaCurrentTime: {\n    get(stateOwners) {\n      var _a;\n      const { media } = stateOwners;\n      return (_a = media == null ? void 0 : media.currentTime) != null ? _a : 0;\n    },\n    set(value, stateOwners) {\n      const { media } = stateOwners;\n      if (!media || !isValidNumber(value))\n        return;\n      media.currentTime = value;\n    },\n    mediaEvents: [\"timeupdate\", \"loadedmetadata\"]\n  },\n  mediaDuration: {\n    get(stateOwners) {\n      const { media, options: { defaultDuration } = {} } = stateOwners;\n      if (defaultDuration && (!media || !media.duration || Number.isNaN(media.duration) || !Number.isFinite(media.duration))) {\n        return defaultDuration;\n      }\n      return Number.isFinite(media == null ? void 0 : media.duration) ? media.duration : Number.NaN;\n    },\n    mediaEvents: [\"durationchange\", \"loadedmetadata\", \"emptied\"]\n  },\n  mediaLoading: {\n    get(stateOwners) {\n      const { media } = stateOwners;\n      return (media == null ? void 0 : media.readyState) < 3;\n    },\n    mediaEvents: [\"waiting\", \"playing\", \"emptied\"]\n  },\n  mediaSeekable: {\n    get(stateOwners) {\n      var _a;\n      const { media } = stateOwners;\n      if (!((_a = media == null ? void 0 : media.seekable) == null ? void 0 : _a.length))\n        return void 0;\n      const start = media.seekable.start(0);\n      const end = media.seekable.end(media.seekable.length - 1);\n      if (!start && !end)\n        return void 0;\n      return [Number(start.toFixed(3)), Number(end.toFixed(3))];\n    },\n    mediaEvents: [\"loadedmetadata\", \"emptied\", \"progress\", \"seekablechange\"]\n  },\n  mediaBuffered: {\n    get(stateOwners) {\n      var _a;\n      const { media } = stateOwners;\n      const timeRanges = (_a = media == null ? void 0 : media.buffered) != null ? _a : [];\n      return Array.from(timeRanges).map((_, i) => [\n        Number(timeRanges.start(i).toFixed(3)),\n        Number(timeRanges.end(i).toFixed(3))\n      ]);\n    },\n    mediaEvents: [\"progress\", \"emptied\"]\n  },\n  mediaStreamType: {\n    get(stateOwners) {\n      const { media, options: { defaultStreamType } = {} } = stateOwners;\n      const usedDefaultStreamType = [\n        StreamTypes.LIVE,\n        StreamTypes.ON_DEMAND\n      ].includes(defaultStreamType) ? defaultStreamType : void 0;\n      if (!media)\n        return usedDefaultStreamType;\n      const { streamType } = media;\n      if (StreamTypeValues.includes(streamType)) {\n        if (streamType === StreamTypes.UNKNOWN) {\n          return usedDefaultStreamType;\n        }\n        return streamType;\n      }\n      const duration = media.duration;\n      if (duration === Infinity) {\n        return StreamTypes.LIVE;\n      } else if (Number.isFinite(duration)) {\n        return StreamTypes.ON_DEMAND;\n      }\n      return usedDefaultStreamType;\n    },\n    mediaEvents: [\n      \"emptied\",\n      \"durationchange\",\n      \"loadedmetadata\",\n      \"streamtypechange\"\n    ]\n  },\n  mediaTargetLiveWindow: {\n    get(stateOwners) {\n      const { media } = stateOwners;\n      if (!media)\n        return Number.NaN;\n      const { targetLiveWindow } = media;\n      const streamType = stateMediator.mediaStreamType.get(stateOwners);\n      if ((targetLiveWindow == null || Number.isNaN(targetLiveWindow)) && streamType === StreamTypes.LIVE) {\n        return 0;\n      }\n      return targetLiveWindow;\n    },\n    mediaEvents: [\n      \"emptied\",\n      \"durationchange\",\n      \"loadedmetadata\",\n      \"streamtypechange\",\n      \"targetlivewindowchange\"\n    ]\n  },\n  mediaTimeIsLive: {\n    get(stateOwners) {\n      const {\n        media,\n        // Default to 10 seconds\n        options: { liveEdgeOffset = 10 } = {}\n      } = stateOwners;\n      if (!media)\n        return false;\n      if (typeof media.liveEdgeStart === \"number\") {\n        if (Number.isNaN(media.liveEdgeStart))\n          return false;\n        return media.currentTime >= media.liveEdgeStart;\n      }\n      const live = stateMediator.mediaStreamType.get(stateOwners) === StreamTypes.LIVE;\n      if (!live)\n        return false;\n      const seekable = media.seekable;\n      if (!seekable)\n        return true;\n      if (!seekable.length)\n        return false;\n      const liveEdgeStart = seekable.end(seekable.length - 1) - liveEdgeOffset;\n      return media.currentTime >= liveEdgeStart;\n    },\n    mediaEvents: [\"playing\", \"timeupdate\", \"progress\", \"waiting\", \"emptied\"]\n  },\n  // Text Tracks modeling\n  mediaSubtitlesList: {\n    get(stateOwners) {\n      return getSubtitleTracks(stateOwners).map(\n        ({ kind, label, language }) => ({ kind, label, language })\n      );\n    },\n    mediaEvents: [\"loadstart\"],\n    textTracksEvents: [\"addtrack\", \"removetrack\"]\n  },\n  mediaSubtitlesShowing: {\n    get(stateOwners) {\n      return getShowingSubtitleTracks(stateOwners).map(\n        ({ kind, label, language }) => ({ kind, label, language })\n      );\n    },\n    mediaEvents: [\"loadstart\"],\n    textTracksEvents: [\"addtrack\", \"removetrack\", \"change\"],\n    stateOwnersUpdateHandlers: [\n      (_handler, stateOwners) => {\n        var _a, _b;\n        const { media, options } = stateOwners;\n        if (!media)\n          return;\n        const updateDefaultSubtitlesCallback = (event) => {\n          var _a2;\n          if (!options.defaultSubtitles)\n            return;\n          const nonSubsEvent = event && ![TextTrackKinds.CAPTIONS, TextTrackKinds.SUBTITLES].includes(\n            // @ts-ignore\n            (_a2 = event == null ? void 0 : event.track) == null ? void 0 : _a2.kind\n          );\n          if (nonSubsEvent)\n            return;\n          toggleSubtitleTracks(stateOwners, true);\n        };\n        media.addEventListener(\n          \"loadstart\",\n          updateDefaultSubtitlesCallback\n        );\n        (_a = media.textTracks) == null ? void 0 : _a.addEventListener(\n          \"addtrack\",\n          updateDefaultSubtitlesCallback\n        );\n        (_b = media.textTracks) == null ? void 0 : _b.addEventListener(\n          \"removetrack\",\n          updateDefaultSubtitlesCallback\n        );\n        return () => {\n          var _a2, _b2;\n          media.removeEventListener(\n            \"loadstart\",\n            updateDefaultSubtitlesCallback\n          );\n          (_a2 = media.textTracks) == null ? void 0 : _a2.removeEventListener(\n            \"addtrack\",\n            updateDefaultSubtitlesCallback\n          );\n          (_b2 = media.textTracks) == null ? void 0 : _b2.removeEventListener(\n            \"removetrack\",\n            updateDefaultSubtitlesCallback\n          );\n        };\n      }\n    ]\n  },\n  mediaChaptersCues: {\n    get(stateOwners) {\n      var _a;\n      const { media } = stateOwners;\n      if (!media)\n        return [];\n      const [chaptersTrack] = getTextTracksList(media, {\n        kind: TextTrackKinds.CHAPTERS\n      });\n      return Array.from((_a = chaptersTrack == null ? void 0 : chaptersTrack.cues) != null ? _a : []).map(\n        ({ text, startTime, endTime }) => ({\n          text: parseHtmlToText(text),\n          startTime,\n          endTime\n        })\n      );\n    },\n    mediaEvents: [\"loadstart\", \"loadedmetadata\"],\n    textTracksEvents: [\"addtrack\", \"removetrack\", \"change\"],\n    stateOwnersUpdateHandlers: [\n      (handler, stateOwners) => {\n        var _a;\n        const { media } = stateOwners;\n        if (!media)\n          return;\n        const chaptersTrack = media.querySelector(\n          'track[kind=\"chapters\"][default][src]'\n        );\n        const shadowChaptersTrack = (_a = media.shadowRoot) == null ? void 0 : _a.querySelector(\n          ':is(video,audio) > track[kind=\"chapters\"][default][src]'\n        );\n        chaptersTrack == null ? void 0 : chaptersTrack.addEventListener(\"load\", handler);\n        shadowChaptersTrack == null ? void 0 : shadowChaptersTrack.addEventListener(\"load\", handler);\n        return () => {\n          chaptersTrack == null ? void 0 : chaptersTrack.removeEventListener(\"load\", handler);\n          shadowChaptersTrack == null ? void 0 : shadowChaptersTrack.removeEventListener(\"load\", handler);\n        };\n      }\n    ]\n  },\n  // Modeling state tied to root node\n  mediaIsPip: {\n    get(stateOwners) {\n      var _a, _b;\n      const { media, documentElement } = stateOwners;\n      if (!media || !documentElement)\n        return false;\n      if (!documentElement.pictureInPictureElement)\n        return false;\n      if (documentElement.pictureInPictureElement === media)\n        return true;\n      if (documentElement.pictureInPictureElement instanceof HTMLMediaElement) {\n        if (!((_a = media.localName) == null ? void 0 : _a.includes(\"-\")))\n          return false;\n        return containsComposedNode(\n          media,\n          documentElement.pictureInPictureElement\n        );\n      }\n      if (documentElement.pictureInPictureElement.localName.includes(\"-\")) {\n        let currentRoot = documentElement.pictureInPictureElement.shadowRoot;\n        while (currentRoot == null ? void 0 : currentRoot.pictureInPictureElement) {\n          if (currentRoot.pictureInPictureElement === media)\n            return true;\n          currentRoot = (_b = currentRoot.pictureInPictureElement) == null ? void 0 : _b.shadowRoot;\n        }\n      }\n      return false;\n    },\n    set(value, stateOwners) {\n      const { media } = stateOwners;\n      if (!media)\n        return;\n      if (value) {\n        if (!document.pictureInPictureEnabled) {\n          console.warn(\"MediaChrome: Picture-in-picture is not enabled\");\n          return;\n        }\n        if (!media.requestPictureInPicture) {\n          console.warn(\n            \"MediaChrome: The current media does not support picture-in-picture\"\n          );\n          return;\n        }\n        const warnNotReady = () => {\n          console.warn(\n            \"MediaChrome: The media is not ready for picture-in-picture. It must have a readyState > 0.\"\n          );\n        };\n        media.requestPictureInPicture().catch((err) => {\n          if (err.code === 11) {\n            if (!media.src) {\n              console.warn(\n                \"MediaChrome: The media is not ready for picture-in-picture. It must have a src set.\"\n              );\n              return;\n            }\n            if (media.readyState === 0 && media.preload === \"none\") {\n              const cleanup = () => {\n                media.removeEventListener(\"loadedmetadata\", tryPip);\n                media.preload = \"none\";\n              };\n              const tryPip = () => {\n                media.requestPictureInPicture().catch(warnNotReady);\n                cleanup();\n              };\n              media.addEventListener(\"loadedmetadata\", tryPip);\n              media.preload = \"metadata\";\n              setTimeout(() => {\n                if (media.readyState === 0)\n                  warnNotReady();\n                cleanup();\n              }, 1e3);\n            } else {\n              throw err;\n            }\n          } else {\n            throw err;\n          }\n        });\n      } else if (document.pictureInPictureElement) {\n        document.exitPictureInPicture();\n      }\n    },\n    mediaEvents: [\"enterpictureinpicture\", \"leavepictureinpicture\"]\n  },\n  mediaRenditionList: {\n    get(stateOwners) {\n      var _a;\n      const { media } = stateOwners;\n      return [...(_a = media == null ? void 0 : media.videoRenditions) != null ? _a : []].map((videoRendition) => ({\n        ...videoRendition\n      }));\n    },\n    mediaEvents: [\"emptied\", \"loadstart\"],\n    videoRenditionsEvents: [\"addrendition\", \"removerendition\"]\n  },\n  /** @TODO Model this as a derived value? (CJP) */\n  mediaRenditionSelected: {\n    get(stateOwners) {\n      var _a, _b, _c;\n      const { media } = stateOwners;\n      return (_c = (_b = media == null ? void 0 : media.videoRenditions) == null ? void 0 : _b[(_a = media.videoRenditions) == null ? void 0 : _a.selectedIndex]) == null ? void 0 : _c.id;\n    },\n    set(value, stateOwners) {\n      const { media } = stateOwners;\n      if (!(media == null ? void 0 : media.videoRenditions)) {\n        console.warn(\n          \"MediaController: Rendition selection not supported by this media.\"\n        );\n        return;\n      }\n      const renditionId = value;\n      const index = Array.prototype.findIndex.call(\n        media.videoRenditions,\n        (r) => r.id == renditionId\n      );\n      if (media.videoRenditions.selectedIndex != index) {\n        media.videoRenditions.selectedIndex = index;\n      }\n    },\n    mediaEvents: [\"emptied\"],\n    videoRenditionsEvents: [\"addrendition\", \"removerendition\", \"change\"]\n  },\n  mediaAudioTrackList: {\n    get(stateOwners) {\n      var _a;\n      const { media } = stateOwners;\n      return [...(_a = media == null ? void 0 : media.audioTracks) != null ? _a : []];\n    },\n    mediaEvents: [\"emptied\", \"loadstart\"],\n    audioTracksEvents: [\"addtrack\", \"removetrack\"]\n  },\n  mediaAudioTrackEnabled: {\n    get(stateOwners) {\n      var _a, _b;\n      const { media } = stateOwners;\n      return (_b = [...(_a = media == null ? void 0 : media.audioTracks) != null ? _a : []].find(\n        (audioTrack) => audioTrack.enabled\n      )) == null ? void 0 : _b.id;\n    },\n    set(value, stateOwners) {\n      const { media } = stateOwners;\n      if (!(media == null ? void 0 : media.audioTracks)) {\n        console.warn(\n          \"MediaChrome: Audio track selection not supported by this media.\"\n        );\n        return;\n      }\n      const audioTrackId = value;\n      for (const track of media.audioTracks) {\n        track.enabled = audioTrackId == track.id;\n      }\n    },\n    mediaEvents: [\"emptied\"],\n    audioTracksEvents: [\"addtrack\", \"removetrack\", \"change\"]\n  },\n  mediaIsFullscreen: {\n    get(stateOwners) {\n      return isFullscreen(stateOwners);\n    },\n    set(value, stateOwners, event) {\n      var _a;\n      if (!value) {\n        exitFullscreen(stateOwners);\n      } else {\n        enterFullscreen(stateOwners);\n        const isPointer = event.detail;\n        if (isPointer)\n          (_a = stateOwners.media) == null ? void 0 : _a.focus();\n      }\n    },\n    // older Safari version may require webkit-specific events\n    rootEvents: [\"fullscreenchange\", \"webkitfullscreenchange\"],\n    // iOS requires webkit-specific events on the video.\n    mediaEvents: [\n      \"webkitbeginfullscreen\",\n      \"webkitendfullscreen\",\n      \"webkitpresentationmodechanged\"\n    ]\n  },\n  mediaIsCasting: {\n    // Note this relies on a customized castable-video element.\n    get(stateOwners) {\n      var _a;\n      const { media } = stateOwners;\n      if (!(media == null ? void 0 : media.remote) || ((_a = media.remote) == null ? void 0 : _a.state) === \"disconnected\")\n        return false;\n      return !!media.remote.state;\n    },\n    set(value, stateOwners) {\n      var _a, _b;\n      const { media } = stateOwners;\n      if (!media)\n        return;\n      if (value && ((_a = media.remote) == null ? void 0 : _a.state) !== \"disconnected\")\n        return;\n      if (!value && ((_b = media.remote) == null ? void 0 : _b.state) !== \"connected\")\n        return;\n      if (typeof media.remote.prompt !== \"function\") {\n        console.warn(\n          \"MediaChrome: Casting is not supported in this environment\"\n        );\n        return;\n      }\n      media.remote.prompt().catch(() => {\n      });\n    },\n    remoteEvents: [\"connect\", \"connecting\", \"disconnect\"]\n  },\n  // NOTE: Newly added state for tracking airplaying\n  mediaIsAirplaying: {\n    // NOTE: Cannot know if airplaying since Safari doesn't fully support HTMLMediaElement::remote yet (e.g. remote::state) (CJP)\n    get() {\n      return false;\n    },\n    set(_value, stateOwners) {\n      const { media } = stateOwners;\n      if (!media)\n        return;\n      if (!(media.webkitShowPlaybackTargetPicker && globalThis.WebKitPlaybackTargetAvailabilityEvent)) {\n        console.error(\n          \"MediaChrome: received a request to select AirPlay but AirPlay is not supported in this environment\"\n        );\n        return;\n      }\n      media.webkitShowPlaybackTargetPicker();\n    },\n    mediaEvents: [\"webkitcurrentplaybacktargetiswirelesschanged\"]\n  },\n  mediaFullscreenUnavailable: {\n    get(stateOwners) {\n      const { media } = stateOwners;\n      if (!fullscreenSupported || !hasFullscreenSupport(media))\n        return AvailabilityStates.UNSUPPORTED;\n      return void 0;\n    }\n  },\n  mediaPipUnavailable: {\n    get(stateOwners) {\n      const { media } = stateOwners;\n      if (!pipSupported || !hasPipSupport(media))\n        return AvailabilityStates.UNSUPPORTED;\n      else if (media == null ? void 0 : media.disablePictureInPicture)\n        return AvailabilityStates.UNAVAILABLE;\n      return void 0;\n    }\n  },\n  mediaVolumeUnavailable: {\n    get(stateOwners) {\n      const { media } = stateOwners;\n      if (volumeSupported === false || (media == null ? void 0 : media.volume) == void 0) {\n        return AvailabilityStates.UNSUPPORTED;\n      }\n      return void 0;\n    },\n    // NOTE: Slightly different impl here. Added generic support for\n    // \"stateOwnersUpdateHandlers\" since the original impl had to hack around\n    // race conditions. (CJP)\n    stateOwnersUpdateHandlers: [\n      (handler) => {\n        if (volumeSupported == null) {\n          volumeSupportPromise.then(\n            (supported) => handler(supported ? void 0 : AvailabilityStates.UNSUPPORTED)\n          );\n        }\n      }\n    ]\n  },\n  mediaCastUnavailable: {\n    // @ts-ignore\n    get(stateOwners, { availability = \"not-available\" } = {}) {\n      var _a;\n      const { media } = stateOwners;\n      if (!castSupported || !((_a = media == null ? void 0 : media.remote) == null ? void 0 : _a.state)) {\n        return AvailabilityStates.UNSUPPORTED;\n      }\n      if (availability == null || availability === \"available\")\n        return void 0;\n      return AvailabilityStates.UNAVAILABLE;\n    },\n    stateOwnersUpdateHandlers: [\n      (handler, stateOwners) => {\n        var _a;\n        const { media } = stateOwners;\n        if (!media)\n          return;\n        const remotePlaybackDisabled = media.disableRemotePlayback || media.hasAttribute(\"disableremoteplayback\");\n        if (!remotePlaybackDisabled) {\n          (_a = media == null ? void 0 : media.remote) == null ? void 0 : _a.watchAvailability((availabilityBool) => {\n            const availability = availabilityBool ? \"available\" : \"not-available\";\n            handler({ availability });\n          }).catch((error) => {\n            if (error.name === \"NotSupportedError\") {\n              handler({ availability: null });\n            } else {\n              handler({ availability: \"not-available\" });\n            }\n          });\n        }\n        return () => {\n          var _a2;\n          (_a2 = media == null ? void 0 : media.remote) == null ? void 0 : _a2.cancelWatchAvailability().catch(() => {\n          });\n        };\n      }\n    ]\n  },\n  mediaAirplayUnavailable: {\n    get(_stateOwners, event) {\n      if (!airplaySupported)\n        return AvailabilityStates.UNSUPPORTED;\n      if ((event == null ? void 0 : event.availability) === \"not-available\") {\n        return AvailabilityStates.UNAVAILABLE;\n      }\n      return void 0;\n    },\n    // NOTE: Keeping this event, as it's still the documented way of monitoring\n    // for AirPlay availability from Apple.\n    // See: https://developer.apple.com/documentation/webkitjs/adding_an_airplay_button_to_your_safari_media_controls#2940021 (CJP)\n    mediaEvents: [\"webkitplaybacktargetavailabilitychanged\"],\n    stateOwnersUpdateHandlers: [\n      (handler, stateOwners) => {\n        var _a;\n        const { media } = stateOwners;\n        if (!media)\n          return;\n        const remotePlaybackDisabled = media.disableRemotePlayback || media.hasAttribute(\"disableremoteplayback\");\n        if (!remotePlaybackDisabled) {\n          (_a = media == null ? void 0 : media.remote) == null ? void 0 : _a.watchAvailability((availabilityBool) => {\n            const availability = availabilityBool ? \"available\" : \"not-available\";\n            handler({ availability });\n          }).catch((error) => {\n            if (error.name === \"NotSupportedError\") {\n              handler({ availability: null });\n            } else {\n              handler({ availability: \"not-available\" });\n            }\n          });\n        }\n        return () => {\n          var _a2;\n          (_a2 = media == null ? void 0 : media.remote) == null ? void 0 : _a2.cancelWatchAvailability().catch(() => {\n          });\n        };\n      }\n    ]\n  },\n  mediaRenditionUnavailable: {\n    get(stateOwners) {\n      var _a;\n      const { media } = stateOwners;\n      if (!(media == null ? void 0 : media.videoRenditions)) {\n        return AvailabilityStates.UNSUPPORTED;\n      }\n      if (!((_a = media.videoRenditions) == null ? void 0 : _a.length)) {\n        return AvailabilityStates.UNAVAILABLE;\n      }\n      return void 0;\n    },\n    mediaEvents: [\"emptied\", \"loadstart\"],\n    videoRenditionsEvents: [\"addrendition\", \"removerendition\"]\n  },\n  mediaAudioTrackUnavailable: {\n    get(stateOwners) {\n      var _a, _b;\n      const { media } = stateOwners;\n      if (!(media == null ? void 0 : media.audioTracks)) {\n        return AvailabilityStates.UNSUPPORTED;\n      }\n      if (((_b = (_a = media.audioTracks) == null ? void 0 : _a.length) != null ? _b : 0) <= 1) {\n        return AvailabilityStates.UNAVAILABLE;\n      }\n      return void 0;\n    },\n    mediaEvents: [\"emptied\", \"loadstart\"],\n    audioTracksEvents: [\"addtrack\", \"removetrack\"]\n  },\n  mediaLang: {\n    get(stateOwners) {\n      const { options: { mediaLang } = {} } = stateOwners;\n      return mediaLang != null ? mediaLang : \"en\";\n    }\n  }\n};\nexport {\n  prepareStateOwners,\n  stateMediator,\n  volumeSupportPromise\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}