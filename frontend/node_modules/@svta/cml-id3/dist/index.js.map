{"version":3,"file":"index.js","names":["view","bytesPerElement: any","view","metadataFrame: MetadataFrame","description: string","value: string","url: string","type: string","size: number","frames: Id3Frame[]","frameData: RawId3Frame","frame: Id3Frame | undefined","frames: Id3Frame[]"],"sources":["../src/util/isId3Header.ts","../src/util/readId3Size.ts","../src/canParseId3.ts","../src/util/isId3Footer.ts","../src/getId3Data.ts","../src/util/toArrayBuffer.ts","../src/util/utf8.ts","../src/util/utf8ArrayToStr.ts","../src/util/decodeId3ImageFrame.ts","../src/util/decodeId3PrivFrame.ts","../src/util/decodeId3TextFrame.ts","../src/util/decodeId3UrlFrame.ts","../src/util/decodeId3Frame.ts","../src/util/getId3FrameData.ts","../src/getId3Frames.ts","../src/isId3TimestampFrame.ts","../src/util/readId3Timestamp.ts","../src/getId3Timestamp.ts","../src/ID3_SCHEME_ID_URI.ts"],"sourcesContent":["/**\n * Returns true if an ID3 header can be found at offset in data\n *\n * @param data - The data to search in\n * @param offset - The offset at which to start searching\n *\n * @returns `true` if an ID3 header is found\n *\n * @internal\n *\n */\nexport function isId3Header(data: Uint8Array, offset: number): boolean {\n\t/*\n\t * http://id3.org/id3v2.3.0\n\t * [0]     = 'I'\n\t * [1]     = 'D'\n\t * [2]     = '3'\n\t * [3,4]   = {Version}\n\t * [5]     = {Flags}\n\t * [6-9]   = {ID3 Size}\n\t *\n\t * An ID3v2 tag can be detected with the following pattern:\n\t *  $49 44 33 yy yy xx zz zz zz zz\n\t * Where yy is less than $FF, xx is the 'flags' byte and zz is less than $80\n\t */\n\tif (offset + 10 <= data.length) {\n\t\t// look for 'ID3' identifier\n\t\tif (\n\t\t\tdata[offset] === 0x49 &&\n\t\t\tdata[offset + 1] === 0x44 &&\n\t\t\tdata[offset + 2] === 0x33\n\t\t) {\n\t\t\t// check version is within range\n\t\t\tif (data[offset + 3] < 0xff && data[offset + 4] < 0xff) {\n\t\t\t\t// check size is within range\n\t\t\t\tif (\n\t\t\t\t\tdata[offset + 6] < 0x80 &&\n\t\t\t\t\tdata[offset + 7] < 0x80 &&\n\t\t\t\t\tdata[offset + 8] < 0x80 &&\n\t\t\t\t\tdata[offset + 9] < 0x80\n\t\t\t\t) {\n\t\t\t\t\treturn true\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn false\n}\n","/**\n * Read ID3 size\n *\n * @param data - The data to read from\n * @param offset - The offset at which to start reading\n *\n * @returns The size\n *\n * @internal\n *\n */\nexport function readId3Size(data: Uint8Array, offset: number): number {\n\tlet size = 0\n\tsize = (data[offset] & 0x7f) << 21\n\tsize |= (data[offset + 1] & 0x7f) << 14\n\tsize |= (data[offset + 2] & 0x7f) << 7\n\tsize |= data[offset + 3] & 0x7f\n\treturn size\n}\n","import { isId3Header } from './util/isId3Header.ts'\nimport { readId3Size } from './util/readId3Size.ts'\n\n/**\n * Checks if the given data contains an ID3 tag.\n *\n * @param data - The data to check\n * @param offset - The offset at which to start checking\n *\n * @returns `true` if an ID3 tag is found\n *\n *\n * @beta\n */\nexport function canParseId3(data: Uint8Array, offset: number): boolean {\n\treturn (\n\t\tisId3Header(data, offset) &&\n\t\treadId3Size(data, offset + 6) + 10 <= data.length - offset\n\t)\n}\n","/**\n * Returns true if an ID3 footer can be found at offset in data\n *\n * @param data - The data to search in\n * @param offset - The offset at which to start searching\n *\n * @returns `true` if an ID3 footer is found\n *\n * @internal\n *\n */\nexport function isId3Footer(data: Uint8Array, offset: number): boolean {\n\t/*\n\t * The footer is a copy of the header, but with a different identifier\n\t */\n\tif (offset + 10 <= data.length) {\n\t\t// look for '3DI' identifier\n\t\tif (\n\t\t\tdata[offset] === 0x33 &&\n\t\t\tdata[offset + 1] === 0x44 &&\n\t\t\tdata[offset + 2] === 0x49\n\t\t) {\n\t\t\t// check version is within range\n\t\t\tif (data[offset + 3] < 0xff && data[offset + 4] < 0xff) {\n\t\t\t\t// check size is within range\n\t\t\t\tif (\n\t\t\t\t\tdata[offset + 6] < 0x80 &&\n\t\t\t\t\tdata[offset + 7] < 0x80 &&\n\t\t\t\t\tdata[offset + 8] < 0x80 &&\n\t\t\t\t\tdata[offset + 9] < 0x80\n\t\t\t\t) {\n\t\t\t\t\treturn true\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false\n}\n","import { isId3Footer } from './util/isId3Footer.ts'\nimport { isId3Header } from './util/isId3Header.ts'\nimport { readId3Size } from './util/readId3Size.ts'\n\n/**\n * Returns any adjacent ID3 tags found in data starting at offset, as one block of data\n *\n * @param data - The data to search in\n * @param offset - The offset at which to start searching\n *\n * @returns The block of data containing any ID3 tags found\n * or `undefined` if no header is found at the starting offset\n *\n * @internal\n *\n */\nexport function getId3Data(\n\tdata: Uint8Array,\n\toffset: number,\n): Uint8Array | undefined {\n\tconst front = offset\n\tlet length = 0\n\n\twhile (isId3Header(data, offset)) {\n\t\t// ID3 header is 10 bytes\n\t\tlength += 10\n\n\t\tconst size = readId3Size(data, offset + 6)\n\t\tlength += size\n\n\t\tif (isId3Footer(data, offset + 10)) {\n\t\t\t// ID3 footer is 10 bytes\n\t\t\tlength += 10\n\t\t}\n\n\t\toffset += length\n\t}\n\n\tif (length > 0) {\n\t\treturn data.subarray(front, front + length)\n\t}\n\n\treturn undefined\n}\n","/**\n * @internal\n */\nexport type TypedArray =\n\t| Int8Array\n\t| Uint8Array\n\t| Int16Array\n\t| Uint16Array\n\t| Int32Array\n\t| Uint32Array\n\t| Float32Array\n\t| Float64Array\n\t| Uint8ClampedArray;\n\n/**\n * @internal\n */\nexport function toArrayBuffer(view: ArrayBuffer | TypedArray): ArrayBuffer {\n\tif (view instanceof ArrayBuffer) {\n\t\treturn view\n\t}\n\telse {\n\t\tif (view.byteOffset == 0 && view.byteLength == view.buffer.byteLength) {\n\t\t\t// This is a TypedArray over the whole buffer.\n\t\t\treturn view.buffer as ArrayBuffer\n\t\t}\n\t\t// This is a 'view' on the buffer.  Create a new buffer that only contains\n\t\t// the data.  Note that since this isn't an ArrayBuffer, the 'new' call\n\t\t// will allocate a new buffer to hold the copy.\n\t\treturn new Uint8Array(view).buffer\n\t}\n}\n","/**\n * @internal\n */\nexport function toUint8(\n\tdata: BufferSource,\n\toffset: number = 0,\n\tlength: number = Infinity,\n): Uint8Array<ArrayBuffer> {\n\treturn view(data, offset, length, Uint8Array)\n}\n\nfunction view<T extends ArrayBufferView>(\n\tdata: BufferSource,\n\toffset: number,\n\tlength: number,\n\tType: new(buffer: ArrayBuffer, byteOffset: number, length: number) => T,\n): T {\n\tconst buffer = unsafeGetArrayBuffer(data)\n\tlet bytesPerElement: any = 1\n\tif ('BYTES_PER_ELEMENT' in Type) {\n\t\tbytesPerElement = Type.BYTES_PER_ELEMENT\n\t}\n\t// Absolute end of the |data| view within |buffer|.\n\tconst dataOffset = isArrayBufferView(data) ? data.byteOffset : 0\n\tconst dataEnd = ((dataOffset) + data.byteLength) / bytesPerElement\n\t// Absolute start of the result within |buffer|.\n\tconst rawStart = ((dataOffset) + offset) / bytesPerElement\n\tconst start = Math.floor(Math.max(0, Math.min(rawStart, dataEnd)))\n\t// Absolute end of the result within |buffer|.\n\tconst end = Math.floor(Math.min(start + Math.max(length, 0), dataEnd))\n\treturn new Type(buffer as ArrayBuffer, start, end - start)\n}\n\nfunction unsafeGetArrayBuffer(view: BufferSource) {\n\tif (view instanceof ArrayBuffer) {\n\t\treturn view\n\t}\n\telse {\n\t\treturn view.buffer\n\t}\n}\n\nfunction isArrayBufferView(obj: any): obj is ArrayBufferView {\n\treturn obj && obj.buffer instanceof ArrayBuffer && obj.byteLength !== undefined && obj.byteOffset !== undefined\n}\n","import { decodeText, UTF_8 } from '@svta/cml-utils'\n\n/**\n * Converts a UTF-8 array to a string.\n *\n * @param array - The UTF-8 array to convert\n * @param exitOnNull - Whether to exit on the first null byte\n *\n * @returns The string\n *\n * @internal\n */\nexport function utf8ArrayToStr(\n\tarray: Uint8Array<ArrayBuffer>,\n\texitOnNull: boolean = false,\n): string {\n\tconst byteLength = exitOnNull ? array.indexOf(0) : array.length\n\tconst view = new DataView<ArrayBuffer>(array.buffer, array.byteOffset, byteLength)\n\tconst result = decodeText(view, { encoding: UTF_8 })\n\n\treturn exitOnNull ? result : result.replace(/\\0/g, '')\n}\n","import type { DecodedId3Frame } from '../DecodedId3Frame.ts'\nimport type { RawId3Frame } from './RawFrame.ts'\nimport { toArrayBuffer } from './toArrayBuffer.ts'\nimport { toUint8 } from './utf8.ts'\nimport { utf8ArrayToStr } from './utf8ArrayToStr.ts'\n\ntype MetadataFrame = {\n\tkey: string;\n\tdescription: string;\n\tdata: string | ArrayBuffer;\n\tmimeType: string | null;\n\tpictureType: number | null;\n};\n\nexport function decodeId3ImageFrame(\n\tframe: RawId3Frame,\n): DecodedId3Frame<string | ArrayBuffer> | undefined {\n\tconst metadataFrame: MetadataFrame = {\n\t\tkey: frame.type,\n\t\tdescription: '',\n\t\tdata: '',\n\t\tmimeType: null,\n\t\tpictureType: null,\n\t}\n\n\tconst utf8Encoding = 0x03\n\n\tif (frame.size < 2) {\n\t\treturn undefined\n\t}\n\tif (frame.data[0] !== utf8Encoding) {\n\t\tconsole.log('Ignore frame with unrecognized character ' + 'encoding')\n\t\treturn undefined\n\t}\n\n\tconst mimeTypeEndIndex = frame.data.subarray(1).indexOf(0)\n\tif (mimeTypeEndIndex === -1) {\n\t\treturn undefined\n\t}\n\tconst mimeType = utf8ArrayToStr(toUint8(frame.data, 1, mimeTypeEndIndex))\n\tconst pictureType = frame.data[2 + mimeTypeEndIndex]\n\tconst descriptionEndIndex = frame.data\n\t\t.subarray(3 + mimeTypeEndIndex)\n\t\t.indexOf(0)\n\tif (descriptionEndIndex === -1) {\n\t\treturn undefined\n\t}\n\tconst description = utf8ArrayToStr(\n\t\ttoUint8(frame.data, 3 + mimeTypeEndIndex, descriptionEndIndex),\n\t)\n\n\tlet data\n\tif (mimeType === '-->') {\n\t\tdata = utf8ArrayToStr(\n\t\t\ttoUint8(frame.data, 4 + mimeTypeEndIndex + descriptionEndIndex),\n\t\t)\n\t}\n\telse {\n\t\tdata = toArrayBuffer(\n\t\t\tframe.data.subarray(4 + mimeTypeEndIndex + descriptionEndIndex),\n\t\t)\n\t}\n\n\tmetadataFrame.mimeType = mimeType\n\tmetadataFrame.pictureType = pictureType\n\tmetadataFrame.description = description\n\tmetadataFrame.data = data\n\treturn metadataFrame\n}\n","import type { DecodedId3Frame } from '../DecodedId3Frame.ts'\nimport type { RawId3Frame } from './RawFrame.ts'\nimport { utf8ArrayToStr } from './utf8ArrayToStr.ts'\n\n/**\n * Decode an ID3 PRIV frame.\n *\n * @param frame - the ID3 PRIV frame\n *\n * @returns The decoded ID3 PRIV frame\n *\n * @internal\n *\n */\nexport function decodeId3PrivFrame(\n\tframe: RawId3Frame,\n): DecodedId3Frame<ArrayBuffer> | undefined {\n\t/*\n\tFormat: <text string>\\0<binary data>\n\t*/\n\tif (frame.size < 2) {\n\t\treturn undefined\n\t}\n\n\tconst owner = utf8ArrayToStr(frame.data, true)\n\tconst privateData = new Uint8Array(frame.data.subarray(owner.length + 1))\n\n\treturn { key: frame.type, info: owner, data: privateData.buffer }\n}\n","import type { DecodedId3Frame } from '../DecodedId3Frame.ts'\nimport type { RawId3Frame } from './RawFrame.ts'\nimport { utf8ArrayToStr } from './utf8ArrayToStr.ts'\n\n/**\n * Decodes an ID3 text frame\n *\n * @param frame - the ID3 text frame\n *\n * @returns The decoded ID3 text frame\n *\n * @internal\n *\n */\nexport function decodeId3TextFrame(frame: RawId3Frame): DecodedId3Frame<string> | undefined {\n\tif (frame.size < 2) {\n\t\treturn undefined\n\t}\n\n\tif (frame.type === 'TXXX') {\n\t\t/*\n\t\tFormat:\n\t\t[0]   = {Text Encoding}\n\t\t[1-?] = {Description}\\0{Value}\n\t\t*/\n\t\tlet index = 1\n\t\tconst { data } = frame\n\t\tconst description = utf8ArrayToStr(data.subarray(index), true)\n\n\t\tindex += description.length + 1\n\t\tconst value = utf8ArrayToStr(data.subarray(index))\n\n\t\treturn { key: frame.type, info: description, data: value }\n\t}\n\t/*\n\tFormat:\n\t[0]   = {Text Encoding}\n\t[1-?] = {Value}\n\t*/\n\tconst text = utf8ArrayToStr(frame.data.subarray(1))\n\treturn { key: frame.type, info: '', data: text }\n}\n","import type { DecodedId3Frame } from '../DecodedId3Frame.ts'\nimport type { RawId3Frame } from './RawFrame.ts'\nimport { utf8ArrayToStr } from './utf8ArrayToStr.ts'\n\n/**\n * Decode a URL frame\n *\n * @param frame - the ID3 URL frame\n *\n * @returns The decoded ID3 URL frame\n *\n * @internal\n *\n */\nexport function decodeId3UrlFrame(frame: RawId3Frame): DecodedId3Frame<string> | undefined {\n\tif (frame.type === 'WXXX') {\n\t\t/*\n\t\tFormat:\n\t\t[0]   = {Text Encoding}\n\t\t[1-?] = {Description}\\0{URL}\n\t\t*/\n\t\tif (frame.size < 2) {\n\t\t\treturn undefined\n\t\t}\n\n\t\tlet index = 1\n\t\tconst description: string = utf8ArrayToStr(\n\t\t\tframe.data.subarray(index),\n\t\t\ttrue,\n\t\t)\n\n\t\tindex += description.length + 1\n\t\tconst value: string = utf8ArrayToStr(frame.data.subarray(index))\n\n\t\treturn { key: frame.type, info: description, data: value }\n\t}\n\t/*\n\tFormat:\n\t[0-?] = {URL}\n\t*/\n\tconst url: string = utf8ArrayToStr(frame.data)\n\treturn { key: frame.type, info: '', data: url }\n}\n","import type { Id3Frame } from '../Id3Frame.ts'\nimport type { RawId3Frame } from './RawFrame.ts'\nimport { decodeId3ImageFrame } from './decodeId3ImageFrame.ts'\nimport { decodeId3PrivFrame } from './decodeId3PrivFrame.ts'\nimport { decodeId3TextFrame } from './decodeId3TextFrame.ts'\nimport { decodeId3UrlFrame } from './decodeId3UrlFrame.ts'\n\n/**\n * Decode an ID3 frame.\n *\n * @param frame - the ID3 frame\n *\n * @returns The decoded ID3 frame\n *\n * @internal\n *\n */\nexport function decodeId3Frame(frame: RawId3Frame): Id3Frame | undefined {\n\tif (frame.type === 'PRIV') {\n\t\treturn decodeId3PrivFrame(frame)\n\t}\n\telse if (frame.type[0] === 'W') {\n\t\treturn decodeId3UrlFrame(frame)\n\t}\n\n\telse if (frame.type === 'APIC') {\n\t\treturn decodeId3ImageFrame(frame)\n\t}\n\n\treturn decodeId3TextFrame(frame)\n}\n","import type { RawId3Frame } from './RawFrame.ts'\nimport { readId3Size } from './readId3Size.ts'\n\n/**\n * Returns the data of an ID3 frame.\n *\n * @param data - The data to read from\n *\n * @returns The data of the ID3 frame\n *\n * @internal\n *\n */\nexport function getId3FrameData(data: Uint8Array<ArrayBuffer>): RawId3Frame {\n\t/*\n\tFrame ID       $xx xx xx xx (four characters)\n\tSize           $xx xx xx xx\n\tFlags          $xx xx\n\t*/\n\tconst type: string = String.fromCharCode(data[0], data[1], data[2], data[3])\n\tconst size: number = readId3Size(data, 4)\n\n\t// skip frame id, size, and flags\n\tconst offset = 10\n\n\treturn { type, size, data: data.subarray(offset, offset + size) }\n}\n","import type { Id3Frame } from './Id3Frame.ts'\nimport type { RawId3Frame } from './util/RawFrame.ts'\nimport { decodeId3Frame } from './util/decodeId3Frame.ts'\nimport { getId3FrameData } from './util/getId3FrameData.ts'\nimport { isId3Footer } from './util/isId3Footer.ts'\nimport { isId3Header } from './util/isId3Header.ts'\nimport { readId3Size } from './util/readId3Size.ts'\n\nconst HEADER_FOOTER_SIZE = 10\nconst FRAME_SIZE = 10\n\n/**\n * Returns an array of ID3 frames found in all the ID3 tags in the id3Data\n *\n * @param id3Data - The ID3 data containing one or more ID3 tags\n *\n * @returns Array of ID3 frame objects\n *\n *\n * @beta\n */\nexport function getId3Frames(id3Data: Uint8Array<ArrayBuffer>): Id3Frame[] {\n\tlet offset = 0\n\tconst frames: Id3Frame[] = []\n\n\twhile (isId3Header(id3Data, offset)) {\n\t\tconst size = readId3Size(id3Data, offset + 6)\n\n\t\tif ((id3Data[offset + 5] >> 6) & 1) {\n\t\t\t// skip extended header\n\t\t\toffset += HEADER_FOOTER_SIZE\n\t\t}\n\t\t// skip past ID3 header\n\t\toffset += HEADER_FOOTER_SIZE\n\t\tconst end = offset + size\n\t\t// loop through frames in the ID3 tag\n\t\twhile (offset + FRAME_SIZE < end) {\n\t\t\tconst frameData: RawId3Frame = getId3FrameData(id3Data.subarray(offset))\n\t\t\tconst frame: Id3Frame | undefined = decodeId3Frame(frameData)\n\t\t\tif (frame) {\n\t\t\t\tframes.push(frame)\n\t\t\t}\n\n\t\t\t// skip frame header and frame data\n\t\t\toffset += frameData.size + HEADER_FOOTER_SIZE\n\t\t}\n\n\t\tif (isId3Footer(id3Data, offset)) {\n\t\t\toffset += HEADER_FOOTER_SIZE\n\t\t}\n\t}\n\n\treturn frames\n}\n","import type { Id3Frame } from './Id3Frame.ts'\n\n/**\n * Returns true if the ID3 frame is an Elementary Stream timestamp frame\n *\n * @param frame - the ID3 frame\n *\n * @returns `true` if the ID3 frame is an Elementary Stream timestamp frame\n *\n * @internal\n *\n */\nexport function isId3TimestampFrame(frame: Id3Frame): boolean {\n\treturn (\n\t\tframe &&\n\t\tframe.key === 'PRIV' &&\n\t\tframe.info === 'com.apple.streaming.transportStreamTimestamp'\n\t)\n}\n","import type { DecodedId3Frame } from '../DecodedId3Frame.ts'\n\n/**\n * Read a 33 bit timestamp from an ID3 frame.\n *\n * @param timeStampFrame - the ID3 frame\n *\n * @returns The timestamp\n *\n * @internal\n *\n */\nexport function readId3Timestamp(\n\ttimeStampFrame: DecodedId3Frame<ArrayBuffer>,\n): number | undefined {\n\tif (timeStampFrame.data.byteLength === 8) {\n\t\tconst data = new Uint8Array(timeStampFrame.data)\n\t\t// timestamp is 33 bit expressed as a big-endian eight-octet number,\n\t\t// with the upper 31 bits set to zero.\n\t\tconst pts33Bit = data[3] & 0x1\n\t\tlet timestamp =\n\t\t\t(data[4] << 23) + (data[5] << 15) + (data[6] << 7) + data[7]\n\t\ttimestamp /= 45\n\n\t\tif (pts33Bit) {\n\t\t\ttimestamp += 47721858.84\n\t\t} // 2^32 / 90\n\n\t\treturn Math.round(timestamp)\n\t}\n\n\treturn undefined\n}\n","import type { DecodedId3Frame } from './DecodedId3Frame.ts'\nimport type { Id3Frame } from './Id3Frame.ts'\nimport { getId3Frames } from './getId3Frames.ts'\nimport { isId3TimestampFrame } from './isId3TimestampFrame.ts'\nimport { readId3Timestamp } from './util/readId3Timestamp.ts'\n\n/**\n * Searches for the Elementary Stream timestamp found in the ID3 data chunk\n *\n * @param data - Block of data containing one or more ID3 tags\n *\n * @returns The timestamp\n *\n *\n * @beta\n */\nexport function getId3Timestamp(data: Uint8Array<ArrayBuffer>): number | undefined {\n\tconst frames: Id3Frame[] = getId3Frames(data)\n\n\tfor (const frame of frames) {\n\t\tif (isId3TimestampFrame(frame)) {\n\t\t\treturn readId3Timestamp(frame as DecodedId3Frame<ArrayBuffer>)\n\t\t}\n\t}\n\n\treturn undefined\n}\n","/**\n * The scheme ID URI for ID3 tags.\n *\n *\n * @beta\n *\n * @see {@link https://aomediacodec.github.io/id3-emsg/ | Carriage of ID3 Timed Metadata in the Common Media Application Format (CMAF)}\n * @see {@link https://developer.apple.com/documentation/http-live-streaming/about-the-common-media-application-format-with-http-live-streaming-hls#CMAF-Tracks-Segments-Headers-and-Fragments | CMAF Tracks, Segments, Headers, and Fragments}\n */\nexport const ID3_SCHEME_ID_URI = 'https://aomedia.org/emsg/ID3'\n"],"mappings":"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"}