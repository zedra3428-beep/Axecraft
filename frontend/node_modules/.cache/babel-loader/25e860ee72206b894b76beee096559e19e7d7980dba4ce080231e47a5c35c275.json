{"ast":null,"code":"import _objectSpread from \"/app/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport le from \"mux-embed\";\nimport rt from \"hls.js\";\nvar E = rt;\nvar C = {\n    VIDEO: \"video\",\n    THUMBNAIL: \"thumbnail\",\n    STORYBOARD: \"storyboard\",\n    DRM: \"drm\"\n  },\n  b = {\n    NOT_AN_ERROR: 0,\n    NETWORK_OFFLINE: 2000002,\n    NETWORK_UNKNOWN_ERROR: 2e6,\n    NETWORK_NO_STATUS: 2000001,\n    NETWORK_INVALID_URL: 24e5,\n    NETWORK_NOT_FOUND: 2404e3,\n    NETWORK_NOT_READY: 2412e3,\n    NETWORK_GENERIC_SERVER_FAIL: 25e5,\n    NETWORK_TOKEN_MISSING: 2403201,\n    NETWORK_TOKEN_MALFORMED: 2412202,\n    NETWORK_TOKEN_EXPIRED: 2403210,\n    NETWORK_TOKEN_AUD_MISSING: 2403221,\n    NETWORK_TOKEN_AUD_MISMATCH: 2403222,\n    NETWORK_TOKEN_SUB_MISMATCH: 2403232,\n    ENCRYPTED_ERROR: 5e6,\n    ENCRYPTED_UNSUPPORTED_KEY_SYSTEM: 5000001,\n    ENCRYPTED_GENERATE_REQUEST_FAILED: 5000002,\n    ENCRYPTED_UPDATE_LICENSE_FAILED: 5000003,\n    ENCRYPTED_UPDATE_SERVER_CERT_FAILED: 5000004,\n    ENCRYPTED_CDM_ERROR: 5000005,\n    ENCRYPTED_OUTPUT_RESTRICTED: 5000006,\n    ENCRYPTED_MISSING_TOKEN: 5000002\n  },\n  W = e => e === C.VIDEO ? \"playback\" : e,\n  L = class L extends Error {\n    constructor(t) {\n      let r = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : L.MEDIA_ERR_CUSTOM;\n      let n = arguments.length > 2 ? arguments[2] : undefined;\n      let o = arguments.length > 3 ? arguments[3] : undefined;\n      var s;\n      super(t), this.name = \"MediaError\", this.code = r, this.context = o, this.fatal = n != null ? n : r >= L.MEDIA_ERR_NETWORK && r <= L.MEDIA_ERR_ENCRYPTED, this.message || (this.message = (s = L.defaultMessages[this.code]) != null ? s : \"\");\n    }\n  };\nL.MEDIA_ERR_ABORTED = 1, L.MEDIA_ERR_NETWORK = 2, L.MEDIA_ERR_DECODE = 3, L.MEDIA_ERR_SRC_NOT_SUPPORTED = 4, L.MEDIA_ERR_ENCRYPTED = 5, L.MEDIA_ERR_CUSTOM = 100, L.defaultMessages = {\n  1: \"You aborted the media playback\",\n  2: \"A network error caused the media download to fail.\",\n  3: \"A media error caused playback to be aborted. The media could be corrupt or your browser does not support this format.\",\n  4: \"An unsupported error occurred. The server or network failed, or your browser does not support this format.\",\n  5: \"The media is encrypted and there are no keys to decrypt it.\"\n};\nvar T = L;\nvar nt = e => e == null,\n  H = (e, t) => nt(t) ? !1 : e in t,\n  Y = {\n    ANY: \"any\",\n    MUTED: \"muted\"\n  },\n  h = {\n    ON_DEMAND: \"on-demand\",\n    LIVE: \"live\",\n    UNKNOWN: \"unknown\"\n  },\n  Q = {\n    MSE: \"mse\",\n    NATIVE: \"native\"\n  },\n  w = {\n    HEADER: \"header\",\n    QUERY: \"query\",\n    NONE: \"none\"\n  },\n  zt = Object.values(w),\n  I = {\n    M3U8: \"application/vnd.apple.mpegurl\",\n    MP4: \"video/mp4\"\n  },\n  F = {\n    HLS: I.M3U8\n  },\n  Qt = Object.keys(F),\n  Zt = [...Object.values(I), \"hls\", \"HLS\"],\n  er = {\n    upTo720p: \"720p\",\n    upTo1080p: \"1080p\",\n    upTo1440p: \"1440p\",\n    upTo2160p: \"2160p\"\n  },\n  tr = {\n    noLessThan480p: \"480p\",\n    noLessThan540p: \"540p\",\n    noLessThan720p: \"720p\",\n    noLessThan1080p: \"1080p\",\n    noLessThan1440p: \"1440p\",\n    noLessThan2160p: \"2160p\"\n  },\n  rr = {\n    DESCENDING: \"desc\"\n  },\n  nr = {\n    upTo720p: \"720p\",\n    upTo1080p: \"1080p\",\n    upTo1440p: \"1440p\",\n    upTo2160p: \"2160p\"\n  };\nvar ot = \"en\",\n  $ = {\n    code: ot\n  };\nvar v = function (e, t, r, n) {\n  let o = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : e;\n  o.addEventListener(t, r, n), e.addEventListener(\"teardown\", () => {\n    o.removeEventListener(t, r);\n  }, {\n    once: !0\n  });\n};\nfunction me(e, t, r) {\n  t && r > t && (r = t);\n  for (let n = 0; n < e.length; n++) if (e.start(n) <= r && e.end(n) >= r) return !0;\n  return !1;\n}\nvar B = e => {\n    let t = e.indexOf(\"?\");\n    if (t < 0) return [e];\n    let r = e.slice(0, t),\n      n = e.slice(t);\n    return [r, n];\n  },\n  V = e => {\n    let {\n      type: t\n    } = e;\n    if (t) {\n      let r = t.toUpperCase();\n      return H(r, F) ? F[r] : t;\n    }\n    return at(e);\n  },\n  ee = e => e === \"VOD\" ? h.ON_DEMAND : h.LIVE,\n  te = e => e === \"EVENT\" ? Number.POSITIVE_INFINITY : e === \"VOD\" ? Number.NaN : 0,\n  at = e => {\n    let {\n      src: t\n    } = e;\n    if (!t) return \"\";\n    let r = \"\";\n    try {\n      r = new URL(t).pathname;\n    } catch (_unused) {\n      console.error(\"invalid url\");\n    }\n    let n = r.lastIndexOf(\".\");\n    if (n < 0) return it(e) ? I.M3U8 : \"\";\n    let s = r.slice(n + 1).toUpperCase();\n    return H(s, I) ? I[s] : \"\";\n  },\n  st = \"mux.com\",\n  it = _ref => {\n    let {\n      src: e,\n      customDomain: t = st\n    } = _ref;\n    let r;\n    try {\n      r = new URL(\"\".concat(e));\n    } catch (_unused2) {\n      return !1;\n    }\n    let n = r.protocol === \"https:\",\n      o = r.hostname === \"stream.\".concat(t).toLowerCase(),\n      s = r.pathname.split(\"/\"),\n      a = s.length === 2,\n      i = !(s != null && s[1].includes(\".\"));\n    return n && o && a && i;\n  },\n  re = e => {\n    let t = (e != null ? e : \"\").split(\".\")[1];\n    if (t) try {\n      let r = t.replace(/-/g, \"+\").replace(/_/g, \"/\"),\n        n = decodeURIComponent(atob(r).split(\"\").map(function (o) {\n          return \"%\" + (\"00\" + o.charCodeAt(0).toString(16)).slice(-2);\n        }).join(\"\"));\n      return JSON.parse(n);\n    } catch (_unused3) {\n      return;\n    }\n  },\n  Ee = function (_ref2) {\n    let {\n      exp: e\n    } = _ref2;\n    let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Date.now();\n    return !e || e * 1e3 < t;\n  },\n  ge = (_ref3, t) => {\n    let {\n      sub: e\n    } = _ref3;\n    return e !== t;\n  },\n  Me = (_ref4, t) => {\n    let {\n      aud: e\n    } = _ref4;\n    return !e;\n  },\n  xe = (_ref5, t) => {\n    let {\n      aud: e\n    } = _ref5;\n    return e !== t;\n  },\n  Re = \"en\";\nfunction x(e) {\n  let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !0;\n  var o, s;\n  let r = t && (s = (o = $) == null ? void 0 : o[e]) != null ? s : e,\n    n = t ? $.code : Re;\n  return new Z(r, n);\n}\nvar Z = class {\n  constructor(t) {\n    let r = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : (n => (n = $) != null ? n : Re)();\n    this.message = t, this.locale = r;\n  }\n  format(t) {\n    return this.message.replace(/\\{(\\w+)\\}/g, (r, n) => {\n      var o;\n      return (o = t[n]) != null ? o : \"\";\n    });\n  }\n  toString() {\n    return this.message;\n  }\n};\nvar ct = Object.values(Y),\n  be = e => typeof e == \"boolean\" || typeof e == \"string\" && ct.includes(e),\n  De = (e, t, r) => {\n    let {\n        autoplay: n\n      } = e,\n      o = !1,\n      s = !1,\n      a = be(n) ? n : !!n,\n      i = () => {\n        o || v(t, \"playing\", () => {\n          o = !0;\n        }, {\n          once: !0\n        });\n      };\n    if (i(), v(t, \"loadstart\", () => {\n      o = !1, i(), ne(t, a);\n    }, {\n      once: !0\n    }), v(t, \"loadstart\", () => {\n      r || (e.streamType && e.streamType !== h.UNKNOWN ? s = e.streamType === h.LIVE : s = !Number.isFinite(t.duration)), ne(t, a);\n    }, {\n      once: !0\n    }), r && r.once(E.Events.LEVEL_LOADED, (d, l) => {\n      var u;\n      e.streamType && e.streamType !== h.UNKNOWN ? s = e.streamType === h.LIVE : s = (u = l.details.live) != null ? u : !1;\n    }), !a) {\n      let d = () => {\n        !s || Number.isFinite(e.startTime) || (r != null && r.liveSyncPosition ? t.currentTime = r.liveSyncPosition : Number.isFinite(t.seekable.end(0)) && (t.currentTime = t.seekable.end(0)));\n      };\n      r && v(t, \"play\", () => {\n        t.preload === \"metadata\" ? r.once(E.Events.LEVEL_UPDATED, d) : d();\n      }, {\n        once: !0\n      });\n    }\n    return d => {\n      o || (a = be(d) ? d : !!d, ne(t, a));\n    };\n  },\n  ne = (e, t) => {\n    if (!t) return;\n    let r = e.muted,\n      n = () => e.muted = r;\n    switch (t) {\n      case Y.ANY:\n        e.play().catch(() => {\n          e.muted = !0, e.play().catch(n);\n        });\n        break;\n      case Y.MUTED:\n        e.muted = !0, e.play().catch(n);\n        break;\n      default:\n        e.play().catch(() => {});\n        break;\n    }\n  };\nvar Ce = (_ref6, r, n) => {\n  let {\n    preload: e,\n    src: t\n  } = _ref6;\n  let o = u => {\n    u != null && [\"\", \"none\", \"metadata\", \"auto\"].includes(u) ? r.setAttribute(\"preload\", u) : r.removeAttribute(\"preload\");\n  };\n  if (!n) return o(e), o;\n  let s = !1,\n    a = !1,\n    i = n.config.maxBufferLength,\n    c = n.config.maxBufferSize,\n    d = u => {\n      o(u);\n      let y = u != null ? u : r.preload;\n      a || y === \"none\" || (y === \"metadata\" ? (n.config.maxBufferLength = 1, n.config.maxBufferSize = 1) : (n.config.maxBufferLength = i, n.config.maxBufferSize = c), l());\n    },\n    l = () => {\n      !s && t && (s = !0, n.loadSource(t));\n    };\n  return v(r, \"play\", () => {\n    a = !0, n.config.maxBufferLength = i, n.config.maxBufferSize = c, l();\n  }, {\n    once: !0\n  }), d(e), d;\n};\nfunction ve(e, t) {\n  var i;\n  if (!(\"videoTracks\" in e)) return;\n  let r = new WeakMap();\n  t.on(E.Events.MANIFEST_PARSED, function (c, d) {\n    a();\n    let l = e.addVideoTrack(\"main\");\n    l.selected = !0;\n    for (let [u, y] of d.levels.entries()) {\n      let m = l.addRendition(y.url[0], y.width, y.height, y.videoCodec, y.bitrate);\n      r.set(y, \"\".concat(u)), m.id = \"\".concat(u);\n    }\n  }), t.on(E.Events.AUDIO_TRACKS_UPDATED, function (c, d) {\n    s();\n    for (let l of d.audioTracks) {\n      let u = l.default ? \"main\" : \"alternative\",\n        y = e.addAudioTrack(u, l.name, l.lang);\n      y.id = \"\".concat(l.id), l.default && (y.enabled = !0);\n    }\n  }), e.audioTracks.addEventListener(\"change\", () => {\n    var l;\n    let c = +((l = [...e.audioTracks].find(u => u.enabled)) == null ? void 0 : l.id),\n      d = t.audioTracks.map(u => u.id);\n    c != t.audioTrack && d.includes(c) && (t.audioTrack = c);\n  }), t.on(E.Events.LEVELS_UPDATED, function (c, d) {\n    var y;\n    let l = e.videoTracks[(y = e.videoTracks.selectedIndex) != null ? y : 0];\n    if (!l) return;\n    let u = d.levels.map(m => r.get(m));\n    for (let m of e.videoRenditions) m.id && !u.includes(m.id) && l.removeRendition(m);\n  });\n  let n = c => {\n    let d = c.target.selectedIndex;\n    d != t.nextLevel && (t.nextLevel = d);\n  };\n  (i = e.videoRenditions) == null || i.addEventListener(\"change\", n);\n  let o = () => {\n      for (let c of e.videoTracks) e.removeVideoTrack(c);\n    },\n    s = () => {\n      for (let c of e.audioTracks) e.removeAudioTrack(c);\n    },\n    a = () => {\n      o(), s();\n    };\n  t.once(E.Events.DESTROYING, a);\n}\nvar oe = e => \"time\" in e ? e.time : e.startTime;\nfunction Pe(e, t) {\n  t.on(E.Events.NON_NATIVE_TEXT_TRACKS_FOUND, (o, _ref7) => {\n    let {\n      tracks: s\n    } = _ref7;\n    s.forEach(a => {\n      var l, u;\n      let i = (l = a.subtitleTrack) != null ? l : a.closedCaptions,\n        c = t.subtitleTracks.findIndex(_ref8 => {\n          let {\n            lang: y,\n            name: m,\n            type: f\n          } = _ref8;\n          return y == (i == null ? void 0 : i.lang) && m === a.label && f.toLowerCase() === a.kind;\n        }),\n        d = ((u = a._id) != null ? u : a.default) ? \"default\" : \"\".concat(a.kind).concat(c);\n      ae(e, a.kind, a.label, i == null ? void 0 : i.lang, d, a.default);\n    });\n  });\n  let r = () => {\n    if (!t.subtitleTracks.length) return;\n    let o = Array.from(e.textTracks).find(i => i.id && i.mode === \"showing\" && [\"subtitles\", \"captions\"].includes(i.kind));\n    if (!o) return;\n    let s = t.subtitleTracks[t.subtitleTrack],\n      a = s ? s.default ? \"default\" : \"\".concat(t.subtitleTracks[t.subtitleTrack].type.toLowerCase()).concat(t.subtitleTrack) : void 0;\n    if (t.subtitleTrack < 0 || (o == null ? void 0 : o.id) !== a) {\n      let i = t.subtitleTracks.findIndex(_ref9 => {\n        let {\n          lang: c,\n          name: d,\n          type: l,\n          default: u\n        } = _ref9;\n        return o.id === \"default\" && u || c == o.language && d === o.label && l.toLowerCase() === o.kind;\n      });\n      t.subtitleTrack = i;\n    }\n    (o == null ? void 0 : o.id) === a && o.cues && Array.from(o.cues).forEach(i => {\n      o.addCue(i);\n    });\n  };\n  e.textTracks.addEventListener(\"change\", r), t.on(E.Events.CUES_PARSED, (o, _ref0) => {\n    let {\n      track: s,\n      cues: a\n    } = _ref0;\n    let i = e.textTracks.getTrackById(s);\n    if (!i) return;\n    let c = i.mode === \"disabled\";\n    c && (i.mode = \"hidden\"), a.forEach(d => {\n      var l;\n      (l = i.cues) != null && l.getCueById(d.id) || i.addCue(d);\n    }), c && (i.mode = \"disabled\");\n  }), t.once(E.Events.DESTROYING, () => {\n    e.textTracks.removeEventListener(\"change\", r), e.querySelectorAll(\"track[data-removeondestroy]\").forEach(s => {\n      s.remove();\n    });\n  });\n  let n = () => {\n    Array.from(e.textTracks).forEach(o => {\n      var s, a;\n      if (![\"subtitles\", \"caption\"].includes(o.kind) && (o.label === \"thumbnails\" || o.kind === \"chapters\")) {\n        if (!((s = o.cues) != null && s.length)) {\n          let i = \"track\";\n          o.kind && (i += \"[kind=\\\"\".concat(o.kind, \"\\\"]\")), o.label && (i += \"[label=\\\"\".concat(o.label, \"\\\"]\"));\n          let c = e.querySelector(i),\n            d = (a = c == null ? void 0 : c.getAttribute(\"src\")) != null ? a : \"\";\n          c == null || c.removeAttribute(\"src\"), setTimeout(() => {\n            c == null || c.setAttribute(\"src\", d);\n          }, 0);\n        }\n        o.mode !== \"hidden\" && (o.mode = \"hidden\");\n      }\n    });\n  };\n  t.once(E.Events.MANIFEST_LOADED, n), t.once(E.Events.MEDIA_ATTACHED, n);\n}\nfunction ae(e, t, r, n, o, s) {\n  let a = document.createElement(\"track\");\n  return a.kind = t, a.label = r, n && (a.srclang = n), o && (a.id = o), s && (a.default = !0), a.track.mode = [\"subtitles\", \"captions\"].includes(t) ? \"disabled\" : \"hidden\", a.setAttribute(\"data-removeondestroy\", \"\"), e.append(a), a.track;\n}\nfunction ut(e, t) {\n  let r = Array.prototype.find.call(e.querySelectorAll(\"track\"), n => n.track === t);\n  r == null || r.remove();\n}\nfunction O(e, t, r) {\n  var n;\n  return (n = Array.from(e.querySelectorAll(\"track\")).find(o => o.track.label === t && o.track.kind === r)) == null ? void 0 : n.track;\n}\nasync function he(e, t, r, n) {\n  let o = O(e, r, n);\n  return o || (o = ae(e, n, r), o.mode = \"hidden\", await new Promise(s => setTimeout(() => s(void 0), 0))), o.mode !== \"hidden\" && (o.mode = \"hidden\"), [...t].sort((s, a) => oe(a) - oe(s)).forEach(s => {\n    var c, d;\n    let a = s.value,\n      i = oe(s);\n    if (\"endTime\" in s && s.endTime != null) o == null || o.addCue(new VTTCue(i, s.endTime, n === \"chapters\" ? a : JSON.stringify(a != null ? a : null)));else {\n      let l = Array.prototype.findIndex.call(o == null ? void 0 : o.cues, f => f.startTime >= i),\n        u = (c = o == null ? void 0 : o.cues) == null ? void 0 : c[l],\n        y = u ? u.startTime : Number.isFinite(e.duration) ? e.duration : Number.MAX_SAFE_INTEGER,\n        m = (d = o == null ? void 0 : o.cues) == null ? void 0 : d[l - 1];\n      m && (m.endTime = i), o == null || o.addCue(new VTTCue(i, y, n === \"chapters\" ? a : JSON.stringify(a != null ? a : null)));\n    }\n  }), e.textTracks.dispatchEvent(new Event(\"change\", {\n    bubbles: !0,\n    composed: !0\n  })), o;\n}\nvar se = \"cuepoints\",\n  _e = Object.freeze({\n    label: se\n  });\nasync function ke(e, t) {\n  let r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _e;\n  return he(e, t, r.label, \"metadata\");\n}\nvar J = e => ({\n  time: e.startTime,\n  value: JSON.parse(e.text)\n});\nfunction dt(e) {\n  let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n    label: se\n  };\n  let r = O(e, t.label, \"metadata\");\n  return r != null && r.cues ? Array.from(r.cues, n => J(n)) : [];\n}\nfunction Le(e) {\n  let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n    label: se\n  };\n  var s, a;\n  let r = O(e, t.label, \"metadata\");\n  if (!((s = r == null ? void 0 : r.activeCues) != null && s.length)) return;\n  if (r.activeCues.length === 1) return J(r.activeCues[0]);\n  let {\n      currentTime: n\n    } = e,\n    o = Array.prototype.find.call((a = r.activeCues) != null ? a : [], _ref1 => {\n      let {\n        startTime: i,\n        endTime: c\n      } = _ref1;\n      return i <= n && c > n;\n    });\n  return J(o || r.activeCues[0]);\n}\nasync function Ae(e) {\n  let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _e;\n  return new Promise(r => {\n    v(e, \"loadstart\", async () => {\n      let n = await ke(e, [], t);\n      v(e, \"cuechange\", () => {\n        let o = Le(e);\n        if (o) {\n          let s = new CustomEvent(\"cuepointchange\", {\n            composed: !0,\n            bubbles: !0,\n            detail: o\n          });\n          e.dispatchEvent(s);\n        }\n      }, {}, n), r(n);\n    });\n  });\n}\nvar ie = \"chapters\",\n  Ie = Object.freeze({\n    label: ie\n  }),\n  j = e => ({\n    startTime: e.startTime,\n    endTime: e.endTime,\n    value: e.text\n  });\nasync function Se(e, t) {\n  let r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Ie;\n  return he(e, t, r.label, \"chapters\");\n}\nfunction lt(e) {\n  let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n    label: ie\n  };\n  var n;\n  let r = O(e, t.label, \"chapters\");\n  return (n = r == null ? void 0 : r.cues) != null && n.length ? Array.from(r.cues, o => j(o)) : [];\n}\nfunction Ne(e) {\n  let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n    label: ie\n  };\n  var s, a;\n  let r = O(e, t.label, \"chapters\");\n  if (!((s = r == null ? void 0 : r.activeCues) != null && s.length)) return;\n  if (r.activeCues.length === 1) return j(r.activeCues[0]);\n  let {\n      currentTime: n\n    } = e,\n    o = Array.prototype.find.call((a = r.activeCues) != null ? a : [], _ref10 => {\n      let {\n        startTime: i,\n        endTime: c\n      } = _ref10;\n      return i <= n && c > n;\n    });\n  return j(o || r.activeCues[0]);\n}\nasync function we(e) {\n  let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Ie;\n  return new Promise(r => {\n    v(e, \"loadstart\", async () => {\n      let n = await Se(e, [], t);\n      v(e, \"cuechange\", () => {\n        let o = Ne(e);\n        if (o) {\n          let s = new CustomEvent(\"chapterchange\", {\n            composed: !0,\n            bubbles: !0,\n            detail: o\n          });\n          e.dispatchEvent(s);\n        }\n      }, {}, n), r(n);\n    });\n  });\n}\nfunction pt(e, t) {\n  if (t) {\n    let r = t.playingDate;\n    if (r != null) return new Date(r.getTime() - e.currentTime * 1e3);\n  }\n  return typeof e.getStartDate == \"function\" ? e.getStartDate() : new Date(NaN);\n}\nfunction ft(e, t) {\n  if (t && t.playingDate) return t.playingDate;\n  if (typeof e.getStartDate == \"function\") {\n    let r = e.getStartDate();\n    return new Date(r.getTime() + e.currentTime * 1e3);\n  }\n  return new Date(NaN);\n}\nvar ce = {\n    VIDEO: \"v\",\n    THUMBNAIL: \"t\",\n    STORYBOARD: \"s\",\n    DRM: \"d\"\n  },\n  Tt = e => {\n    if (e === C.VIDEO) return ce.VIDEO;\n    if (e === C.DRM) return ce.DRM;\n  },\n  yt = (e, t) => {\n    var o, s;\n    let r = W(e),\n      n = \"\".concat(r, \"Token\");\n    return (o = t.tokens) != null && o[r] ? (s = t.tokens) == null ? void 0 : s[r] : H(n, t) ? t[n] : void 0;\n  },\n  K = function (e, t, r, n) {\n    let o = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : !1;\n    let s = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : !(a => (a = globalThis.navigator) == null ? void 0 : a.onLine)();\n    var M, k;\n    if (s) {\n      let R = x(\"Your device appears to be offline\", o),\n        D = void 0,\n        p = T.MEDIA_ERR_NETWORK,\n        _ = new T(R, p, !1, D);\n      return _.errorCategory = t, _.muxCode = b.NETWORK_OFFLINE, _.data = e, _;\n    }\n    let i = \"status\" in e ? e.status : e.code,\n      c = Date.now(),\n      d = T.MEDIA_ERR_NETWORK;\n    if (i === 200) return;\n    let l = W(t),\n      u = yt(t, r),\n      y = Tt(t),\n      [m] = B((M = r.playbackId) != null ? M : \"\");\n    if (!i || !m) return;\n    let f = re(u);\n    if (u && !f) {\n      let R = x(\"The {tokenNamePrefix}-token provided is invalid or malformed.\", o).format({\n          tokenNamePrefix: l\n        }),\n        D = x(\"Compact JWT string: {token}\", o).format({\n          token: u\n        }),\n        p = new T(R, d, !0, D);\n      return p.errorCategory = t, p.muxCode = b.NETWORK_TOKEN_MALFORMED, p.data = e, p;\n    }\n    if (i >= 500) {\n      let R = new T(\"\", d, n != null ? n : !0);\n      return R.errorCategory = t, R.muxCode = b.NETWORK_UNKNOWN_ERROR, R;\n    }\n    if (i === 403) if (f) {\n      if (Ee(f, c)) {\n        let R = {\n            timeStyle: \"medium\",\n            dateStyle: \"medium\"\n          },\n          D = x(\"The video\\u2019s secured {tokenNamePrefix}-token has expired.\", o).format({\n            tokenNamePrefix: l\n          }),\n          p = x(\"Expired at: {expiredDate}. Current time: {currentDate}.\", o).format({\n            expiredDate: new Intl.DateTimeFormat(\"en\", R).format((k = f.exp) != null ? k : 0 * 1e3),\n            currentDate: new Intl.DateTimeFormat(\"en\", R).format(c)\n          }),\n          _ = new T(D, d, !0, p);\n        return _.errorCategory = t, _.muxCode = b.NETWORK_TOKEN_EXPIRED, _.data = e, _;\n      }\n      if (ge(f, m)) {\n        let R = x(\"The video\\u2019s playback ID does not match the one encoded in the {tokenNamePrefix}-token.\", o).format({\n            tokenNamePrefix: l\n          }),\n          D = x(\"Specified playback ID: {playbackId} and the playback ID encoded in the {tokenNamePrefix}-token: {tokenPlaybackId}\", o).format({\n            tokenNamePrefix: l,\n            playbackId: m,\n            tokenPlaybackId: f.sub\n          }),\n          p = new T(R, d, !0, D);\n        return p.errorCategory = t, p.muxCode = b.NETWORK_TOKEN_SUB_MISMATCH, p.data = e, p;\n      }\n      if (Me(f, y)) {\n        let R = x(\"The {tokenNamePrefix}-token is formatted with incorrect information.\", o).format({\n            tokenNamePrefix: l\n          }),\n          D = x(\"The {tokenNamePrefix}-token has no aud value. aud value should be {expectedAud}.\", o).format({\n            tokenNamePrefix: l,\n            expectedAud: y\n          }),\n          p = new T(R, d, !0, D);\n        return p.errorCategory = t, p.muxCode = b.NETWORK_TOKEN_AUD_MISSING, p.data = e, p;\n      }\n      if (xe(f, y)) {\n        let R = x(\"The {tokenNamePrefix}-token is formatted with incorrect information.\", o).format({\n            tokenNamePrefix: l\n          }),\n          D = x(\"The {tokenNamePrefix}-token has an incorrect aud value: {aud}. aud value should be {expectedAud}.\", o).format({\n            tokenNamePrefix: l,\n            expectedAud: y,\n            aud: f.aud\n          }),\n          p = new T(R, d, !0, D);\n        return p.errorCategory = t, p.muxCode = b.NETWORK_TOKEN_AUD_MISMATCH, p.data = e, p;\n      }\n    } else {\n      let R = x(\"Authorization error trying to access this {category} URL. If this is a signed URL, you might need to provide a {tokenNamePrefix}-token.\", o).format({\n          tokenNamePrefix: l,\n          category: t\n        }),\n        D = x(\"Specified playback ID: {playbackId}\", o).format({\n          playbackId: m\n        }),\n        p = new T(R, d, n != null ? n : !0, D);\n      return p.errorCategory = t, p.muxCode = b.NETWORK_TOKEN_MISSING, p.data = e, p;\n    }\n    if (i === 412) {\n      let R = x(\"This playback-id may belong to a live stream that is not currently active or an asset that is not ready.\", o),\n        D = x(\"Specified playback ID: {playbackId}\", o).format({\n          playbackId: m\n        }),\n        p = new T(R, d, n != null ? n : !0, D);\n      return p.errorCategory = t, p.muxCode = b.NETWORK_NOT_READY, p.streamType = r.streamType === h.LIVE ? \"live\" : r.streamType === h.ON_DEMAND ? \"on-demand\" : \"unknown\", p.data = e, p;\n    }\n    if (i === 404) {\n      let R = x(\"This URL or playback-id does not exist. You may have used an Asset ID or an ID from a different resource.\", o),\n        D = x(\"Specified playback ID: {playbackId}\", o).format({\n          playbackId: m\n        }),\n        p = new T(R, d, n != null ? n : !0, D);\n      return p.errorCategory = t, p.muxCode = b.NETWORK_NOT_FOUND, p.data = e, p;\n    }\n    if (i === 400) {\n      let R = x(\"The URL or playback-id was invalid. You may have used an invalid value as a playback-id.\"),\n        D = x(\"Specified playback ID: {playbackId}\", o).format({\n          playbackId: m\n        }),\n        p = new T(R, d, n != null ? n : !0, D);\n      return p.errorCategory = t, p.muxCode = b.NETWORK_INVALID_URL, p.data = e, p;\n    }\n    let g = new T(\"\", d, n != null ? n : !0);\n    return g.errorCategory = t, g.muxCode = b.NETWORK_UNKNOWN_ERROR, g.data = e, g;\n  };\nvar Oe = E.DefaultConfig.capLevelController,\n  mt = {\n    \"720p\": 921600,\n    \"1080p\": 2073600,\n    \"1440p\": 4194304,\n    \"2160p\": 8294400\n  };\nfunction Et(e) {\n  let t = e.toLowerCase().trim();\n  return mt[t];\n}\nvar N = class N extends Oe {\n  constructor(t) {\n    super(t);\n  }\n  static setMaxAutoResolution(t, r) {\n    r ? N.maxAutoResolution.set(t, r) : N.maxAutoResolution.delete(t);\n  }\n  getMaxAutoResolution() {\n    var r;\n    let t = this.hls;\n    return (r = N.maxAutoResolution.get(t)) != null ? r : void 0;\n  }\n  get levels() {\n    var t;\n    return (t = this.hls.levels) != null ? t : [];\n  }\n  getValidLevels(t) {\n    return this.levels.filter((r, n) => this.isLevelAllowed(r) && n <= t);\n  }\n  getMaxLevelCapped(t) {\n    let r = this.getValidLevels(t),\n      n = this.getMaxAutoResolution();\n    if (!n) return super.getMaxLevel(t);\n    let o = Et(n);\n    if (!o) return super.getMaxLevel(t);\n    let s = r.filter(c => c.width * c.height <= o),\n      a = s.findIndex(c => c.width * c.height === o);\n    if (a !== -1) {\n      let c = s[a];\n      return r.findIndex(d => d === c);\n    }\n    if (s.length === 0) return 0;\n    let i = s[s.length - 1];\n    return r.findIndex(c => c === i);\n  }\n  getMaxLevel(t) {\n    if (this.getMaxAutoResolution() !== void 0) return this.getMaxLevelCapped(t);\n    let r = super.getMaxLevel(t),\n      n = this.getValidLevels(t);\n    if (!n[r]) return r;\n    let o = Math.min(n[r].width, n[r].height),\n      s = N.minMaxResolution;\n    return o >= s ? r : Oe.getMaxLevelByMediaSize(n, s * (16 / 9), s);\n  }\n};\nN.minMaxResolution = 720, N.maxAutoResolution = new WeakMap();\nvar ue = N,\n  q = ue;\nvar G = {\n    FAIRPLAY: \"fairplay\",\n    PLAYREADY: \"playready\",\n    WIDEVINE: \"widevine\"\n  },\n  gt = e => {\n    if (e.includes(\"fps\")) return G.FAIRPLAY;\n    if (e.includes(\"playready\")) return G.PLAYREADY;\n    if (e.includes(\"widevine\")) return G.WIDEVINE;\n  },\n  Mt = e => {\n    let t = e.split(\"\\n\").find((r, n, o) => n && o[n - 1].startsWith(\"#EXT-X-STREAM-INF\"));\n    return fetch(t).then(r => r.status !== 200 ? Promise.reject(r) : r.text());\n  },\n  xt = e => {\n    let t = e.split(\"\\n\").filter(n => n.startsWith(\"#EXT-X-SESSION-DATA\"));\n    if (!t.length) return {};\n    let r = {};\n    for (let n of t) {\n      let o = bt(n),\n        s = o[\"DATA-ID\"];\n      s && (r[s] = _objectSpread({}, o));\n    }\n    return {\n      sessionData: r\n    };\n  },\n  Rt = /([A-Z0-9-]+)=\"?(.*?)\"?(?:,|$)/g;\nfunction bt(e) {\n  let t = [...e.matchAll(Rt)];\n  return Object.fromEntries(t.map(_ref11 => {\n    let [, r, n] = _ref11;\n    return [r, n];\n  }));\n}\nvar Dt = e => {\n    var i, c, d;\n    let t = e.split(\"\\n\"),\n      n = (c = ((i = t.find(l => l.startsWith(\"#EXT-X-PLAYLIST-TYPE\"))) != null ? i : \"\").split(\":\")[1]) == null ? void 0 : c.trim(),\n      o = ee(n),\n      s = te(n),\n      a;\n    if (o === h.LIVE) {\n      let l = t.find(y => y.startsWith(\"#EXT-X-PART-INF\"));\n      if (!!l) a = +l.split(\":\")[1].split(\"=\")[1] * 2;else {\n        let y = t.find(g => g.startsWith(\"#EXT-X-TARGETDURATION\")),\n          m = (d = y == null ? void 0 : y.split(\":\")) == null ? void 0 : d[1];\n        a = +(m != null ? m : 6) * 3;\n      }\n    }\n    return {\n      streamType: o,\n      targetLiveWindow: s,\n      liveEdgeStartOffset: a\n    };\n  },\n  Ct = async (e, t) => {\n    if (t === I.MP4) return {\n      streamType: h.ON_DEMAND,\n      targetLiveWindow: Number.NaN,\n      liveEdgeStartOffset: void 0,\n      sessionData: void 0\n    };\n    if (t === I.M3U8) {\n      let r = await fetch(e);\n      if (!r.ok) return Promise.reject(r);\n      let n = await r.text(),\n        o = await Mt(n);\n      return _objectSpread(_objectSpread({}, xt(n)), Dt(o));\n    }\n    return console.error(\"Media type \".concat(t, \" is an unrecognized or unsupported type for src \").concat(e, \".\")), {\n      streamType: void 0,\n      targetLiveWindow: void 0,\n      liveEdgeStartOffset: void 0,\n      sessionData: void 0\n    };\n  },\n  vt = async function (e, t) {\n    let r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : V({\n      src: e\n    });\n    var c, d, l, u;\n    let {\n        streamType: n,\n        targetLiveWindow: o,\n        liveEdgeStartOffset: s,\n        sessionData: a\n      } = await Ct(e, r),\n      i = a == null ? void 0 : a[\"com.apple.hls.chapters\"];\n    (i != null && i.URI || i != null && i.VALUE.toLocaleLowerCase().startsWith(\"http\")) && pe((c = i.URI) != null ? c : i.VALUE, t), ((d = P.get(t)) != null ? d : {}).liveEdgeStartOffset = s, ((l = P.get(t)) != null ? l : {}).targetLiveWindow = o, t.dispatchEvent(new CustomEvent(\"targetlivewindowchange\", {\n      composed: !0,\n      bubbles: !0\n    })), ((u = P.get(t)) != null ? u : {}).streamType = n, t.dispatchEvent(new CustomEvent(\"streamtypechange\", {\n      composed: !0,\n      bubbles: !0\n    }));\n  },\n  pe = async (e, t) => {\n    var r, n;\n    try {\n      let o = await fetch(e);\n      if (!o.ok) throw new Error(\"Failed to fetch Mux metadata: \".concat(o.status, \" \").concat(o.statusText));\n      let s = await o.json(),\n        a = {};\n      if (!((r = s == null ? void 0 : s[0]) != null && r.metadata)) return;\n      for (let c of s[0].metadata) c.key && c.value && (a[c.key] = c.value);\n      ((n = P.get(t)) != null ? n : {}).metadata = a;\n      let i = new CustomEvent(\"muxmetadata\");\n      t.dispatchEvent(i);\n    } catch (o) {\n      console.error(o);\n    }\n  },\n  Pt = e => {\n    var a;\n    let t = e.type,\n      r = ee(t),\n      n = te(t),\n      o,\n      s = !!((a = e.partList) != null && a.length);\n    return r === h.LIVE && (o = s ? e.partTarget * 2 : e.targetduration * 3), {\n      streamType: r,\n      targetLiveWindow: n,\n      liveEdgeStartOffset: o,\n      lowLatency: s\n    };\n  },\n  ht = (e, t, r) => {\n    var i, c, d, l, u, y, m, f;\n    let {\n      streamType: n,\n      targetLiveWindow: o,\n      liveEdgeStartOffset: s,\n      lowLatency: a\n    } = Pt(e);\n    if (n === h.LIVE) {\n      a ? (r.config.backBufferLength = (i = r.userConfig.backBufferLength) != null ? i : 4, r.config.maxFragLookUpTolerance = (c = r.userConfig.maxFragLookUpTolerance) != null ? c : .001, r.config.abrBandWidthUpFactor = (d = r.userConfig.abrBandWidthUpFactor) != null ? d : r.config.abrBandWidthFactor) : r.config.backBufferLength = (l = r.userConfig.backBufferLength) != null ? l : 8;\n      let g = Object.freeze({\n        get length() {\n          return t.seekable.length;\n        },\n        start(M) {\n          return t.seekable.start(M);\n        },\n        end(M) {\n          var k;\n          return M > this.length || M < 0 || Number.isFinite(t.duration) ? t.seekable.end(M) : (k = r.liveSyncPosition) != null ? k : t.seekable.end(M);\n        }\n      });\n      ((u = P.get(t)) != null ? u : {}).seekable = g;\n    }\n    ((y = P.get(t)) != null ? y : {}).liveEdgeStartOffset = s, ((m = P.get(t)) != null ? m : {}).targetLiveWindow = o, t.dispatchEvent(new CustomEvent(\"targetlivewindowchange\", {\n      composed: !0,\n      bubbles: !0\n    })), ((f = P.get(t)) != null ? f : {}).streamType = n, t.dispatchEvent(new CustomEvent(\"streamtypechange\", {\n      composed: !0,\n      bubbles: !0\n    }));\n  },\n  He,\n  Ve,\n  Be = (Ve = (He = globalThis == null ? void 0 : globalThis.navigator) == null ? void 0 : He.userAgent) != null ? Ve : \"\",\n  Ke,\n  We,\n  Ye,\n  _t = (Ye = (We = (Ke = globalThis == null ? void 0 : globalThis.navigator) == null ? void 0 : Ke.userAgentData) == null ? void 0 : We.platform) != null ? Ye : \"\",\n  kt = Be.toLowerCase().includes(\"android\") || [\"x11\", \"android\"].some(e => _t.toLowerCase().includes(e)),\n  Lt = e => /^((?!chrome|android).)*safari/i.test(Be) && !!e.canPlayType(\"application/vnd.apple.mpegurl\"),\n  P = new WeakMap(),\n  S = \"mux.com\",\n  Fe,\n  $e,\n  Je = ($e = (Fe = E).isSupported) == null ? void 0 : $e.call(Fe),\n  At = e => kt || !Lt(e),\n  jr = () => {\n    if (typeof window != \"undefined\") return le.utils.now();\n  },\n  It = le.utils.generateUUID,\n  qr = function () {\n    let {\n      playbackId: e,\n      customDomain: t = S,\n      maxResolution: r,\n      minResolution: n,\n      renditionOrder: o,\n      programStartTime: s,\n      programEndTime: a,\n      assetStartTime: i,\n      assetEndTime: c,\n      playbackToken: d,\n      tokens: {\n        playback: l = d\n      } = {},\n      extraSourceParams: u = {}\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    if (!e) return;\n    let [y, m = \"\"] = B(e),\n      f = new URL(\"https://stream.\".concat(t, \"/\").concat(y, \".m3u8\").concat(m));\n    return l || f.searchParams.has(\"token\") ? (f.searchParams.forEach((g, M) => {\n      M != \"token\" && f.searchParams.delete(M);\n    }), l && f.searchParams.set(\"token\", l)) : (r && f.searchParams.set(\"max_resolution\", r), n && (f.searchParams.set(\"min_resolution\", n), r && +r.slice(0, -1) < +n.slice(0, -1) && console.error(\"minResolution must be <= maxResolution\", \"minResolution\", n, \"maxResolution\", r)), o && f.searchParams.set(\"rendition_order\", o), s && f.searchParams.set(\"program_start_time\", \"\".concat(s)), a && f.searchParams.set(\"program_end_time\", \"\".concat(a)), i && f.searchParams.set(\"asset_start_time\", \"\".concat(i)), c && f.searchParams.set(\"asset_end_time\", \"\".concat(c)), Object.entries(u).forEach(_ref12 => {\n      let [g, M] = _ref12;\n      M != null && f.searchParams.set(g, M);\n    })), f.toString();\n  },\n  z = e => {\n    if (!e) return;\n    let [t] = e.split(\"?\");\n    return t || void 0;\n  },\n  je = e => {\n    if (!e || !e.startsWith(\"https://stream.\")) return;\n    let [t] = new URL(e).pathname.slice(1).split(/\\.m3u8|\\//);\n    return t || void 0;\n  },\n  St = e => {\n    var t, r, n;\n    return (t = e == null ? void 0 : e.metadata) != null && t.video_id ? e.metadata.video_id : Ze(e) && (n = (r = z(e.playbackId)) != null ? r : je(e.src)) != null ? n : e.src;\n  },\n  Nt = e => {\n    var t;\n    return (t = P.get(e)) == null ? void 0 : t.error;\n  },\n  Gr = e => {\n    var t;\n    return (t = P.get(e)) == null ? void 0 : t.metadata;\n  },\n  Ue = e => {\n    var t, r;\n    return (r = (t = P.get(e)) == null ? void 0 : t.streamType) != null ? r : h.UNKNOWN;\n  },\n  Xr = e => {\n    var t, r;\n    return (r = (t = P.get(e)) == null ? void 0 : t.targetLiveWindow) != null ? r : Number.NaN;\n  },\n  qe = e => {\n    var t, r;\n    return (r = (t = P.get(e)) == null ? void 0 : t.seekable) != null ? r : e.seekable;\n  },\n  zr = e => {\n    var n;\n    let t = (n = P.get(e)) == null ? void 0 : n.liveEdgeStartOffset;\n    if (typeof t != \"number\") return Number.NaN;\n    let r = qe(e);\n    return r.length ? r.end(r.length - 1) - t : Number.NaN;\n  },\n  fe = .034,\n  wt = function (e, t) {\n    let r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : fe;\n    return Math.abs(e - t) <= r;\n  },\n  Ge = function (e, t) {\n    let r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : fe;\n    return e > t || wt(e, t, r);\n  },\n  Ot = function (e) {\n    let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : fe;\n    return e.paused && Ge(e.currentTime, e.duration, t);\n  },\n  Xe = (e, t) => {\n    var d, l, u;\n    if (!t || !e.buffered.length) return;\n    if (e.readyState > 2) return !1;\n    let r = t.currentLevel >= 0 ? (l = (d = t.levels) == null ? void 0 : d[t.currentLevel]) == null ? void 0 : l.details : (u = t.levels.find(y => !!y.details)) == null ? void 0 : u.details;\n    if (!r || r.live) return;\n    let {\n      fragments: n\n    } = r;\n    if (!(n != null && n.length)) return;\n    if (e.currentTime < e.duration - (r.targetduration + .5)) return !1;\n    let o = n[n.length - 1];\n    if (e.currentTime <= o.start) return !1;\n    let s = o.start + o.duration / 2,\n      a = e.buffered.start(e.buffered.length - 1),\n      i = e.buffered.end(e.buffered.length - 1);\n    return s > a && s < i;\n  },\n  Ut = (e, t) => e.ended || e.loop ? e.ended : t && Xe(e, t) ? !0 : Ot(e),\n  Qr = (e, t, r) => {\n    Ht(t, r, e);\n    let {\n        metadata: n = {}\n      } = e,\n      {\n        view_session_id: o = It()\n      } = n,\n      s = St(e);\n    n.view_session_id = o, n.video_id = s, e.metadata = n;\n    let a = l => {\n      var u;\n      (u = t.mux) == null || u.emit(\"hb\", {\n        view_drm_type: l\n      });\n    };\n    e.drmTypeCb = a, P.set(t, {\n      retryCount: 0\n    });\n    let i = Vt(e, t),\n      c = Ce(e, t, i);\n    e != null && e.muxDataKeepSession && t != null && t.mux && !t.mux.deleted ? i && t.mux.addHLSJS({\n      hlsjs: i,\n      Hls: i ? E : void 0\n    }) : Bt(e, t, i), Jt(e, t, i), Ae(t), we(t);\n    let d = De(e, t, i);\n    return {\n      engine: i,\n      setAutoplay: d,\n      setPreload: c\n    };\n  },\n  Ht = (e, t, r) => {\n    let n = t == null ? void 0 : t.engine;\n    e != null && e.mux && !e.mux.deleted && (r != null && r.muxDataKeepSession ? n && e.mux.removeHLSJS() : (e.mux.destroy(), delete e.mux)), n && (n.detachMedia(), n.destroy()), e && (e.hasAttribute(\"src\") && (e.removeAttribute(\"src\"), e.load()), e.removeEventListener(\"error\", tt), e.removeEventListener(\"error\", de), e.removeEventListener(\"durationchange\", et), P.delete(e), e.dispatchEvent(new Event(\"teardown\")));\n  };\nfunction ze(e, t) {\n  var d;\n  let r = V(e);\n  if (!(r === I.M3U8)) return !0;\n  let o = !r || ((d = t.canPlayType(r)) != null ? d : !0),\n    {\n      preferPlayback: s\n    } = e,\n    a = s === Q.MSE,\n    i = s === Q.NATIVE,\n    c = Je && (a || At(t));\n  return o && (i || !c);\n}\nvar Vt = (e, t) => {\n    let {\n        debug: r,\n        streamType: n,\n        startTime: o = -1,\n        metadata: s,\n        preferCmcd: a,\n        _hlsConfig: i = {},\n        maxAutoResolution: c\n      } = e,\n      l = V(e) === I.M3U8,\n      u = ze(e, t);\n    if (l && !u && Je) {\n      let y = {\n          backBufferLength: 30,\n          renderTextTracksNatively: !1,\n          liveDurationInfinity: !0,\n          capLevelToPlayerSize: !0,\n          capLevelOnFPSDrop: !0\n        },\n        m = Kt(n),\n        f = Wt(e),\n        g = [w.QUERY, w.HEADER].includes(a) ? {\n          useHeaders: a === w.HEADER,\n          sessionId: s == null ? void 0 : s.view_session_id,\n          contentId: s == null ? void 0 : s.video_id\n        } : void 0,\n        M = i.capLevelToPlayerSize == null ? {\n          capLevelController: q\n        } : {},\n        k = new E(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread({\n          debug: r,\n          startPosition: o,\n          cmcd: g,\n          xhrSetup: (R, D) => {\n            var U, Te;\n            if (a && a !== w.QUERY) return;\n            let p = new URL(D);\n            if (!p.searchParams.has(\"CMCD\")) return;\n            let _ = ((Te = (U = p.searchParams.get(\"CMCD\")) == null ? void 0 : U.split(\",\")) != null ? Te : []).filter(ye => ye.startsWith(\"sid\") || ye.startsWith(\"cid\")).join(\",\");\n            p.searchParams.set(\"CMCD\", _), R.open(\"GET\", p);\n          }\n        }, M), y), m), f), i));\n      return M.capLevelController === q && c !== void 0 && q.setMaxAutoResolution(k, c), k.on(E.Events.MANIFEST_PARSED, async function (R, D) {\n        var _, U;\n        let p = (_ = D.sessionData) == null ? void 0 : _[\"com.apple.hls.chapters\"];\n        (p != null && p.URI || p != null && p.VALUE.toLocaleLowerCase().startsWith(\"http\")) && pe((U = p == null ? void 0 : p.URI) != null ? U : p == null ? void 0 : p.VALUE, t);\n      }), k;\n    }\n  },\n  Kt = e => e === h.LIVE ? {\n    backBufferLength: 8\n  } : {},\n  Wt = e => {\n    let {\n        tokens: {\n          drm: t\n        } = {},\n        playbackId: r,\n        drmTypeCb: n\n      } = e,\n      o = z(r);\n    return !t || !o ? {} : {\n      emeEnabled: !0,\n      drmSystems: {\n        \"com.apple.fps\": {\n          licenseUrl: X(e, \"fairplay\"),\n          serverCertificateUrl: Qe(e, \"fairplay\")\n        },\n        \"com.widevine.alpha\": {\n          licenseUrl: X(e, \"widevine\")\n        },\n        \"com.microsoft.playready\": {\n          licenseUrl: X(e, \"playready\")\n        }\n      },\n      requestMediaKeySystemAccessFunc: (s, a) => (s === \"com.widevine.alpha\" && (a = [...a.map(i => {\n        var d;\n        let c = (d = i.videoCapabilities) == null ? void 0 : d.map(l => _objectSpread(_objectSpread({}, l), {}, {\n          robustness: \"HW_SECURE_ALL\"\n        }));\n        return _objectSpread(_objectSpread({}, i), {}, {\n          videoCapabilities: c\n        });\n      }), ...a]), navigator.requestMediaKeySystemAccess(s, a).then(i => {\n        let c = gt(s);\n        return n == null || n(c), i;\n      }))\n    };\n  },\n  Yt = async e => {\n    let t = await fetch(e);\n    return t.status !== 200 ? Promise.reject(t) : await t.arrayBuffer();\n  },\n  Ft = async (e, t) => {\n    let r = await fetch(t, {\n      method: \"POST\",\n      headers: {\n        \"Content-type\": \"application/octet-stream\"\n      },\n      body: e\n    });\n    if (r.status !== 200) return Promise.reject(r);\n    let n = await r.arrayBuffer();\n    return new Uint8Array(n);\n  },\n  $t = (e, t) => {\n    let r = async a => {\n        let i = await navigator.requestMediaKeySystemAccess(\"com.apple.fps\", [{\n          initDataTypes: [a],\n          videoCapabilities: [{\n            contentType: \"application/vnd.apple.mpegurl\",\n            robustness: \"\"\n          }],\n          distinctiveIdentifier: \"not-allowed\",\n          persistentState: \"not-allowed\",\n          sessionTypes: [\"temporary\"]\n        }]).then(d => {\n          var l;\n          return (l = e.drmTypeCb) == null || l.call(e, G.FAIRPLAY), d;\n        }).catch(() => {\n          let d = x(\"Cannot play DRM-protected content with current security configuration on this browser. Try playing in another browser.\"),\n            l = new T(d, T.MEDIA_ERR_ENCRYPTED, !0);\n          l.errorCategory = C.DRM, l.muxCode = b.ENCRYPTED_UNSUPPORTED_KEY_SYSTEM, A(t, l);\n        });\n        if (!i) return;\n        let c = await i.createMediaKeys();\n        try {\n          let d = await Yt(Qe(e, \"fairplay\")).catch(l => {\n            if (l instanceof Response) {\n              let u = K(l, C.DRM, e);\n              return console.error(\"mediaError\", u == null ? void 0 : u.message, u == null ? void 0 : u.context), u ? Promise.reject(u) : Promise.reject(new Error(\"Unexpected error in app cert request\"));\n            }\n            return Promise.reject(l);\n          });\n          await c.setServerCertificate(d).catch(() => {\n            let l = x(\"Your server certificate failed when attempting to set it. This may be an issue with a no longer valid certificate.\"),\n              u = new T(l, T.MEDIA_ERR_ENCRYPTED, !0);\n            return u.errorCategory = C.DRM, u.muxCode = b.ENCRYPTED_UPDATE_SERVER_CERT_FAILED, Promise.reject(u);\n          });\n        } catch (d) {\n          A(t, d);\n          return;\n        }\n        await t.setMediaKeys(c);\n      },\n      n = a => {\n        let i;\n        if (a === \"internal-error\") {\n          let c = x(\"The DRM Content Decryption Module system had an internal failure. Try reloading the page, upading your browser, or playing in another browser.\");\n          i = new T(c, T.MEDIA_ERR_ENCRYPTED, !0), i.errorCategory = C.DRM, i.muxCode = b.ENCRYPTED_CDM_ERROR;\n        } else if (a === \"output-restricted\" || a === \"output-downscaled\") {\n          let c = x(\"DRM playback is being attempted in an environment that is not sufficiently secure. User may see black screen.\");\n          i = new T(c, T.MEDIA_ERR_ENCRYPTED, !1), i.errorCategory = C.DRM, i.muxCode = b.ENCRYPTED_OUTPUT_RESTRICTED;\n        }\n        i && A(t, i);\n      },\n      o = async (a, i) => {\n        let c = t.mediaKeys.createSession(),\n          d = () => {\n            c.keyStatuses.forEach(u => n(u));\n          },\n          l = async u => {\n            let y = u.message;\n            try {\n              let m = await Ft(y, X(e, \"fairplay\"));\n              try {\n                await c.update(m);\n              } catch (_unused4) {\n                let f = x(\"Failed to update DRM license. This may be an issue with the player or your protected content.\"),\n                  g = new T(f, T.MEDIA_ERR_ENCRYPTED, !0);\n                g.errorCategory = C.DRM, g.muxCode = b.ENCRYPTED_UPDATE_LICENSE_FAILED, A(t, g);\n              }\n            } catch (m) {\n              if (m instanceof Response) {\n                let f = K(m, C.DRM, e);\n                if (console.error(\"mediaError\", f == null ? void 0 : f.message, f == null ? void 0 : f.context), f) {\n                  A(t, f);\n                  return;\n                }\n                console.error(\"Unexpected error in license key request\", m);\n                return;\n              }\n              console.error(m);\n            }\n          };\n        c.addEventListener(\"keystatuseschange\", d), c.addEventListener(\"message\", l), t.addEventListener(\"teardown\", () => {\n          c.removeEventListener(\"keystatuseschange\", d), c.removeEventListener(\"message\", l), c.close();\n        }, {\n          once: !0\n        }), await c.generateRequest(a, i).catch(u => {\n          console.error(\"Failed to generate license request\", u);\n          let y = x(\"Failed to generate a DRM license request. This may be an issue with the player or your protected content.\"),\n            m = new T(y, T.MEDIA_ERR_ENCRYPTED, !0);\n          return m.errorCategory = C.DRM, m.muxCode = b.ENCRYPTED_GENERATE_REQUEST_FAILED, Promise.reject(m);\n        });\n      };\n    v(t, \"encrypted\", async a => {\n      try {\n        let i = a.initDataType;\n        if (i !== \"skd\") {\n          console.error(\"Received unexpected initialization data type \\\"\".concat(i, \"\\\"\"));\n          return;\n        }\n        t.mediaKeys || (await r(i));\n        let c = a.initData;\n        if (c == null) {\n          console.error(\"Could not start encrypted playback due to missing initData in \".concat(a.type, \" event\"));\n          return;\n        }\n        await o(i, c);\n      } catch (i) {\n        A(t, i);\n        return;\n      }\n    });\n  },\n  X = (_ref13, n) => {\n    let {\n      playbackId: e,\n      tokens: {\n        drm: t\n      } = {},\n      customDomain: r = S\n    } = _ref13;\n    let o = z(e);\n    return \"https://license.\".concat(r.toLocaleLowerCase().endsWith(S) ? r : S, \"/license/\").concat(n, \"/\").concat(o, \"?token=\").concat(t);\n  },\n  Qe = (_ref14, n) => {\n    let {\n      playbackId: e,\n      tokens: {\n        drm: t\n      } = {},\n      customDomain: r = S\n    } = _ref14;\n    let o = z(e);\n    return \"https://license.\".concat(r.toLocaleLowerCase().endsWith(S) ? r : S, \"/appcert/\").concat(n, \"/\").concat(o, \"?token=\").concat(t);\n  },\n  Ze = _ref15 => {\n    let {\n      playbackId: e,\n      src: t,\n      customDomain: r\n    } = _ref15;\n    if (e) return !0;\n    if (typeof t != \"string\") return !1;\n    let n = window == null ? void 0 : window.location.href,\n      o = new URL(t, n).hostname.toLocaleLowerCase();\n    return o.includes(S) || !!r && o.includes(r.toLocaleLowerCase());\n  },\n  Bt = (e, t, r) => {\n    var c;\n    let {\n        envKey: n,\n        disableTracking: o,\n        muxDataSDK: s = le,\n        muxDataSDKOptions: a = {}\n      } = e,\n      i = Ze(e);\n    if (!o && (n || i)) {\n      let {\n          playerInitTime: d,\n          playerSoftwareName: l,\n          playerSoftwareVersion: u,\n          beaconCollectionDomain: y,\n          debug: m,\n          disableCookies: f\n        } = e,\n        g = _objectSpread(_objectSpread({}, e.metadata), {}, {\n          video_title: ((c = e == null ? void 0 : e.metadata) == null ? void 0 : c.video_title) || void 0\n        }),\n        M = k => typeof k.player_error_code == \"string\" ? !1 : typeof e.errorTranslator == \"function\" ? e.errorTranslator(k) : k;\n      s.monitor(t, _objectSpread(_objectSpread({\n        debug: m,\n        beaconCollectionDomain: y,\n        hlsjs: r,\n        Hls: r ? E : void 0,\n        automaticErrorTracking: !1,\n        errorTranslator: M,\n        disableCookies: f\n      }, a), {}, {\n        data: _objectSpread(_objectSpread({}, n ? {\n          env_key: n\n        } : {}), {}, {\n          player_software_name: l,\n          player_software: l,\n          player_software_version: u,\n          player_init_time: d\n        }, g)\n      }));\n    }\n  },\n  Jt = (e, t, r) => {\n    var l, u;\n    let n = ze(e, t),\n      {\n        src: o,\n        customDomain: s = S\n      } = e,\n      a = () => {\n        t.ended || e.disablePseudoEnded || !Ut(t, r) || (Xe(t, r) ? t.currentTime = t.buffered.end(t.buffered.length - 1) : t.dispatchEvent(new Event(\"ended\")));\n      },\n      i,\n      c,\n      d = () => {\n        let y = qe(t),\n          m,\n          f;\n        y.length > 0 && (m = y.start(0), f = y.end(0)), (c !== f || i !== m) && t.dispatchEvent(new CustomEvent(\"seekablechange\", {\n          composed: !0\n        })), i = m, c = f;\n      };\n    if (v(t, \"durationchange\", d), t && n) {\n      let y = V(e);\n      if (typeof o == \"string\") {\n        if (o.endsWith(\".mp4\") && o.includes(s)) {\n          let g = je(o),\n            M = new URL(\"https://stream.\".concat(s, \"/\").concat(g, \"/metadata.json\"));\n          pe(M.toString(), t);\n        }\n        let m = () => {\n            if (Ue(t) !== h.LIVE || Number.isFinite(t.duration)) return;\n            let g = setInterval(d, 1e3);\n            t.addEventListener(\"teardown\", () => {\n              clearInterval(g);\n            }, {\n              once: !0\n            }), v(t, \"durationchange\", () => {\n              Number.isFinite(t.duration) && clearInterval(g);\n            });\n          },\n          f = async () => vt(o, t, y).then(m).catch(g => {\n            if (g instanceof Response) {\n              let M = K(g, C.VIDEO, e);\n              if (M) {\n                A(t, M);\n                return;\n              }\n            } else g instanceof Error;\n          });\n        if (t.preload === \"none\") {\n          let g = () => {\n              f(), t.removeEventListener(\"loadedmetadata\", M);\n            },\n            M = () => {\n              f(), t.removeEventListener(\"play\", g);\n            };\n          v(t, \"play\", g, {\n            once: !0\n          }), v(t, \"loadedmetadata\", M, {\n            once: !0\n          });\n        } else f();\n        (l = e.tokens) != null && l.drm ? $t(e, t) : v(t, \"encrypted\", () => {\n          let g = x(\"Attempting to play DRM-protected content without providing a DRM token.\"),\n            M = new T(g, T.MEDIA_ERR_ENCRYPTED, !0);\n          M.errorCategory = C.DRM, M.muxCode = b.ENCRYPTED_MISSING_TOKEN, A(t, M);\n        }, {\n          once: !0\n        }), t.setAttribute(\"src\", o), e.startTime && (((u = P.get(t)) != null ? u : {}).startTime = e.startTime, t.addEventListener(\"durationchange\", et, {\n          once: !0\n        }));\n      } else t.removeAttribute(\"src\");\n      t.addEventListener(\"error\", tt), t.addEventListener(\"error\", de), t.addEventListener(\"emptied\", () => {\n        t.querySelectorAll(\"track[data-removeondestroy]\").forEach(f => {\n          f.remove();\n        });\n      }, {\n        once: !0\n      }), v(t, \"pause\", a), v(t, \"seeked\", a), v(t, \"play\", () => {\n        t.ended || Ge(t.currentTime, t.duration) && (t.currentTime = t.seekable.length ? t.seekable.start(0) : 0);\n      });\n    } else r && o ? (r.once(E.Events.LEVEL_LOADED, (y, m) => {\n      ht(m.details, t, r), d(), Ue(t) === h.LIVE && !Number.isFinite(t.duration) && (r.on(E.Events.LEVEL_UPDATED, d), v(t, \"durationchange\", () => {\n        Number.isFinite(t.duration) && r.off(E.Events.LEVELS_UPDATED, d);\n      }));\n    }), r.on(E.Events.ERROR, (y, m) => {\n      var g, M;\n      let f = jt(m, e);\n      if (f.muxCode === b.NETWORK_NOT_READY) {\n        let R = (g = P.get(t)) != null ? g : {},\n          D = (M = R.retryCount) != null ? M : 0;\n        if (D < 6) {\n          let p = D === 0 ? 5e3 : 6e4,\n            _ = new T(\"Retrying in \".concat(p / 1e3, \" seconds...\"), f.code, f.fatal);\n          Object.assign(_, f), A(t, _), setTimeout(() => {\n            R.retryCount = D + 1, m.details === \"manifestLoadError\" && m.url && r.loadSource(m.url);\n          }, p);\n          return;\n        } else {\n          R.retryCount = 0;\n          let p = new T('Try again later or <a href=\"#\" onclick=\"window.location.reload(); return false;\" style=\"color: #4a90e2;\">click here to retry</a>', f.code, f.fatal);\n          Object.assign(p, f), A(t, p);\n          return;\n        }\n      }\n      A(t, f);\n    }), r.on(E.Events.MANIFEST_LOADED, () => {\n      let y = P.get(t);\n      y && y.error && (y.error = null, y.retryCount = 0, t.dispatchEvent(new Event(\"emptied\")), t.dispatchEvent(new Event(\"loadstart\")));\n    }), t.addEventListener(\"error\", de), v(t, \"waiting\", a), ve(e, r), Pe(t, r), r.attachMedia(t)) : console.error(\"It looks like the video you're trying to play will not work on this system! If possible, try upgrading to the newest versions of your browser or software.\");\n  };\nfunction et(e) {\n  var n;\n  let t = e.target,\n    r = (n = P.get(t)) == null ? void 0 : n.startTime;\n  if (r && me(t.seekable, t.duration, r)) {\n    let o = t.preload === \"auto\";\n    o && (t.preload = \"none\"), t.currentTime = r, o && (t.preload = \"auto\");\n  }\n}\nasync function tt(e) {\n  if (!e.isTrusted) return;\n  e.stopImmediatePropagation();\n  let t = e.target;\n  if (!(t != null && t.error)) return;\n  let {\n      message: r,\n      code: n\n    } = t.error,\n    o = new T(r, n);\n  if (t.src && n === T.MEDIA_ERR_SRC_NOT_SUPPORTED && t.readyState === HTMLMediaElement.HAVE_NOTHING) {\n    setTimeout(() => {\n      var a;\n      let s = (a = Nt(t)) != null ? a : t.error;\n      (s == null ? void 0 : s.code) === T.MEDIA_ERR_SRC_NOT_SUPPORTED && A(t, o);\n    }, 500);\n    return;\n  }\n  if (t.src && (n !== T.MEDIA_ERR_DECODE || n !== void 0)) try {\n    let {\n      status: s\n    } = await fetch(t.src);\n    o.data = {\n      response: {\n        code: s\n      }\n    };\n  } catch (_unused5) {}\n  A(t, o);\n}\nfunction A(e, t) {\n  var r;\n  t.fatal && (((r = P.get(e)) != null ? r : {}).error = t, e.dispatchEvent(new CustomEvent(\"error\", {\n    detail: t\n  })));\n}\nfunction de(e) {\n  var n, o;\n  if (!(e instanceof CustomEvent) || !(e.detail instanceof T)) return;\n  let t = e.target,\n    r = e.detail;\n  !r || !r.fatal || (((n = P.get(t)) != null ? n : {}).error = r, (o = t.mux) == null || o.emit(\"error\", {\n    player_error_code: r.code,\n    player_error_message: r.message,\n    player_error_context: r.context\n  }));\n}\nvar jt = (e, t) => {\n  var c, d, l;\n  !e.fatal ? t.debug && console.warn(\"getErrorFromHlsErrorData() (non-fatal)\", e) : console.error(\"getErrorFromHlsErrorData()\", e);\n  let n = {\n      [E.ErrorTypes.NETWORK_ERROR]: T.MEDIA_ERR_NETWORK,\n      [E.ErrorTypes.MEDIA_ERROR]: T.MEDIA_ERR_DECODE,\n      [E.ErrorTypes.KEY_SYSTEM_ERROR]: T.MEDIA_ERR_ENCRYPTED\n    },\n    o = u => [E.ErrorDetails.KEY_SYSTEM_LICENSE_REQUEST_FAILED, E.ErrorDetails.KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED].includes(u.details) ? T.MEDIA_ERR_NETWORK : n[u.type],\n    s = u => {\n      if (u.type === E.ErrorTypes.KEY_SYSTEM_ERROR) return C.DRM;\n      if (u.type === E.ErrorTypes.NETWORK_ERROR) return C.VIDEO;\n    },\n    a,\n    i = o(e);\n  if (i === T.MEDIA_ERR_NETWORK && e.response) {\n    let u = (c = s(e)) != null ? c : C.VIDEO;\n    a = (d = K(e.response, u, t, e.fatal)) != null ? d : new T(\"\", i, e.fatal);\n  } else if (i === T.MEDIA_ERR_ENCRYPTED) {\n    if (e.details === E.ErrorDetails.KEY_SYSTEM_NO_CONFIGURED_LICENSE) {\n      let u = x(\"Attempting to play DRM-protected content without providing a DRM token.\");\n      a = new T(u, T.MEDIA_ERR_ENCRYPTED, e.fatal), a.errorCategory = C.DRM, a.muxCode = b.ENCRYPTED_MISSING_TOKEN;\n    } else if (e.details === E.ErrorDetails.KEY_SYSTEM_NO_ACCESS) {\n      let u = x(\"Cannot play DRM-protected content with current security configuration on this browser. Try playing in another browser.\");\n      a = new T(u, T.MEDIA_ERR_ENCRYPTED, e.fatal), a.errorCategory = C.DRM, a.muxCode = b.ENCRYPTED_UNSUPPORTED_KEY_SYSTEM;\n    } else if (e.details === E.ErrorDetails.KEY_SYSTEM_NO_SESSION) {\n      let u = x(\"Failed to generate a DRM license request. This may be an issue with the player or your protected content.\");\n      a = new T(u, T.MEDIA_ERR_ENCRYPTED, !0), a.errorCategory = C.DRM, a.muxCode = b.ENCRYPTED_GENERATE_REQUEST_FAILED;\n    } else if (e.details === E.ErrorDetails.KEY_SYSTEM_SESSION_UPDATE_FAILED) {\n      let u = x(\"Failed to update DRM license. This may be an issue with the player or your protected content.\");\n      a = new T(u, T.MEDIA_ERR_ENCRYPTED, e.fatal), a.errorCategory = C.DRM, a.muxCode = b.ENCRYPTED_UPDATE_LICENSE_FAILED;\n    } else if (e.details === E.ErrorDetails.KEY_SYSTEM_SERVER_CERTIFICATE_UPDATE_FAILED) {\n      let u = x(\"Your server certificate failed when attempting to set it. This may be an issue with a no longer valid certificate.\");\n      a = new T(u, T.MEDIA_ERR_ENCRYPTED, e.fatal), a.errorCategory = C.DRM, a.muxCode = b.ENCRYPTED_UPDATE_SERVER_CERT_FAILED;\n    } else if (e.details === E.ErrorDetails.KEY_SYSTEM_STATUS_INTERNAL_ERROR) {\n      let u = x(\"The DRM Content Decryption Module system had an internal failure. Try reloading the page, upading your browser, or playing in another browser.\");\n      a = new T(u, T.MEDIA_ERR_ENCRYPTED, e.fatal), a.errorCategory = C.DRM, a.muxCode = b.ENCRYPTED_CDM_ERROR;\n    } else if (e.details === E.ErrorDetails.KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED) {\n      let u = x(\"DRM playback is being attempted in an environment that is not sufficiently secure. User may see black screen.\");\n      a = new T(u, T.MEDIA_ERR_ENCRYPTED, !1), a.errorCategory = C.DRM, a.muxCode = b.ENCRYPTED_OUTPUT_RESTRICTED;\n    } else a = new T(e.error.message, T.MEDIA_ERR_ENCRYPTED, e.fatal), a.errorCategory = C.DRM, a.muxCode = b.ENCRYPTED_ERROR;\n  } else a = new T(\"\", i, e.fatal);\n  return a.context || (a.context = \"\".concat(e.url ? \"url: \".concat(e.url, \"\\n\") : \"\").concat(e.response && (e.response.code || e.response.text) ? \"response: \".concat(e.response.code, \", \").concat(e.response.text, \"\\n\") : \"\").concat(e.reason ? \"failure reason: \".concat(e.reason, \"\\n\") : \"\").concat(e.level ? \"level: \".concat(e.level, \"\\n\") : \"\").concat(e.parent ? \"parent stream controller: \".concat(e.parent, \"\\n\") : \"\").concat(e.buffer ? \"buffer length: \".concat(e.buffer, \"\\n\") : \"\").concat(e.error ? \"error: \".concat(e.error, \"\\n\") : \"\").concat(e.event ? \"event: \".concat(e.event, \"\\n\") : \"\").concat(e.err ? \"error message: \".concat((l = e.err) == null ? void 0 : l.message, \"\\n\") : \"\")), a.data = e, a;\n};\nexport { Y as AutoplayTypes, zt as CmcdTypeValues, w as CmcdTypes, I as ExtensionMimeTypeMap, E as Hls, nr as MaxAutoResolution, er as MaxResolution, T as MediaError, F as MimeTypeShorthandMap, tr as MinResolution, C as MuxErrorCategory, b as MuxErrorCode, ce as MuxJWTAud, Q as PlaybackTypes, rr as RenditionOrder, h as StreamTypes, Se as addChapters, ke as addCuePoints, ae as addTextTrack, Zt as allMediaTypes, W as errorCategoryToTokenNameOrPrefix, pe as fetchAndDispatchMuxMetadata, jr as generatePlayerInitTime, It as generateUUID, Ne as getActiveChapter, Le as getActiveCuePoint, Yt as getAppCertificate, lt as getChapters, dt as getCuePoints, ft as getCurrentPdt, Wt as getDRMConfig, Ut as getEnded, Nt as getError, Ft as getLicenseKey, zr as getLiveEdgeStart, Mt as getMediaPlaylistFromMultivariantPlaylist, Gr as getMetadata, xt as getMultivariantPlaylistSessionData, qe as getSeekable, pt as getStartDate, Pt as getStreamInfoFromHlsjsLevelDetails, Dt as getStreamInfoFromPlaylist, Ct as getStreamInfoFromSrcAndType, Ue as getStreamType, Kt as getStreamTypeConfig, Xr as getTargetLiveWindow, O as getTextTrack, x as i18n, Qr as initialize, H as isKeyOf, Ze as isMuxVideoSrc, Ot as isPseudoEnded, Xe as isStuckOnLastFragment, Jt as loadMedia, le as mux, P as muxMediaState, re as parseJwt, bt as parseTagAttributes, ut as removeTextTrack, we as setupChapters, Ae as setupCuePoints, Vt as setupHls, Bt as setupMux, $t as setupNativeFairplayDRM, Qt as shorthandKeys, Ht as teardown, Qe as toAppCertURL, gt as toDRMTypeFromKeySystem, X as toLicenseKeyURL, qr as toMuxVideoURL, je as toPlaybackIdFromSrc, B as toPlaybackIdParts, ht as updateStreamInfoFromHlsjsLevelDetails, vt as updateStreamInfoFromSrc };","map":{"version":3,"names":["le","rt","E","C","VIDEO","THUMBNAIL","STORYBOARD","DRM","b","NOT_AN_ERROR","NETWORK_OFFLINE","NETWORK_UNKNOWN_ERROR","NETWORK_NO_STATUS","NETWORK_INVALID_URL","NETWORK_NOT_FOUND","NETWORK_NOT_READY","NETWORK_GENERIC_SERVER_FAIL","NETWORK_TOKEN_MISSING","NETWORK_TOKEN_MALFORMED","NETWORK_TOKEN_EXPIRED","NETWORK_TOKEN_AUD_MISSING","NETWORK_TOKEN_AUD_MISMATCH","NETWORK_TOKEN_SUB_MISMATCH","ENCRYPTED_ERROR","ENCRYPTED_UNSUPPORTED_KEY_SYSTEM","ENCRYPTED_GENERATE_REQUEST_FAILED","ENCRYPTED_UPDATE_LICENSE_FAILED","ENCRYPTED_UPDATE_SERVER_CERT_FAILED","ENCRYPTED_CDM_ERROR","ENCRYPTED_OUTPUT_RESTRICTED","ENCRYPTED_MISSING_TOKEN","W","e","L","Error","constructor","t","r","arguments","length","undefined","MEDIA_ERR_CUSTOM","n","o","s","name","code","context","fatal","MEDIA_ERR_NETWORK","MEDIA_ERR_ENCRYPTED","message","defaultMessages","MEDIA_ERR_ABORTED","MEDIA_ERR_DECODE","MEDIA_ERR_SRC_NOT_SUPPORTED","T","nt","H","isKeyOf","Y","ANY","MUTED","h","ON_DEMAND","LIVE","UNKNOWN","Q","MSE","NATIVE","w","HEADER","QUERY","NONE","zt","Object","values","I","M3U8","MP4","F","HLS","Qt","keys","Zt","er","upTo720p","upTo1080p","upTo1440p","upTo2160p","tr","noLessThan480p","noLessThan540p","noLessThan720p","noLessThan1080p","noLessThan1440p","noLessThan2160p","rr","DESCENDING","nr","ot","$","v","addEventListenerWithTeardown","addEventListener","removeEventListener","once","me","start","end","B","indexOf","slice","V","type","toUpperCase","at","ee","te","Number","POSITIVE_INFINITY","NaN","src","URL","pathname","_unused","console","error","lastIndexOf","it","st","_ref","customDomain","concat","_unused2","protocol","hostname","toLowerCase","split","a","i","includes","re","replace","decodeURIComponent","atob","map","charCodeAt","toString","join","JSON","parse","_unused3","Ee","isJWTExpired","_ref2","exp","Date","now","ge","isJWTSubMismatch","_ref3","sub","Me","isJWTAudMissing","_ref4","aud","xe","isJWTAudMismatch","_ref5","Re","x","Z","locale","format","ct","be","De","setupAutoplay","autoplay","updateHasPlayed","ne","streamType","isFinite","duration","Events","LEVEL_LOADED","d","l","u","details","live","handleSeek","startTime","liveSyncPosition","currentTime","seekable","preload","LEVEL_UPDATED","handleAutoplay","muted","restoreMuted","play","catch","Ce","setupPreload","_ref6","setAttribute","removeAttribute","config","maxBufferLength","c","maxBufferSize","y","safeLoadSource","loadSource","ve","WeakMap","on","MANIFEST_PARSED","addVideoTrack","selected","levels","entries","m","addRendition","url","width","height","videoCodec","bitrate","set","id","AUDIO_TRACKS_UPDATED","audioTracks","default","addAudioTrack","lang","enabled","find","audioTrack","LEVELS_UPDATED","videoTracks","selectedIndex","get","videoRenditions","removeRendition","target","nextLevel","removeVideoTracks","removeVideoTrack","removeAudioTracks","removeAudioTrack","removeAllMediaTracks","DESTROYING","oe","time","Pe","NON_NATIVE_TEXT_TRACKS_FOUND","_ref7","tracks","forEach","subtitleTrack","closedCaptions","subtitleTracks","findIndex","_ref8","f","label","kind","_id","ae","changeHandler","Array","from","textTracks","mode","_ref9","language","cues","addCue","CUES_PARSED","_ref0","track","getTrackById","getCueById","querySelectorAll","remove","forceHiddenTracks","querySelector","getAttribute","setTimeout","MANIFEST_LOADED","MEDIA_ATTACHED","document","createElement","srclang","append","ut","prototype","call","O","he","Promise","sort","value","endTime","VTTCue","stringify","MAX_SAFE_INTEGER","dispatchEvent","Event","bubbles","composed","se","_e","freeze","ke","J","text","dt","Le","activeCues","_ref1","Ae","CustomEvent","detail","ie","Ie","j","Se","lt","Ne","_ref10","we","pt","playingDate","getTime","getStartDate","ft","ce","Tt","yt","categoryToToken","tokens","K","getErrorFromResponse","globalThis","navigator","onLine","M","k","R","D","p","_","errorCategory","muxCode","data","status","playbackId","tokenNamePrefix","token","timeStyle","dateStyle","expiredDate","Intl","DateTimeFormat","currentDate","tokenPlaybackId","expectedAud","category","g","Oe","DefaultConfig","capLevelController","mt","Et","trim","N","setMaxAutoResolution","maxAutoResolution","delete","getMaxAutoResolution","hls","getValidLevels","filter","isLevelAllowed","getMaxLevelCapped","getMaxLevel","Math","min","minMaxResolution","getMaxLevelByMediaSize","ue","q","G","FAIRPLAY","PLAYREADY","WIDEVINE","gt","Mt","startsWith","fetch","then","reject","xt","bt","_objectSpread","sessionData","Rt","matchAll","fromEntries","_ref11","Dt","targetLiveWindow","liveEdgeStartOffset","Ct","getStreamInfoFromSrcAndType","ok","vt","updateStreamInfoFromSrc","URI","VALUE","toLocaleLowerCase","pe","P","fetchAndDispatchMuxMetadata","statusText","json","metadata","key","Pt","partList","partTarget","targetduration","lowLatency","ht","updateStreamInfoFromHlsjsLevelDetails","backBufferLength","userConfig","maxFragLookUpTolerance","abrBandWidthUpFactor","abrBandWidthFactor","He","Ve","Be","userAgent","Ke","We","Ye","_t","userAgentData","platform","kt","some","Lt","test","canPlayType","S","Fe","$e","Je","isSupported","At","jr","generatePlayerInitTime","window","utils","It","generateUUID","qr","toMuxVideoURL","maxResolution","minResolution","renditionOrder","programStartTime","programEndTime","assetStartTime","assetEndTime","playbackToken","playback","extraSourceParams","searchParams","has","_ref12","z","je","St","video_id","Ze","Nt","Gr","Ue","Xr","qe","zr","fe","wt","isApproximatelyEqual","abs","Ge","isApproximatelyGTE","Ot","isPseudoEnded","paused","Xe","isStuckOnLastFragment","buffered","readyState","currentLevel","fragments","Ut","getEnded","ended","loop","Qr","initialize","Ht","view_session_id","mux","emit","view_drm_type","drmTypeCb","retryCount","Vt","muxDataKeepSession","deleted","addHLSJS","hlsjs","Hls","Bt","Jt","engine","setAutoplay","setPreload","teardown","removeHLSJS","destroy","detachMedia","hasAttribute","load","tt","de","et","ze","preferPlayback","setupHls","debug","preferCmcd","_hlsConfig","renderTextTracksNatively","liveDurationInfinity","capLevelToPlayerSize","capLevelOnFPSDrop","Kt","Wt","useHeaders","sessionId","contentId","startPosition","cmcd","xhrSetup","U","Te","ye","open","drm","emeEnabled","drmSystems","licenseUrl","X","serverCertificateUrl","Qe","requestMediaKeySystemAccessFunc","videoCapabilities","robustness","requestMediaKeySystemAccess","Yt","arrayBuffer","Ft","getLicenseKey","method","headers","body","Uint8Array","$t","setupNativeFairplayDRM","initDataTypes","contentType","distinctiveIdentifier","persistentState","sessionTypes","A","createMediaKeys","Response","setServerCertificate","setMediaKeys","setupMediaKeySession","mediaKeys","createSession","onKeyStatusChange","keyStatuses","update","_unused4","close","generateRequest","initDataType","initData","toLicenseKeyURL","_ref13","endsWith","toAppCertURL","_ref14","_ref15","location","href","setupMux","envKey","disableTracking","muxDataSDK","muxDataSDKOptions","playerInitTime","playerSoftwareName","playerSoftwareVersion","beaconCollectionDomain","disableCookies","video_title","player_error_code","errorTranslator","monitor","automaticErrorTracking","env_key","player_software_name","player_software","player_software_version","player_init_time","loadMedia","maybeDispatchEndedCallback","disablePseudoEnded","seekableChange","setupSeekableChangePoll","setInterval","clearInterval","setupNativeStreamInfo","playHandler","loadedMetadataHandler","off","ERROR","jt","assign","attachMedia","isTrusted","stopImmediatePropagation","HTMLMediaElement","HAVE_NOTHING","response","_unused5","player_error_message","player_error_context","getErrorFromHlsErrorData","warn","ErrorTypes","NETWORK_ERROR","MEDIA_ERROR","KEY_SYSTEM_ERROR","ErrorDetails","KEY_SYSTEM_LICENSE_REQUEST_FAILED","KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED","KEY_SYSTEM_NO_CONFIGURED_LICENSE","KEY_SYSTEM_NO_ACCESS","KEY_SYSTEM_NO_SESSION","KEY_SYSTEM_SESSION_UPDATE_FAILED","KEY_SYSTEM_SERVER_CERTIFICATE_UPDATE_FAILED","KEY_SYSTEM_STATUS_INTERNAL_ERROR","KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED","reason","level","parent","buffer","event","err","AutoplayTypes","CmcdTypeValues","CmcdTypes","ExtensionMimeTypeMap","MaxAutoResolution","MaxResolution","MediaError","MimeTypeShorthandMap","MinResolution","MuxErrorCategory","MuxErrorCode","MuxJWTAud","PlaybackTypes","RenditionOrder","StreamTypes","addChapters","addCuePoints","addTextTrack","allMediaTypes","errorCategoryToTokenNameOrPrefix","getActiveChapter","getActiveCuePoint","getAppCertificate","getChapters","getCuePoints","getCurrentPdt","getDRMConfig","getError","getLiveEdgeStart","getMediaPlaylistFromMultivariantPlaylist","getMetadata","getMultivariantPlaylistSessionData","getSeekable","getStreamInfoFromHlsjsLevelDetails","getStreamInfoFromPlaylist","getStreamType","getStreamTypeConfig","getTargetLiveWindow","getTextTrack","i18n","isMuxVideoSrc","muxMediaState","parseJwt","parseTagAttributes","removeTextTrack","setupChapters","setupCuePoints","shorthandKeys","toDRMTypeFromKeySystem","toPlaybackIdFromSrc","toPlaybackIdParts"],"sources":["/app/frontend/node_modules/@mux/playback-core/src/index.ts","/app/frontend/node_modules/@mux/playback-core/src/hls.ts","/app/frontend/node_modules/@mux/playback-core/src/errors.ts","/app/frontend/node_modules/@mux/playback-core/src/types.ts","/app/frontend/node_modules/@mux/playback-core/lang/en.json","/app/frontend/node_modules/@mux/playback-core/src/util.ts","/app/frontend/node_modules/@mux/playback-core/src/autoplay.ts","/app/frontend/node_modules/@mux/playback-core/src/preload.ts","/app/frontend/node_modules/@mux/playback-core/src/media-tracks.ts","/app/frontend/node_modules/@mux/playback-core/src/text-tracks.ts","/app/frontend/node_modules/@mux/playback-core/src/pdt.ts","/app/frontend/node_modules/@mux/playback-core/src/request-errors.ts","/app/frontend/node_modules/@mux/playback-core/src/min-cap-level-controller.ts"],"sourcesContent":["import type { ValueOf, PlaybackCore, MuxMediaProps, MuxMediaPropsInternal, MuxMediaPropTypes } from './types';\nimport mux, { ErrorEvent } from 'mux-embed';\nimport Hls from './hls';\nimport type { HlsInterface } from './hls';\nimport type { ErrorData, HlsConfig } from 'hls.js';\nimport { MediaError, MuxErrorCategory, MuxErrorCode, errorCategoryToTokenNameOrPrefix } from './errors';\nimport { setupAutoplay } from './autoplay';\nimport { setupPreload } from './preload';\nimport { setupMediaTracks } from './media-tracks';\nimport {\n  setupTextTracks,\n  addTextTrack,\n  removeTextTrack,\n  getTextTrack,\n  addCuePoints,\n  getCuePoints,\n  getActiveCuePoint,\n  setupCuePoints,\n  addChapters,\n  getChapters,\n  getActiveChapter,\n  setupChapters,\n} from './text-tracks';\nimport { getStartDate, getCurrentPdt } from './pdt';\nimport {\n  inSeekableRange,\n  toPlaybackIdParts,\n  getType,\n  toStreamTypeFromPlaylistType,\n  toTargetLiveWindowFromPlaylistType,\n  addEventListenerWithTeardown,\n  i18n,\n  parseJwt,\n} from './util';\nimport { StreamTypes, PlaybackTypes, ExtensionMimeTypeMap, CmcdTypes, HlsPlaylistTypes, MediaTypes } from './types';\nimport { getErrorFromResponse, MuxJWTAud } from './request-errors';\nimport MinCapLevelController from './min-cap-level-controller';\n// import { MediaKeySessionContext } from 'hls.js';\nexport {\n  mux,\n  Hls,\n  MediaError,\n  MuxErrorCategory,\n  MuxErrorCode,\n  errorCategoryToTokenNameOrPrefix,\n  MuxJWTAud,\n  addTextTrack,\n  removeTextTrack,\n  getTextTrack,\n  addCuePoints,\n  getCuePoints,\n  getActiveCuePoint,\n  setupCuePoints,\n  addChapters,\n  getChapters,\n  getActiveChapter,\n  setupChapters,\n  getStartDate,\n  getCurrentPdt,\n  toPlaybackIdParts,\n  i18n,\n  parseJwt,\n};\nexport * from './types';\n\nconst DRMType = {\n  FAIRPLAY: 'fairplay',\n  PLAYREADY: 'playready',\n  WIDEVINE: 'widevine',\n} as const;\n\ntype DRMTypeValue = (typeof DRMType)[keyof typeof DRMType];\nexport const toDRMTypeFromKeySystem = (keySystem: string): DRMTypeValue | undefined => {\n  if (keySystem.includes('fps')) return DRMType.FAIRPLAY;\n  if (keySystem.includes('playready')) return DRMType.PLAYREADY;\n  if (keySystem.includes('widevine')) return DRMType.WIDEVINE;\n  return undefined;\n};\n\nexport const getMediaPlaylistFromMultivariantPlaylist = (multivariantPlaylist: string) => {\n  const mediaPlaylistUrl = multivariantPlaylist.split('\\n').find((_line, idx, lines) => {\n    return idx && lines[idx - 1].startsWith('#EXT-X-STREAM-INF');\n  }) as string;\n\n  return fetch(mediaPlaylistUrl).then((resp) => {\n    if (resp.status !== 200) {\n      return Promise.reject(resp);\n    }\n    return resp.text();\n  });\n};\n\nexport const getMultivariantPlaylistSessionData = (playlist: string) => {\n  // See https://datatracker.ietf.org/doc/html/draft-pantos-hls-rfc8216bis-12#section-4.4.6.4\n  const sessionDataLines = playlist.split('\\n').filter((line) => line.startsWith('#EXT-X-SESSION-DATA'));\n  if (!sessionDataLines.length) return {};\n\n  const sessionData: Record<string, Record<string, string>> = {};\n\n  for (const line of sessionDataLines) {\n    const sessionDataAttrs = parseTagAttributes(line);\n    const dataId = sessionDataAttrs['DATA-ID'];\n    if (!dataId) continue;\n\n    sessionData[dataId] = { ...sessionDataAttrs };\n  }\n\n  return {\n    sessionData,\n  };\n};\n\n// matches all HLS attribute name=value pairs, with or without quotes, using per spec rules\n// for matching AttributeName (See: https://datatracker.ietf.org/doc/html/draft-pantos-hls-rfc8216bis-17#section-4.2)\nconst ATTR_LIST_REGEX = /([A-Z0-9-]+)=\"?(.*?)\"?(?:,|$)/g;\nexport function parseTagAttributes(str: string) {\n  const matches = [...str.matchAll(ATTR_LIST_REGEX)];\n  return Object.fromEntries(matches.map(([, key, value]) => [key, value]));\n}\n\nexport const getStreamInfoFromPlaylist = (playlist: string) => {\n  const playlistLines = playlist.split('\\n');\n  const typeLine = playlistLines.find((line) => line.startsWith('#EXT-X-PLAYLIST-TYPE')) ?? '';\n  const playlistType = typeLine.split(':')[1]?.trim() as HlsPlaylistTypes;\n  const streamType = toStreamTypeFromPlaylistType(playlistType);\n  const targetLiveWindow = toTargetLiveWindowFromPlaylistType(playlistType);\n\n  // Computation of the live edge start offset per media-ui-extensions proposal. See: https://github.com/video-dev/media-ui-extensions/blob/main/proposals/0007-live-edge.md#recommended-computation-for-rfc8216bis12-aka-hls (CJP)\n  let liveEdgeStartOffset = undefined;\n\n  if (streamType === StreamTypes.LIVE) {\n    // Required if playlist contains one or more EXT-X-PART tags. See: https://datatracker.ietf.org/doc/html/draft-pantos-hls-rfc8216bis-12#section-4.4.3.7 (CJP)\n    const partInfLine = playlistLines.find((line) => line.startsWith('#EXT-X-PART-INF'));\n    const lowLatency = !!partInfLine;\n\n    if (lowLatency) {\n      // The EXT-X-PART-INF only has one in-spec named attribute, PART-TARGET, which is required,\n      // so parsing & casting presumptuously here. See spec link above for more info. (CJP)\n      const partTarget = +partInfLine.split(':')[1].split('=')[1];\n      liveEdgeStartOffset = partTarget * 2;\n    } else {\n      // This is required for all media playlists. See: https://datatracker.ietf.org/doc/html/draft-pantos-hls-rfc8216bis-12#section-4.4.3.1 (CJP)\n      const targetDurationLine = playlistLines.find((line) => line.startsWith('#EXT-X-TARGETDURATION')) as string;\n      // EXT-X-TARGETDURATION has exactly one unnamed attribute that represents the target duration value, which is required,\n      // so parsing and casting presumptuously here. See spec link above for more info. (CJP)\n      const targetDurationValue = targetDurationLine?.split(':')?.[1];\n      // NOTE: Defaulting here and using optional chaining above since some people are seeing RTEs on iPhones under edge cases.\n      // Identifying root cause would be ideal, but this will at least avoid the RTE. (CJP)\n      const targetDuration = +(targetDurationValue ?? 6);\n      liveEdgeStartOffset = targetDuration * 3;\n    }\n  }\n\n  return {\n    streamType,\n    targetLiveWindow,\n    liveEdgeStartOffset,\n  };\n};\n\nexport const getStreamInfoFromSrcAndType = async (src: string, type?: MediaTypes | '') => {\n  if (type === ExtensionMimeTypeMap.MP4) {\n    return {\n      streamType: StreamTypes.ON_DEMAND,\n      targetLiveWindow: Number.NaN,\n      liveEdgeStartOffset: undefined,\n      sessionData: undefined,\n    };\n  }\n\n  if (type === ExtensionMimeTypeMap.M3U8) {\n    const multivariantPlaylistResponse = await fetch(src);\n    if (!multivariantPlaylistResponse.ok) {\n      return Promise.reject(multivariantPlaylistResponse);\n    }\n    const multivariantPlaylist = await multivariantPlaylistResponse.text();\n    const mediaPlaylist = await getMediaPlaylistFromMultivariantPlaylist(multivariantPlaylist);\n    return {\n      ...getMultivariantPlaylistSessionData(multivariantPlaylist),\n      ...getStreamInfoFromPlaylist(mediaPlaylist),\n    };\n  }\n\n  // Unknown or undefined type.\n  console.error(`Media type ${type} is an unrecognized or unsupported type for src ${src}.`);\n  return {\n    streamType: undefined,\n    targetLiveWindow: undefined,\n    liveEdgeStartOffset: undefined,\n    sessionData: undefined,\n  };\n};\n\nexport const updateStreamInfoFromSrc = async (\n  src: string,\n  mediaEl: HTMLMediaElement,\n  type: MediaTypes | '' = getType({ src })\n) => {\n  const { streamType, targetLiveWindow, liveEdgeStartOffset, sessionData } = await getStreamInfoFromSrcAndType(\n    src,\n    type\n  );\n\n  const metadata = sessionData?.['com.apple.hls.chapters' as keyof typeof sessionData];\n  if (metadata?.URI || metadata?.VALUE.toLocaleLowerCase().startsWith('http')) {\n    // NOTE: data identified by DATA-ID 'com.apple.hls.chapters' is expected to provide its value\n    // via a remote JSON source identified by the URI attribute. Providing VALUE as a fallback.\n    // For more, see:\n    // https://developer.apple.com/documentation/http-live-streaming/providing-javascript-object-notation-json-chapters#Specify-a-main-playlist\n    fetchAndDispatchMuxMetadata(metadata.URI ?? metadata.VALUE, mediaEl);\n  }\n\n  (muxMediaState.get(mediaEl) ?? {}).liveEdgeStartOffset = liveEdgeStartOffset;\n\n  (muxMediaState.get(mediaEl) ?? {}).targetLiveWindow = targetLiveWindow;\n  mediaEl.dispatchEvent(new CustomEvent('targetlivewindowchange', { composed: true, bubbles: true }));\n\n  (muxMediaState.get(mediaEl) ?? {}).streamType = streamType;\n  mediaEl.dispatchEvent(new CustomEvent('streamtypechange', { composed: true, bubbles: true }));\n};\n\nexport const fetchAndDispatchMuxMetadata = async (metadataUrl: string, mediaEl: HTMLMediaElement) => {\n  try {\n    const resp = await fetch(metadataUrl);\n    if (!resp.ok) {\n      throw new Error(`Failed to fetch Mux metadata: ${resp.status} ${resp.statusText}`);\n    }\n\n    const json = await resp.json();\n    const metadata: Record<string, string> = {};\n\n    if (!json?.[0]?.metadata) return;\n\n    for (const item of json[0].metadata) {\n      if (item.key && item.value) {\n        metadata[item.key] = item.value;\n      }\n    }\n\n    (muxMediaState.get(mediaEl) ?? {}).metadata = metadata;\n\n    const eventUpdateMetadata = new CustomEvent('muxmetadata');\n    mediaEl.dispatchEvent(eventUpdateMetadata);\n  } catch (error) {\n    console.error(error);\n  }\n};\n\nexport const getStreamInfoFromHlsjsLevelDetails = (levelDetails: any) => {\n  const playlistType: HlsPlaylistTypes = levelDetails.type as HlsPlaylistTypes;\n\n  const streamType = toStreamTypeFromPlaylistType(playlistType);\n  const targetLiveWindow = toTargetLiveWindowFromPlaylistType(playlistType);\n  let liveEdgeStartOffset = undefined;\n  const lowLatency = !!levelDetails.partList?.length;\n  if (streamType === StreamTypes.LIVE) {\n    liveEdgeStartOffset = lowLatency ? levelDetails.partTarget * 2 : levelDetails.targetduration * 3;\n  }\n\n  return {\n    streamType,\n    targetLiveWindow,\n    liveEdgeStartOffset,\n    lowLatency,\n  };\n};\n\nexport const updateStreamInfoFromHlsjsLevelDetails = (\n  levelDetails: any,\n  mediaEl: HTMLMediaElement,\n  hls: Pick<Hls, 'config' | 'userConfig' | 'liveSyncPosition'>\n) => {\n  const { streamType, targetLiveWindow, liveEdgeStartOffset, lowLatency } =\n    getStreamInfoFromHlsjsLevelDetails(levelDetails);\n\n  if (streamType === StreamTypes.LIVE) {\n    // Update hls.js config for live/ll-live\n    if (lowLatency) {\n      hls.config.backBufferLength = hls.userConfig.backBufferLength ?? 4;\n      hls.config.maxFragLookUpTolerance = hls.userConfig.maxFragLookUpTolerance ?? 0.001;\n      // For ll-hls, ensure that up switches are weighted the same as down switches to mitigate\n      // cases of getting stuck at lower bitrates.\n      hls.config.abrBandWidthUpFactor = hls.userConfig.abrBandWidthUpFactor ?? hls.config.abrBandWidthFactor;\n    } else {\n      hls.config.backBufferLength = hls.userConfig.backBufferLength ?? 8;\n    }\n\n    // Proxy `seekable.end()` to constrain based on rules in\n    // https://github.com/video-dev/media-ui-extensions/blob/main/proposals/0007-live-edge.md#property-constraint-on-htmlmediaelementseekableend-to-model-seekable-live-edge\n    const seekable: TimeRanges = Object.freeze({\n      get length() {\n        return mediaEl.seekable.length;\n      },\n      start(index: number) {\n        return mediaEl.seekable.start(index);\n      },\n      end(index: number) {\n        // Defer to native seekable for:\n        // 1) \"out of range\" cases\n        // 2) \"finite duration\" media (whether live/\"DVR\" that has ended or on demand)\n        if (index > this.length || index < 0 || Number.isFinite(mediaEl.duration)) return mediaEl.seekable.end(index);\n        // Otherwise rely on the live sync position (but still fall back to native seekable when nullish)\n        return hls.liveSyncPosition ?? mediaEl.seekable.end(index);\n      },\n    });\n    (muxMediaState.get(mediaEl) ?? {}).seekable = seekable;\n  }\n\n  (muxMediaState.get(mediaEl) ?? {}).liveEdgeStartOffset = liveEdgeStartOffset;\n\n  (muxMediaState.get(mediaEl) ?? {}).targetLiveWindow = targetLiveWindow;\n  mediaEl.dispatchEvent(new CustomEvent('targetlivewindowchange', { composed: true, bubbles: true }));\n\n  (muxMediaState.get(mediaEl) ?? {}).streamType = streamType;\n  mediaEl.dispatchEvent(new CustomEvent('streamtypechange', { composed: true, bubbles: true }));\n};\n\ndeclare global {\n  interface NavigatorUAData {\n    platform: string;\n    mobile: boolean;\n    brands: Array<{ brand: string; version: string }>;\n  }\n\n  interface Navigator {\n    userAgentData?: NavigatorUAData;\n  }\n}\n\nconst userAgentStr = globalThis?.navigator?.userAgent ?? '';\nconst userAgentPlatform = globalThis?.navigator?.userAgentData?.platform ?? '';\n\n// NOTE: Our primary *goal* with this is to detect \"non-Apple-OS\" platforms which may also support\n// native HLS playback. Our primary concern with any check for this is \"false negatives\" where we\n// identify an \"Apple-OS\" as a \"non-Apple-OS\". As such, instead of having logic to attempt to identify\n// \"!isAppleOS\", we opt to target known platforms that can support both native playback and MSE/hls.js.\n// For now, these are \"Android or Android-like\" platforms. If we end up matching platforms other than\n// Android (or e.g. forks thereof), this is fine so long as it doesn't include Apple-OS platforms.\n// Below are two strategies:\n// 1. UA string parsing - here, we're extra cautious to only match if the UA string explicitly includes 'android'.\n//   This is prone to false negatives (aka \"Android or Android-like\" platforms that yield false), since\n//   detection using UA strings is intentionally and notoriously unreliable (See: https://developer.mozilla.org/en-US/docs/Web/HTTP/Browser_detection_using_the_user_agent)\n//   and Google is even officially attempting to lock this down even more for security and privacy reasons\n//   (See: https://developers.google.com/privacy-sandbox/blog/user-agent-reduction-android-model-and-version)\n// 2. userAgentData.platform checking - here, we're matching either 'android' or 'x11', and could add more matches in the future\n//    While still prone to false negatives, we can be a bit more aggressive with matches here for a few reasons.\n//    First, navigator.userAgentData is still experimental, is only supported on a subset of Chromium browsers,\n//    and neither Mozilla nor Webkit have even established an official browser support position. In other words,\n//    Apple-OS Safari and even other Apple-OS browsers (including Chrome) will typically not even support this\n//    feature, and, if and when they do, the purpose of this new API is to avoid obfuscatory information, so\n//    we should be able to better trust userAgentData.platform to not result in erroneous matches.\nconst isAndroidLike =\n  userAgentStr.toLowerCase().includes('android') ||\n  ['x11', 'android'].some((platformStr) => userAgentPlatform.toLowerCase().includes(platformStr));\n\nconst isSafari = (mediaEl: Pick<HTMLMediaElement, 'canPlayType'>) =>\n  /^((?!chrome|android).)*safari/i.test(userAgentStr) && !!mediaEl.canPlayType('application/vnd.apple.mpegurl');\n\n// NOTE: Exporting for testing\nexport const muxMediaState: WeakMap<\n  HTMLMediaElement,\n  Partial<MuxMediaProps> & { seekable?: TimeRanges; liveEdgeStartOffset?: number; retryCount?: number }\n> = new WeakMap();\n\nconst MUX_VIDEO_DOMAIN = 'mux.com';\nconst MSE_SUPPORTED = Hls.isSupported?.();\n\nconst shouldDefaultToMSE = (mediaEl: Pick<HTMLMediaElement, 'canPlayType'>) => isAndroidLike || !isSafari(mediaEl);\n\nexport const generatePlayerInitTime = () => {\n  // bail during SSR to avoid triggering prerender errors\n  // actual time will be generated during hydration\n  if (typeof window === 'undefined') return undefined;\n\n  return mux.utils.now();\n};\n\nexport const generateUUID = mux.utils.generateUUID;\n\ntype MuxVideoURLProps = Partial<\n  Pick<\n    MuxMediaPropTypes,\n    | 'playbackId'\n    | 'customDomain'\n    | 'maxResolution'\n    | 'minResolution'\n    | 'renditionOrder'\n    | 'programStartTime'\n    | 'programEndTime'\n    | 'assetStartTime'\n    | 'assetEndTime'\n    | 'tokens'\n    | 'playbackToken'\n    | 'extraSourceParams'\n  >\n>;\n\nexport const toMuxVideoURL = ({\n  playbackId: playbackIdWithParams,\n  customDomain: domain = MUX_VIDEO_DOMAIN,\n  maxResolution,\n  minResolution,\n  renditionOrder,\n  programStartTime,\n  programEndTime,\n  assetStartTime,\n  assetEndTime,\n  // Normalizes different ways of providing playback token\n  playbackToken,\n  tokens: { playback: token = playbackToken } = {},\n  extraSourceParams = {},\n}: MuxVideoURLProps = {}) => {\n  if (!playbackIdWithParams) return undefined;\n  // Normalizes different ways of providing playback id\n  const [playbackId, queryPart = ''] = toPlaybackIdParts(playbackIdWithParams);\n  const url = new URL(`https://stream.${domain}/${playbackId}.m3u8${queryPart}`);\n  /*\n   * All identified query params here can only be added to public\n   * playback IDs. In order to use these features with signed URLs\n   * the query param must be added to the signing token.\n   *\n   * */\n  if (token || url.searchParams.has('token')) {\n    url.searchParams.forEach((_, key) => {\n      if (key != 'token') url.searchParams.delete(key);\n    });\n    if (token) url.searchParams.set('token', token);\n  } else {\n    if (maxResolution) {\n      url.searchParams.set('max_resolution', maxResolution);\n    }\n    if (minResolution) {\n      url.searchParams.set('min_resolution', minResolution);\n      if (maxResolution && +maxResolution.slice(0, -1) < +minResolution.slice(0, -1)) {\n        console.error(\n          'minResolution must be <= maxResolution',\n          'minResolution',\n          minResolution,\n          'maxResolution',\n          maxResolution\n        );\n      }\n    }\n    if (renditionOrder) {\n      url.searchParams.set('rendition_order', renditionOrder);\n    }\n    if (programStartTime) {\n      url.searchParams.set('program_start_time', `${programStartTime}`);\n    }\n    if (programEndTime) {\n      url.searchParams.set('program_end_time', `${programEndTime}`);\n    }\n    if (assetStartTime) {\n      url.searchParams.set('asset_start_time', `${assetStartTime}`);\n    }\n    if (assetEndTime) {\n      url.searchParams.set('asset_end_time', `${assetEndTime}`);\n    }\n    Object.entries(extraSourceParams).forEach(([k, v]) => {\n      if (v == undefined) return;\n      url.searchParams.set(k, v);\n    });\n  }\n  return url.toString();\n};\n\nconst toPlaybackIdFromParameterized = (playbackIdWithParams: string | undefined) => {\n  if (!playbackIdWithParams) return undefined;\n  const [playbackId] = playbackIdWithParams.split('?');\n  // `|| undefined` is here to handle potential invalid cases\n  return playbackId || undefined;\n};\n\nexport const toPlaybackIdFromSrc = (src: string | undefined) => {\n  if (!src || !src.startsWith('https://stream.')) return undefined;\n  const [playbackId] = new URL(src).pathname.slice(1).split(/\\.m3u8|\\//);\n  // `|| undefined` is here to handle potential invalid cases\n  return playbackId || undefined;\n};\n\nconst toVideoId = (props: Partial<MuxMediaPropsInternal>) => {\n  if (props?.metadata?.video_id) return props.metadata.video_id;\n  if (!isMuxVideoSrc(props)) return props.src;\n  return toPlaybackIdFromParameterized(props.playbackId) ?? toPlaybackIdFromSrc(props.src) ?? props.src;\n};\n\nexport const getError = (mediaEl: HTMLMediaElement) => {\n  return muxMediaState.get(mediaEl)?.error;\n};\n\nexport const getMetadata = (mediaEl: HTMLMediaElement) => {\n  return muxMediaState.get(mediaEl)?.metadata;\n};\n\nexport const getStreamType = (mediaEl: HTMLMediaElement) => {\n  return muxMediaState.get(mediaEl)?.streamType ?? StreamTypes.UNKNOWN;\n};\n\nexport const getTargetLiveWindow = (mediaEl: HTMLMediaElement) => {\n  return muxMediaState.get(mediaEl)?.targetLiveWindow ?? Number.NaN;\n};\n\nexport const getSeekable = (mediaEl: HTMLMediaElement) => {\n  return muxMediaState.get(mediaEl)?.seekable ?? mediaEl.seekable;\n};\n\nexport const getLiveEdgeStart = (mediaEl: HTMLMediaElement) => {\n  const liveEdgeStartOffset = muxMediaState.get(mediaEl)?.liveEdgeStartOffset;\n  if (typeof liveEdgeStartOffset !== 'number') return Number.NaN;\n  const seekable = getSeekable(mediaEl);\n  // We aren't guaranteed that seekable is ready before invoking this, so handle that case.\n  if (!seekable.length) return Number.NaN;\n  return seekable.end(seekable.length - 1) - liveEdgeStartOffset;\n};\n\nconst DEFAULT_ENDED_MOE = 0.034;\n\nconst isApproximatelyEqual = (x: number, y: number, moe = DEFAULT_ENDED_MOE) => Math.abs(x - y) <= moe;\nconst isApproximatelyGTE = (x: number, y: number, moe = DEFAULT_ENDED_MOE) => x > y || isApproximatelyEqual(x, y, moe);\n\nexport const isPseudoEnded = (mediaEl: HTMLMediaElement, moe = DEFAULT_ENDED_MOE) => {\n  return mediaEl.paused && isApproximatelyGTE(mediaEl.currentTime, mediaEl.duration, moe);\n};\n\nexport const isStuckOnLastFragment = (\n  mediaEl: HTMLMediaElement,\n  hls?: Pick<\n    Hls,\n    /** Should we add audio fragments logic here, too? (CJP) */\n    // | 'audioTrack'\n    // | 'audioTracks'\n    'levels' | 'currentLevel'\n  >\n) => {\n  if (!hls || !mediaEl.buffered.length) return undefined;\n  if (mediaEl.readyState > 2) return false;\n  const videoLevelDetails =\n    hls.currentLevel >= 0\n      ? hls.levels?.[hls.currentLevel]?.details\n      : hls.levels.find((level) => !!level.details)?.details;\n\n  // Don't define for live streams (for now).\n  if (!videoLevelDetails || videoLevelDetails.live) return undefined;\n\n  const { fragments } = videoLevelDetails;\n\n  // Don't give a definitive true|false before we have no fragments (for now).\n  if (!fragments?.length) return undefined;\n\n  // Do a cheap check up front to see if we're close to the end.\n  // For more on TARGET_DURATION, see https://datatracker.ietf.org/doc/html/draft-pantos-hls-rfc8216bis-14#section-4.4.3.1 (CJP)\n  if (mediaEl.currentTime < mediaEl.duration - (videoLevelDetails.targetduration + 0.5)) return false;\n\n  const lastFragment = fragments[fragments.length - 1];\n\n  // We're not yet playing the last fragment, so we can't be stuck on it.\n  if (mediaEl.currentTime <= lastFragment.start) return false;\n\n  const lastFragmentMidpoint = lastFragment.start + lastFragment.duration / 2;\n  const lastBufferedStart = mediaEl.buffered.start(mediaEl.buffered.length - 1);\n  const lastBufferedEnd = mediaEl.buffered.end(mediaEl.buffered.length - 1);\n\n  // True if we've already buffered (half of) the last fragment\n  const lastFragmentInBuffer = lastFragmentMidpoint > lastBufferedStart && lastFragmentMidpoint < lastBufferedEnd;\n  // If we haven't buffered half already, assume we're still waiting to fetch+buffer the fragment, otherwise,\n  // since we already checked the ready state, this means we're stuck on the last segment, and should pretend we're ended!\n  return lastFragmentInBuffer;\n};\n\nexport const getEnded = (\n  mediaEl: HTMLMediaElement,\n  hls?: Pick<\n    Hls,\n    /** Should we add audio fragments logic here, too? (CJP) */\n    // | 'audioTrack'\n    // | 'audioTracks'\n    'levels' | 'currentLevel'\n  >\n) => {\n  // Since looping media never truly ends, don't apply pseudo-ended logic\n  // Also, trust when the HTMLMediaElement says we have ended (only apply pseudo-ended logic when it reports false)\n  if (mediaEl.ended || mediaEl.loop) return mediaEl.ended;\n  // Externalize conversion to boolean for \"under-determined cases\" here (See isStuckOnLastFragment() for details)\n  if (hls && !!isStuckOnLastFragment(mediaEl, hls)) return true;\n  return isPseudoEnded(mediaEl);\n};\n\nexport const initialize = (props: Partial<MuxMediaPropsInternal>, mediaEl: HTMLMediaElement, core?: PlaybackCore) => {\n  // Automatically tear down previously initialized mux data & hls instance if it exists.\n  teardown(mediaEl, core, props);\n  // NOTE: metadata should never be nullish/nil. Adding here for type safety due to current type defs.\n  const { metadata = {} } = props;\n  const { view_session_id = generateUUID() } = metadata;\n  const video_id = toVideoId(props);\n  metadata.view_session_id = view_session_id;\n  metadata.video_id = video_id;\n  props.metadata = metadata;\n\n  // Used to signal DRM Type to Mux Data. See, e.g. `getDRMConfig()`\n  const drmTypeCb = (drmType?: string) => {\n    mediaEl.mux?.emit('hb', { view_drm_type: drmType });\n  };\n\n  props.drmTypeCb = drmTypeCb;\n\n  muxMediaState.set(mediaEl as HTMLMediaElement, { retryCount: 0 });\n  const nextHlsInstance = setupHls(props, mediaEl);\n  const setPreload = setupPreload(props as Pick<MuxMediaProps, 'preload' | 'src'>, mediaEl, nextHlsInstance);\n\n  if (props?.muxDataKeepSession && mediaEl?.mux && !mediaEl.mux.deleted) {\n    if (nextHlsInstance) {\n      mediaEl.mux.addHLSJS({\n        hlsjs: nextHlsInstance as HlsInterface,\n        Hls: nextHlsInstance ? Hls : undefined,\n      });\n    }\n  } else {\n    setupMux(props, mediaEl, nextHlsInstance);\n  }\n\n  loadMedia(props, mediaEl, nextHlsInstance);\n  setupCuePoints(mediaEl);\n  setupChapters(mediaEl);\n  const setAutoplay = setupAutoplay(props as Pick<MuxMediaProps, 'autoplay'>, mediaEl, nextHlsInstance);\n\n  return {\n    engine: nextHlsInstance,\n    setAutoplay,\n    setPreload,\n  };\n};\n\nexport const teardown = (\n  mediaEl?: HTMLMediaElement | null,\n  core?: PlaybackCore,\n  props?: Partial<MuxMediaPropsInternal>\n) => {\n  const hls = core?.engine;\n\n  if (mediaEl?.mux && !mediaEl.mux.deleted) {\n    if (props?.muxDataKeepSession) {\n      if (hls) mediaEl.mux.removeHLSJS();\n    } else {\n      mediaEl.mux.destroy();\n      delete mediaEl.mux;\n    }\n  }\n\n  if (hls) {\n    hls.detachMedia();\n    hls.destroy();\n  }\n\n  if (mediaEl) {\n    if (mediaEl.hasAttribute('src')) {\n      mediaEl.removeAttribute('src');\n      mediaEl.load();\n    }\n    mediaEl.removeEventListener('error', handleNativeError);\n    mediaEl.removeEventListener('error', handleInternalError);\n    mediaEl.removeEventListener('durationchange', seekInSeekableRange);\n    muxMediaState.delete(mediaEl);\n    mediaEl.dispatchEvent(new Event('teardown'));\n  }\n};\n\n/**\n * Returns true if we should use native playback. e.g. progressive files (mp3, mp4, webm) or native HLS on Safari.\n * We should use native playback for hls media sources if we\n *\n *   a) can use native playback (excluding Android, it's MSE by default)\n *   b) not prefer to use MSE/hls.js if it's supported\n */\nfunction useNative(\n  props: Partial<Pick<MuxMediaProps, 'preferPlayback' | 'type'>>,\n  mediaEl: Pick<HTMLMediaElement, 'canPlayType'>\n) {\n  const type = getType(props);\n  const hlsType = type === ExtensionMimeTypeMap.M3U8;\n  if (!hlsType) return true;\n\n  const canUseNative = !type || (mediaEl.canPlayType(type) ?? true);\n  const { preferPlayback } = props;\n\n  const preferMse = preferPlayback === PlaybackTypes.MSE;\n  const preferNative = preferPlayback === PlaybackTypes.NATIVE;\n  const forceMse = MSE_SUPPORTED && (preferMse || shouldDefaultToMSE(mediaEl));\n\n  return canUseNative && (preferNative || !forceMse);\n}\n\nexport const setupHls = (\n  props: Partial<\n    Pick<\n      MuxMediaPropsInternal,\n      | 'debug'\n      | 'streamType'\n      | 'type'\n      | 'startTime'\n      | 'metadata'\n      | 'preferCmcd'\n      | '_hlsConfig'\n      | 'tokens'\n      | 'drmTypeCb'\n      | 'maxAutoResolution'\n    >\n  >,\n  mediaEl: HTMLMediaElement\n) => {\n  const {\n    debug,\n    streamType,\n    startTime: startPosition = -1,\n    metadata,\n    preferCmcd,\n    _hlsConfig = {},\n    maxAutoResolution,\n  } = props;\n  const type = getType(props);\n  const hlsType = type === ExtensionMimeTypeMap.M3U8;\n  const shouldUseNative = useNative(props, mediaEl);\n\n  // 1. if we are trying to play an hls media source create hls if we should be using it \"under the hood\"\n  if (hlsType && !shouldUseNative && MSE_SUPPORTED) {\n    const defaultConfig = {\n      backBufferLength: 30,\n      renderTextTracksNatively: false,\n      liveDurationInfinity: true,\n      capLevelToPlayerSize: true,\n      capLevelOnFPSDrop: true,\n    };\n    const streamTypeConfig = getStreamTypeConfig(streamType);\n    const drmConfig = getDRMConfig(props);\n    // NOTE: `metadata.view_session_id` & `metadata.video_id` are guaranteed here (CJP)\n    // @ts-ignore\n    const cmcd = [CmcdTypes.QUERY, CmcdTypes.HEADER].includes(preferCmcd)\n      ? {\n          useHeaders: preferCmcd === CmcdTypes.HEADER,\n          sessionId: metadata?.view_session_id,\n          contentId: metadata?.video_id,\n        }\n      : undefined;\n\n    const capLevelControllerObj =\n      _hlsConfig.capLevelToPlayerSize == null ? { capLevelController: MinCapLevelController } : {};\n\n    const hls = new Hls({\n      // Kind of like preload metadata, but causes spinner.\n      // autoStartLoad: false,\n      debug,\n      startPosition,\n      cmcd,\n      xhrSetup: (xhr, url) => {\n        if (preferCmcd && preferCmcd !== CmcdTypes.QUERY) return;\n        const urlObj = new URL(url);\n        if (!urlObj.searchParams.has('CMCD')) return;\n        const cmcdVal = (urlObj.searchParams.get('CMCD')?.split(',') ?? [])\n          .filter((cmcdKVStr) => cmcdKVStr.startsWith('sid') || cmcdKVStr.startsWith('cid'))\n          .join(',');\n        urlObj.searchParams.set('CMCD', cmcdVal);\n\n        xhr.open('GET', urlObj);\n      },\n      ...capLevelControllerObj,\n      ...defaultConfig,\n      ...streamTypeConfig,\n      ...drmConfig,\n      ..._hlsConfig,\n    }) as HlsInterface;\n\n    if (capLevelControllerObj.capLevelController === MinCapLevelController) {\n      if (maxAutoResolution !== undefined) {\n        MinCapLevelController.setMaxAutoResolution(hls, maxAutoResolution);\n      }\n    }\n\n    hls.on(Hls.Events.MANIFEST_PARSED, async function (_event, data) {\n      const chapters = data.sessionData?.['com.apple.hls.chapters'];\n      if (chapters?.URI || chapters?.VALUE.toLocaleLowerCase().startsWith('http')) {\n        fetchAndDispatchMuxMetadata(chapters?.URI ?? chapters?.VALUE, mediaEl);\n      }\n    });\n\n    return hls;\n  }\n  return undefined;\n};\n\nexport const getStreamTypeConfig = (streamType?: ValueOf<StreamTypes>) => {\n  // for regular live videos, set backBufferLength to 8\n  if (streamType === StreamTypes.LIVE) {\n    const liveConfig = {\n      backBufferLength: 8,\n    };\n\n    return liveConfig;\n  }\n\n  return {};\n};\n\nexport const getDRMConfig = (\n  props: Partial<Pick<MuxMediaPropsInternal, 'src' | 'playbackId' | 'tokens' | 'customDomain' | 'drmTypeCb'>>\n): Partial<HlsConfig> => {\n  const {\n    tokens: { drm: drmToken } = {},\n    playbackId: playbackIdWithOptionalParams, // Since Mux Player typically sets `src` instead of `playbackId`, fall back to it here (CJP)\n    drmTypeCb,\n  } = props;\n  const playbackId = toPlaybackIdFromParameterized(playbackIdWithOptionalParams);\n  if (!drmToken || !playbackId) return {};\n  return {\n    emeEnabled: true,\n    drmSystems: {\n      'com.apple.fps': {\n        licenseUrl: toLicenseKeyURL(props, 'fairplay'),\n        serverCertificateUrl: toAppCertURL(props, 'fairplay'),\n      },\n      'com.widevine.alpha': {\n        licenseUrl: toLicenseKeyURL(props, 'widevine'),\n      },\n      'com.microsoft.playready': {\n        licenseUrl: toLicenseKeyURL(props, 'playready'),\n      },\n    },\n    requestMediaKeySystemAccessFunc: (keySystem, supportedConfigurations) => {\n      if (keySystem === 'com.widevine.alpha') {\n        supportedConfigurations = [\n          // NOTE: For widevine, by default we'll duplicate the key system configs but add L1-level\n          // security to the first set of duplicates so the key system will \"prefer\" that\n          // if/when available. (CJP)\n          // See, e.g.: https://developer.mozilla.org/en-US/docs/Web/API/Navigator/requestMediaKeySystemAccess#supportedconfigurations\n          ...supportedConfigurations.map((mediaKeySystemConfig) => {\n            const videoCapabilities = mediaKeySystemConfig.videoCapabilities?.map((capability) => {\n              return {\n                ...capability,\n                robustness: 'HW_SECURE_ALL',\n              };\n            });\n            return {\n              ...mediaKeySystemConfig,\n              videoCapabilities,\n            };\n          }),\n          ...supportedConfigurations,\n        ];\n      }\n      return navigator.requestMediaKeySystemAccess(keySystem, supportedConfigurations).then((value) => {\n        const drmType = toDRMTypeFromKeySystem(keySystem);\n        drmTypeCb?.(drmType);\n        return value;\n      });\n    },\n  };\n};\n\nexport const getAppCertificate = async (appCertificateUrl: string) => {\n  const resp = await fetch(appCertificateUrl);\n  if (resp.status !== 200) {\n    return Promise.reject(resp);\n  }\n  const body = await resp.arrayBuffer();\n  return body;\n};\n\nexport const getLicenseKey = async (message: ArrayBuffer, licenseServerUrl: string) => {\n  const resp = await fetch(licenseServerUrl, {\n    method: 'POST',\n    headers: { 'Content-type': 'application/octet-stream' },\n    body: message,\n  });\n  if (resp.status !== 200) {\n    return Promise.reject(resp);\n  }\n  const keyBuffer = await resp.arrayBuffer();\n  return new Uint8Array(keyBuffer);\n};\n\nexport const setupNativeFairplayDRM = (\n  props: Partial<Pick<MuxMediaPropsInternal, 'playbackId' | 'tokens' | 'playbackToken' | 'customDomain' | 'drmTypeCb'>>,\n  mediaEl: HTMLMediaElement\n) => {\n  const setupMediaKeys = async (initDataType: string) => {\n    const access = await navigator\n      .requestMediaKeySystemAccess('com.apple.fps', [\n        {\n          initDataTypes: [initDataType],\n          videoCapabilities: [{ contentType: 'application/vnd.apple.mpegurl', robustness: '' }],\n          distinctiveIdentifier: 'not-allowed',\n          persistentState: 'not-allowed',\n          sessionTypes: ['temporary'],\n        },\n      ])\n      .then((value) => {\n        props.drmTypeCb?.(DRMType.FAIRPLAY);\n        return value;\n      })\n      .catch(() => {\n        const message = i18n(\n          'Cannot play DRM-protected content with current security configuration on this browser. Try playing in another browser.'\n        );\n        // Should we flag this as a business exception?\n        const mediaError = new MediaError(message, MediaError.MEDIA_ERR_ENCRYPTED, true);\n        mediaError.errorCategory = MuxErrorCategory.DRM;\n        mediaError.muxCode = MuxErrorCode.ENCRYPTED_UNSUPPORTED_KEY_SYSTEM;\n        saveAndDispatchError(mediaEl, mediaError);\n      });\n\n    if (!access) return;\n\n    const keys = await access.createMediaKeys();\n\n    try {\n      const fairPlayAppCert = await getAppCertificate(toAppCertURL(props, 'fairplay')).catch((errOrResp) => {\n        if (errOrResp instanceof Response) {\n          const mediaError = getErrorFromResponse(errOrResp, MuxErrorCategory.DRM, props);\n          console.error('mediaError', mediaError?.message, mediaError?.context);\n          if (mediaError) {\n            return Promise.reject(mediaError);\n          }\n          // NOTE: This should never happen. Adding for exhaustiveness (CJP).\n          return Promise.reject(new Error('Unexpected error in app cert request'));\n        }\n        return Promise.reject(errOrResp);\n      });\n      await keys.setServerCertificate(fairPlayAppCert).catch(() => {\n        const message = i18n(\n          'Your server certificate failed when attempting to set it. This may be an issue with a no longer valid certificate.'\n        );\n        const mediaError = new MediaError(message, MediaError.MEDIA_ERR_ENCRYPTED, true);\n        mediaError.errorCategory = MuxErrorCategory.DRM;\n        mediaError.muxCode = MuxErrorCode.ENCRYPTED_UPDATE_SERVER_CERT_FAILED;\n        return Promise.reject(mediaError);\n      });\n      // @ts-ignore\n    } catch (error: Error | MediaError) {\n      saveAndDispatchError(mediaEl, error);\n      return;\n    }\n    await mediaEl.setMediaKeys(keys);\n  };\n\n  const updateMediaKeyStatus = (mediaKeyStatus: MediaKeyStatus) => {\n    let mediaError;\n    if (mediaKeyStatus === 'internal-error') {\n      const message = i18n(\n        'The DRM Content Decryption Module system had an internal failure. Try reloading the page, upading your browser, or playing in another browser.'\n      );\n      mediaError = new MediaError(message, MediaError.MEDIA_ERR_ENCRYPTED, true);\n      mediaError.errorCategory = MuxErrorCategory.DRM;\n      mediaError.muxCode = MuxErrorCode.ENCRYPTED_CDM_ERROR;\n    } else if (mediaKeyStatus === 'output-restricted' || mediaKeyStatus === 'output-downscaled') {\n      const message = i18n(\n        'DRM playback is being attempted in an environment that is not sufficiently secure. User may see black screen.'\n      );\n      // NOTE: When encountered, this is a non-fatal error (though it's certainly interruptive of standard playback experience). (CJP)\n      mediaError = new MediaError(message, MediaError.MEDIA_ERR_ENCRYPTED, false);\n      mediaError.errorCategory = MuxErrorCategory.DRM;\n      mediaError.muxCode = MuxErrorCode.ENCRYPTED_OUTPUT_RESTRICTED;\n    }\n\n    if (mediaError) {\n      saveAndDispatchError(mediaEl, mediaError);\n    }\n  };\n\n  const setupMediaKeySession = async (initDataType: string, initData: ArrayBuffer) => {\n    const session = (mediaEl.mediaKeys as MediaKeys).createSession();\n    const onKeyStatusChange = () => {\n      // recheck key statuses\n      // NOTE: As an improvement, we could also add checks for a status of 'expired' and\n      // attempt to renew the license here (CJP)\n      session.keyStatuses.forEach((keyStatus) => updateMediaKeyStatus(keyStatus));\n    };\n\n    const onMessage = async (event: MediaKeyMessageEvent) => {\n      const spc = event.message;\n      try {\n        const ckc = await getLicenseKey(spc, toLicenseKeyURL(props, 'fairplay'));\n\n        try {\n          // This is the same call whether we are local or AirPlay.\n          // Safari will forward CKC to Apple TV automatically.\n          await session.update(ckc);\n        } catch {\n          const message = i18n(\n            'Failed to update DRM license. This may be an issue with the player or your protected content.'\n          );\n          const mediaError = new MediaError(message, MediaError.MEDIA_ERR_ENCRYPTED, true);\n          mediaError.errorCategory = MuxErrorCategory.DRM;\n          mediaError.muxCode = MuxErrorCode.ENCRYPTED_UPDATE_LICENSE_FAILED;\n\n          saveAndDispatchError(mediaEl, mediaError);\n        }\n      } catch (errOrResp) {\n        if (errOrResp instanceof Response) {\n          const mediaError = getErrorFromResponse(errOrResp, MuxErrorCategory.DRM, props);\n          console.error('mediaError', mediaError?.message, mediaError?.context);\n\n          if (mediaError) {\n            saveAndDispatchError(mediaEl, mediaError);\n            return;\n          }\n\n          console.error('Unexpected error in license key request', errOrResp);\n          return;\n        }\n\n        console.error(errOrResp);\n      }\n    };\n\n    session.addEventListener('keystatuseschange', onKeyStatusChange);\n    session.addEventListener('message', onMessage);\n    mediaEl.addEventListener(\n      'teardown',\n      () => {\n        session.removeEventListener('keystatuseschange', onKeyStatusChange);\n        session.removeEventListener('message', onMessage);\n        session.close();\n      },\n      { once: true }\n    );\n\n    await session.generateRequest(initDataType, initData).catch((e) => {\n      console.error('Failed to generate license request', e);\n      const message = i18n(\n        'Failed to generate a DRM license request. This may be an issue with the player or your protected content.'\n      );\n      const mediaError = new MediaError(message, MediaError.MEDIA_ERR_ENCRYPTED, true);\n      mediaError.errorCategory = MuxErrorCategory.DRM;\n      mediaError.muxCode = MuxErrorCode.ENCRYPTED_GENERATE_REQUEST_FAILED;\n      return Promise.reject(mediaError);\n    });\n  };\n\n  const onFpEncrypted = async (event: MediaEncryptedEvent) => {\n    try {\n      const initDataType = event.initDataType;\n      if (initDataType !== 'skd') {\n        console.error(`Received unexpected initialization data type \"${initDataType}\"`);\n        return;\n      }\n\n      if (!mediaEl.mediaKeys) {\n        await setupMediaKeys(initDataType);\n      }\n\n      const initData = event.initData;\n      if (initData == null) {\n        console.error(`Could not start encrypted playback due to missing initData in ${event.type} event`);\n        return;\n      }\n\n      await setupMediaKeySession(initDataType, initData);\n      // @ts-ignore\n    } catch (error: Error | MediaError) {\n      saveAndDispatchError(mediaEl, error);\n      return;\n    }\n  };\n\n  addEventListenerWithTeardown(mediaEl, 'encrypted', onFpEncrypted);\n};\n\nexport const toLicenseKeyURL = (\n  {\n    playbackId: playbackIdWithParams,\n    tokens: { drm: token } = {},\n    customDomain = MUX_VIDEO_DOMAIN,\n  }: Partial<Pick<MuxMediaPropsInternal, 'playbackId' | 'tokens' | 'customDomain'>>,\n  scheme: 'widevine' | 'playready' | 'fairplay'\n) => {\n  const playbackId = toPlaybackIdFromParameterized(playbackIdWithParams);\n  // NOTE: Mux Video currently doesn't support custom domains for license/DRM endpoints, but\n  // customDomain can also be used for internal use cases, so treat that as an exception case for now. (CJP)\n  const domain = customDomain.toLocaleLowerCase().endsWith(MUX_VIDEO_DOMAIN) ? customDomain : MUX_VIDEO_DOMAIN;\n  return `https://license.${domain}/license/${scheme}/${playbackId}?token=${token}`;\n};\n\nexport const toAppCertURL = (\n  {\n    playbackId: playbackIdWithParams,\n    tokens: { drm: token } = {},\n    customDomain = MUX_VIDEO_DOMAIN,\n  }: Partial<Pick<MuxMediaPropsInternal, 'playbackId' | 'tokens' | 'customDomain'>>,\n  scheme: 'widevine' | 'playready' | 'fairplay'\n) => {\n  const playbackId = toPlaybackIdFromParameterized(playbackIdWithParams);\n  // NOTE: Mux Video currently doesn't support custom domains for license/DRM endpoints, but\n  // customDomain can also be used for internal use cases, so treat that as an exception case for now. (CJP)\n  const domain = customDomain.toLocaleLowerCase().endsWith(MUX_VIDEO_DOMAIN) ? customDomain : MUX_VIDEO_DOMAIN;\n  return `https://license.${domain}/appcert/${scheme}/${playbackId}?token=${token}`;\n};\n\nexport const isMuxVideoSrc = ({\n  playbackId,\n  src,\n  customDomain,\n}: Partial<Pick<MuxMediaPropsInternal, 'playbackId' | 'src' | 'customDomain'>>) => {\n  if (!!playbackId) return true;\n  // having no playback id and no src string should never actually happen, but could\n  if (typeof src !== 'string') return false;\n  // Include base for relative paths\n  const base = window?.location.href;\n  const hostname = new URL(src, base).hostname.toLocaleLowerCase();\n\n  return hostname.includes(MUX_VIDEO_DOMAIN) || (!!customDomain && hostname.includes(customDomain.toLocaleLowerCase()));\n};\n\nexport const setupMux = (\n  props: Partial<\n    Pick<\n      MuxMediaPropsInternal,\n      | 'envKey'\n      | 'playerInitTime'\n      | 'beaconCollectionDomain'\n      | 'errorTranslator'\n      | 'metadata'\n      | 'debug'\n      | 'playerSoftwareName'\n      | 'playerSoftwareVersion'\n      | 'playbackId'\n      | 'src'\n      | 'customDomain'\n      | 'disableCookies'\n      | 'disableTracking'\n      | 'muxDataSDK'\n      | 'muxDataSDKOptions'\n    >\n  >,\n  mediaEl: HTMLMediaElement,\n  hlsjs?: HlsInterface\n) => {\n  const { envKey: env_key, disableTracking, muxDataSDK = mux, muxDataSDKOptions = {} } = props;\n  const inferredEnv = isMuxVideoSrc(props);\n\n  if (!disableTracking && (env_key || inferredEnv)) {\n    const {\n      playerInitTime: player_init_time,\n      playerSoftwareName: player_software_name,\n      playerSoftwareVersion: player_software_version,\n      beaconCollectionDomain,\n      debug,\n      disableCookies,\n    } = props;\n\n    const metadata = {\n      ...props.metadata,\n      video_title: props?.metadata?.video_title || undefined,\n    };\n\n    const muxEmbedErrorTranslator = (error: ErrorEvent) => {\n      // mux-embed auto tracks fatal hls.js errors, turn it off.\n      // playback-core will emit errors with a numeric code manually to mux-embed.\n      if (typeof error.player_error_code === 'string') return false;\n\n      if (typeof props.errorTranslator === 'function') {\n        return props.errorTranslator(error);\n      }\n\n      return error;\n    };\n\n    muxDataSDK.monitor(mediaEl, {\n      debug,\n      beaconCollectionDomain,\n      hlsjs,\n      Hls: hlsjs ? Hls : undefined,\n      automaticErrorTracking: false,\n      errorTranslator: muxEmbedErrorTranslator,\n      disableCookies,\n      ...muxDataSDKOptions,\n      data: {\n        ...(env_key ? { env_key } : {}),\n        // Metadata fields\n        player_software_name,\n        // NOTE: Adding this because there appears to be some instability on whether\n        // player_software_name or player_software \"wins\" for Mux Data (CJP)\n        player_software: player_software_name,\n        player_software_version,\n        player_init_time,\n        // Use any metadata passed in programmatically (which may override the defaults above)\n        ...metadata,\n      },\n    });\n  }\n};\n\nexport const loadMedia = (\n  props: Partial<\n    Pick<\n      MuxMediaProps,\n      | 'preferPlayback'\n      | 'src'\n      | 'type'\n      | 'startTime'\n      | 'streamType'\n      | 'autoplay'\n      | 'playbackId'\n      | 'tokens'\n      | 'customDomain'\n      | 'disablePseudoEnded'\n      | 'debug'\n    >\n  >,\n  mediaEl: HTMLMediaElement,\n  hls?: Pick<\n    Hls,\n    | 'config'\n    | 'on'\n    | 'once'\n    | 'off'\n    | 'trigger'\n    | 'startLoad'\n    | 'stopLoad'\n    | 'recoverMediaError'\n    | 'destroy'\n    | 'loadSource'\n    | 'attachMedia'\n    | 'liveSyncPosition'\n    | 'subtitleTracks'\n    | 'subtitleTrack'\n    | 'userConfig'\n    | 'audioTrack'\n    | 'audioTracks'\n    | 'autoLevelEnabled'\n    | 'nextLevel'\n    | 'levels'\n    | 'currentLevel'\n  >\n) => {\n  const shouldUseNative = useNative(props, mediaEl);\n  const { src, customDomain = MUX_VIDEO_DOMAIN } = props;\n\n  const maybeDispatchEndedCallback = () => {\n    // We want to early bail if the underlying media element is already in an ended state,\n    // since that means it will have already fired the ended event.\n    // Do the \"cheaper\" check first\n    if (mediaEl.ended) return;\n\n    if (props.disablePseudoEnded) return;\n\n    const pseudoEnded = getEnded(mediaEl, hls);\n    if (!pseudoEnded) return;\n\n    if (isStuckOnLastFragment(mediaEl, hls)) {\n      // Nudge the playhead in this case.\n      mediaEl.currentTime = mediaEl.buffered.end(mediaEl.buffered.length - 1);\n    } else {\n      mediaEl.dispatchEvent(new Event('ended'));\n    }\n  };\n\n  let prevSeekableStart: number | undefined;\n  let prevSeekableEnd: number | undefined;\n\n  const seekableChange = () => {\n    const seekableTimeRanges = getSeekable(mediaEl);\n    let nextSeekableStart: number | undefined;\n    let nextSeekableEnd: number | undefined;\n    if (seekableTimeRanges.length > 0) {\n      nextSeekableStart = seekableTimeRanges.start(0);\n      nextSeekableEnd = seekableTimeRanges.end(0);\n    }\n    if (prevSeekableEnd !== nextSeekableEnd || prevSeekableStart !== nextSeekableStart) {\n      mediaEl.dispatchEvent(new CustomEvent('seekablechange', { composed: true }));\n    }\n    prevSeekableStart = nextSeekableStart;\n    prevSeekableEnd = nextSeekableEnd;\n  };\n\n  // Make sure we track transitions from infinite to finite durations for seekable changes as well.\n  addEventListenerWithTeardown(mediaEl, 'durationchange', seekableChange);\n\n  if (mediaEl && shouldUseNative) {\n    const type = getType(props);\n\n    if (typeof src === 'string') {\n      // Fetch the Mux metadata JSON even on preload=none because it's needed for the Mux logo.\n      if (src.endsWith('.mp4') && src.includes(customDomain)) {\n        const playbackId = toPlaybackIdFromSrc(src);\n        const metadataUrl = new URL(`https://stream.${customDomain}/${playbackId}/metadata.json`);\n        fetchAndDispatchMuxMetadata(metadataUrl.toString(), mediaEl);\n      }\n\n      // NOTE: This should only be invoked after stream type has been\n      // derived after stream type has been determined.\n      const setupSeekableChangePoll = () => {\n        // Only monitor for seekable updates if StreamType is \"live\" and duration is not finite.\n        if (getStreamType(mediaEl) !== StreamTypes.LIVE || Number.isFinite(mediaEl.duration)) return;\n\n        // Use 1 second since in this context we don't know what the rate of updates\n        // should/will be.\n        // NOTE: We *could* derive the interval rate if we wanted to add logic to our playlist parsing to\n        // account for the per-spec rate of media playlist GETs. See:\n        // https://datatracker.ietf.org/doc/html/draft-pantos-hls-rfc8216bis-14#section-6.3.4 (CJP)\n        const intervalId = setInterval(seekableChange, 1000);\n\n        // Make sure we clean up after ourselves.\n        mediaEl.addEventListener(\n          'teardown',\n          () => {\n            clearInterval(intervalId);\n          },\n          { once: true }\n        );\n\n        // Assume we're done updating seekable when the duration is finite, which\n        // occurs when e.g. an HLS playlist is ended (`#EXT-X-ENDLIST`).\n        addEventListenerWithTeardown(mediaEl, 'durationchange', () => {\n          if (!Number.isFinite(mediaEl.duration)) return;\n          clearInterval(intervalId);\n        });\n      };\n\n      const setupNativeStreamInfo = async () => {\n        return updateStreamInfoFromSrc(src, mediaEl, type)\n          .then(setupSeekableChangePoll)\n          .catch((errOrResp: Response | Error) => {\n            if (errOrResp instanceof Response) {\n              const mediaError = getErrorFromResponse(errOrResp, MuxErrorCategory.VIDEO, props);\n              if (mediaError) {\n                saveAndDispatchError(mediaEl, mediaError);\n                return;\n              }\n            } else if (errOrResp instanceof Error) {\n              // mediaEl.dispatchEvent(new MediaError())\n            }\n          });\n      };\n\n      if (mediaEl.preload === 'none') {\n        // NOTE: Previously, we relied on the 'loadstart' event to fetch & parse playlists for stream\n        // info for native playback scenarios. Unfortunately, per spec this event will be dispatched\n        // regardless of the preload state and regardless of whether or not fetching of the src media\n        // has, in fact, begun. In order to respect the provided preferences and avoid eager loading\n        // while still attempting to begin fetching playlists for stream info as early as possible when\n        // media *will* be loaded, we will do a \"first to the finish line\" on both the 'play' event,\n        // which will be dispatched earlier *if* it is the event that initiates media loading, and the\n        // 'loadedmetadata' event, which is dispatched only after the media has finished loading metadata,\n        // but will reliably correlate with media loading. (CJP)\n        // For more, see: Steps 7 & 8 of 'the resource selection algorithm' from 4.8.11.5 Loading the\n        // media resource in the HTML Living Standard\n        // (https://html.spec.whatwg.org/multipage/media.html#concept-media-load-algorithm)\n        const playHandler = () => {\n          setupNativeStreamInfo();\n          mediaEl.removeEventListener('loadedmetadata', loadedMetadataHandler);\n        };\n        const loadedMetadataHandler = () => {\n          setupNativeStreamInfo();\n          mediaEl.removeEventListener('play', playHandler);\n        };\n        addEventListenerWithTeardown(mediaEl, 'play', playHandler, { once: true });\n        addEventListenerWithTeardown(mediaEl, 'loadedmetadata', loadedMetadataHandler, { once: true });\n      } else {\n        setupNativeStreamInfo();\n      }\n\n      // NOTE: Currently use drmToken to signal that playback is expected to be DRM-protected\n      if (props.tokens?.drm) {\n        setupNativeFairplayDRM(props, mediaEl);\n      } else {\n        // If we end up receiving an encrypted event in this case, that means the media is DRM-protected\n        // but a token was not provided.\n        addEventListenerWithTeardown(\n          mediaEl,\n          'encrypted',\n          () => {\n            const message = i18n('Attempting to play DRM-protected content without providing a DRM token.');\n            const mediaError = new MediaError(message, MediaError.MEDIA_ERR_ENCRYPTED, true);\n            mediaError.errorCategory = MuxErrorCategory.DRM;\n            mediaError.muxCode = MuxErrorCode.ENCRYPTED_MISSING_TOKEN;\n            saveAndDispatchError(mediaEl, mediaError);\n          },\n          { once: true }\n        );\n      }\n\n      mediaEl.setAttribute('src', src);\n\n      if (props.startTime) {\n        (muxMediaState.get(mediaEl) ?? {}).startTime = props.startTime;\n        // seekable is set to the range of the entire video once durationchange fires\n        mediaEl.addEventListener('durationchange', seekInSeekableRange, { once: true });\n      }\n    } else {\n      mediaEl.removeAttribute('src');\n    }\n\n    mediaEl.addEventListener('error', handleNativeError);\n    mediaEl.addEventListener('error', handleInternalError);\n    mediaEl.addEventListener(\n      'emptied',\n      () => {\n        const trackEls: NodeListOf<HTMLTrackElement> = mediaEl.querySelectorAll('track[data-removeondestroy]');\n        trackEls.forEach((trackEl) => {\n          trackEl.remove();\n        });\n      },\n      { once: true }\n    );\n\n    addEventListenerWithTeardown(mediaEl, 'pause', maybeDispatchEndedCallback);\n    // NOTE: Browsers do not consistently fire an 'ended' event upon seeking to the\n    // end of the media while already paused. This was due to an ambiguity in the\n    // HTML specification, but is now more explicit.\n    // See: https://html.spec.whatwg.org/multipage/media.html#reaches-the-end (CJP)\n    addEventListenerWithTeardown(mediaEl, 'seeked', maybeDispatchEndedCallback);\n\n    addEventListenerWithTeardown(mediaEl, 'play', () => {\n      if (mediaEl.ended) return;\n      if (!isApproximatelyGTE(mediaEl.currentTime, mediaEl.duration)) return;\n      // If we were \"pseudo-ended\" before playback was attempted, seek back to the\n      // beginning to \"replay\", like \"real\" ended behavior.\n      mediaEl.currentTime = mediaEl.seekable.length ? mediaEl.seekable.start(0) : 0;\n    });\n  } else if (hls && src) {\n    hls.once(Hls.Events.LEVEL_LOADED, (_evt, data) => {\n      updateStreamInfoFromHlsjsLevelDetails(data.details, mediaEl, hls);\n      seekableChange();\n      // Only monitor for seekable updates if StreamType is \"live\" and duration is not finite.\n      if (getStreamType(mediaEl) === StreamTypes.LIVE && !Number.isFinite(mediaEl.duration)) {\n        hls.on(Hls.Events.LEVEL_UPDATED, seekableChange);\n\n        // Assume we're done updating seekable when the duration is finite, which\n        // occurs when e.g. an HLS playlist is ended (`#EXT-X-ENDLIST`).\n        addEventListenerWithTeardown(mediaEl, 'durationchange', () => {\n          if (!Number.isFinite(mediaEl.duration)) return;\n          hls.off(Hls.Events.LEVELS_UPDATED, seekableChange);\n        });\n      }\n    });\n\n    hls.on(Hls.Events.ERROR, (_event, data) => {\n      const error = getErrorFromHlsErrorData(data, props);\n\n      if (error.muxCode === MuxErrorCode.NETWORK_NOT_READY) {\n        const maxRetries = 6; // 5 minutes and 5 seconds total (5s, 60s, 60s, 60s, 60s, 60s)\n        const state = muxMediaState.get(mediaEl) ?? {};\n        const retryCount = state.retryCount ?? 0;\n\n        if (retryCount < maxRetries) {\n          // First retry is 5 seconds, subsequent retries are 60 seconds\n          const retryDelay = retryCount === 0 ? 5000 : 60000;\n\n          // New error with the retry delay\n          const retryDelayError = new MediaError(\n            `Retrying in ${retryDelay / 1000} seconds...`,\n            error.code,\n            error.fatal\n          );\n          Object.assign(retryDelayError, error);\n          saveAndDispatchError(mediaEl, retryDelayError);\n\n          setTimeout(() => {\n            state.retryCount = retryCount + 1;\n            if (data.details === 'manifestLoadError' && data.url) {\n              hls.loadSource(data.url);\n            }\n          }, retryDelay);\n          return;\n        } else {\n          state.retryCount = 0;\n          // New error with the retry link\n          const retryLinkError = new MediaError(\n            'Try again later or <a href=\"#\" onclick=\"window.location.reload(); return false;\" style=\"color: #4a90e2;\">click here to retry</a>',\n            error.code,\n            error.fatal\n          );\n          Object.assign(retryLinkError, error);\n          saveAndDispatchError(mediaEl, retryLinkError);\n          return;\n        }\n      }\n      saveAndDispatchError(mediaEl, error);\n    });\n\n    hls.on(Hls.Events.MANIFEST_LOADED, () => {\n      // Clear error state and UI\n      const state = muxMediaState.get(mediaEl);\n      if (state && state.error) {\n        state.error = null;\n        state.retryCount = 0;\n\n        mediaEl.dispatchEvent(new Event('emptied'));\n        mediaEl.dispatchEvent(new Event('loadstart'));\n      }\n    });\n\n    mediaEl.addEventListener('error', handleInternalError);\n    addEventListenerWithTeardown(mediaEl, 'waiting', maybeDispatchEndedCallback);\n\n    setupMediaTracks(props as HTMLMediaElement, hls);\n    setupTextTracks(mediaEl, hls);\n\n    hls.attachMedia(mediaEl);\n  } else {\n    console.error(\n      \"It looks like the video you're trying to play will not work on this system! If possible, try upgrading to the newest versions of your browser or software.\"\n    );\n  }\n};\n\nfunction seekInSeekableRange(event: Event) {\n  const mediaEl = event.target as HTMLMediaElement;\n  const startTime = muxMediaState.get(mediaEl)?.startTime;\n  if (!startTime) return;\n\n  if (inSeekableRange(mediaEl.seekable, mediaEl.duration, startTime)) {\n    // Setting preload to `none` from `auto` was required on iOS to fix a bug\n    // that caused no `timeupdate` events to fire after seeking \\_()_/\n    const wasAuto = mediaEl.preload === 'auto';\n    if (wasAuto) {\n      mediaEl.preload = 'none';\n    }\n\n    mediaEl.currentTime = startTime;\n\n    if (wasAuto) {\n      mediaEl.preload = 'auto';\n    }\n  }\n}\n\nasync function handleNativeError(event: Event) {\n  // Return if the event was created or modified by a script or dispatched\n  // via EventTarget.dispatchEvent() preventing an infinite loop.\n  if (!event.isTrusted) return;\n\n  // Stop immediate propagation of the native error event, re-dispatch below!\n  event.stopImmediatePropagation();\n\n  const mediaEl = event.target as HTMLMediaElement;\n  // Safari sometimes throws an error event with a null error.\n  if (!mediaEl?.error) return;\n\n  const { message, code } = mediaEl.error;\n  const error = new MediaError(message, code);\n\n  // This accounts for cases where native playback is being used but\n  // a non-200 response occurs on the request for the playback-id's playlist.\n  // In this case, we currently already fetch the playlist in parallel (for\n  // things like inferring the stream type, live edge start window, etc.),\n  // so we'll wait briefly for that response to translate to a more accurate\n  // error.\n  if (\n    mediaEl.src &&\n    code === MediaError.MEDIA_ERR_SRC_NOT_SUPPORTED &&\n    mediaEl.readyState === HTMLMediaElement.HAVE_NOTHING\n  ) {\n    setTimeout(() => {\n      const ourError = getError(mediaEl) ?? mediaEl.error;\n      // If the code is (still) MediaError.MEDIA_ERR_SRC_NOT_SUPPORTED,\n      // assume it's an (unlikely) case where we did, in fact, encounter\n      // media that is unsupported.\n      if (ourError?.code === MediaError.MEDIA_ERR_SRC_NOT_SUPPORTED) {\n        saveAndDispatchError(mediaEl, error);\n      }\n      // Since a parallel request for the source should be initiated to determine\n      // stream info (e.g. streamType) at roughly the same time as when the source\n      // is loaded by the media element, we should be able to keep this timeout short.\n      // NOTE: Although there is a case where the parallel request may happen later\n      // (namely, after metadata is loaded), this should be mutually exclusive from\n      // the case we're accounting for here, since unsupported media should not\n      // ever get metadata loaded in the first place. (CJP)\n    }, 500);\n    return;\n  }\n\n  if (mediaEl.src && (code !== MediaError.MEDIA_ERR_DECODE || code !== undefined)) {\n    // Attempt to get the response code from the video src url.\n    try {\n      const { status } = await fetch(mediaEl.src);\n      // Use the same hls.js data structure.\n      error.data = { response: { code: status } };\n    } catch {}\n  }\n\n  saveAndDispatchError(mediaEl, error);\n}\n\nfunction saveAndDispatchError(mediaEl: HTMLMediaElement, error: MediaError) {\n  // Prevent dispatching non-fatal errors.\n  if (!error.fatal) return;\n\n  (muxMediaState.get(mediaEl) ?? {}).error = error as unknown as HTMLMediaElement['error'];\n\n  mediaEl.dispatchEvent(\n    new CustomEvent('error', {\n      detail: error,\n    })\n  );\n}\n\n/**\n * Use a event listener instead of a function call when dispatching the Custom error\n * event so consumers are still able to disable or intercept this error event.\n * @param {Event} event\n */\nfunction handleInternalError(event: Event | CustomEvent<MediaError>) {\n  if (!(event instanceof CustomEvent) || !(event.detail instanceof MediaError)) return;\n\n  const mediaEl = event.target as HTMLMediaElement;\n  const error = event.detail;\n  // Prevent tracking non-fatal errors in Mux data.\n  if (!error || !error.fatal) return;\n\n  (muxMediaState.get(mediaEl) ?? {}).error = error as unknown as HTMLMediaElement['error'];\n\n  // Only pass valid mux-embed props: player_error_code, player_error_message, player_error_context\n  mediaEl.mux?.emit('error', {\n    player_error_code: error.code,\n    player_error_message: error.message,\n    player_error_context: error.context,\n  });\n}\n\nconst getErrorFromHlsErrorData = (\n  data: ErrorData,\n  props: Partial<Pick<MuxMediaPropsInternal, 'playbackId' | 'drmToken' | 'playbackToken' | 'tokens' | 'debug'>>\n) => {\n  // Non-fatal errors: only log when debug is enabled (using console.warn to reduce user concern)\n  const isNonFatal = !data.fatal;\n  if (isNonFatal) {\n    if (props.debug) {\n      console.warn('getErrorFromHlsErrorData() (non-fatal)', data);\n    }\n  } else {\n    console.error('getErrorFromHlsErrorData()', data);\n  }\n\n  const ErrorCodeMap: Partial<Record<ValueOf<typeof Hls.ErrorTypes>, 0 | 1 | 2 | 3 | 4 | 5>> = {\n    [Hls.ErrorTypes.NETWORK_ERROR]: MediaError.MEDIA_ERR_NETWORK,\n    [Hls.ErrorTypes.MEDIA_ERROR]: MediaError.MEDIA_ERR_DECODE,\n    [Hls.ErrorTypes.KEY_SYSTEM_ERROR]: MediaError.MEDIA_ERR_ENCRYPTED,\n  } as const;\n\n  // eslint-disable-next-line no-shadow\n  const hlsErrorDataToErrorCode = (data: ErrorData) => {\n    if (\n      [\n        Hls.ErrorDetails.KEY_SYSTEM_LICENSE_REQUEST_FAILED,\n        Hls.ErrorDetails.KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED,\n      ].includes(data.details)\n    ) {\n      return MediaError.MEDIA_ERR_NETWORK;\n    }\n    return ErrorCodeMap[data.type];\n  };\n\n  // eslint-disable-next-line no-shadow\n  const hlsErrorDataToCategory = (data: ErrorData) => {\n    if (data.type === Hls.ErrorTypes.KEY_SYSTEM_ERROR) return MuxErrorCategory.DRM;\n    if (data.type === Hls.ErrorTypes.NETWORK_ERROR) return MuxErrorCategory.VIDEO;\n  };\n\n  let mediaError: MediaError;\n  const errorCode = hlsErrorDataToErrorCode(data);\n  if (errorCode === MediaError.MEDIA_ERR_NETWORK && data.response) {\n    const category = hlsErrorDataToCategory(data) ?? MuxErrorCategory.VIDEO;\n    mediaError =\n      getErrorFromResponse(data.response, category, props, data.fatal) ?? new MediaError('', errorCode, data.fatal);\n  } else if (errorCode === MediaError.MEDIA_ERR_ENCRYPTED) {\n    if (data.details === Hls.ErrorDetails.KEY_SYSTEM_NO_CONFIGURED_LICENSE) {\n      const message = i18n('Attempting to play DRM-protected content without providing a DRM token.');\n      mediaError = new MediaError(message, MediaError.MEDIA_ERR_ENCRYPTED, data.fatal);\n      mediaError.errorCategory = MuxErrorCategory.DRM;\n      mediaError.muxCode = MuxErrorCode.ENCRYPTED_MISSING_TOKEN;\n    } else if (data.details === Hls.ErrorDetails.KEY_SYSTEM_NO_ACCESS) {\n      /** @TODO For UI message add suggestion to try another browser */\n      const message = i18n(\n        'Cannot play DRM-protected content with current security configuration on this browser. Try playing in another browser.'\n      );\n      // Should we flag this as a business exception?\n      mediaError = new MediaError(message, MediaError.MEDIA_ERR_ENCRYPTED, data.fatal);\n      mediaError.errorCategory = MuxErrorCategory.DRM;\n      mediaError.muxCode = MuxErrorCode.ENCRYPTED_UNSUPPORTED_KEY_SYSTEM;\n    } else if (data.details === Hls.ErrorDetails.KEY_SYSTEM_NO_SESSION) {\n      const message = i18n(\n        'Failed to generate a DRM license request. This may be an issue with the player or your protected content.'\n      );\n      // NOTE: For some reason, perhaps due to issues with EXT-X-KEY parsing, hls.js defines this as a non-fatal error.\n      // For us, we should be able to assume it is instead fatal. (CJP)\n      mediaError = new MediaError(message, MediaError.MEDIA_ERR_ENCRYPTED, true);\n      mediaError.errorCategory = MuxErrorCategory.DRM;\n      mediaError.muxCode = MuxErrorCode.ENCRYPTED_GENERATE_REQUEST_FAILED;\n    } else if (data.details === Hls.ErrorDetails.KEY_SYSTEM_SESSION_UPDATE_FAILED) {\n      const message = i18n(\n        'Failed to update DRM license. This may be an issue with the player or your protected content.'\n      );\n      mediaError = new MediaError(message, MediaError.MEDIA_ERR_ENCRYPTED, data.fatal);\n      mediaError.errorCategory = MuxErrorCategory.DRM;\n      mediaError.muxCode = MuxErrorCode.ENCRYPTED_UPDATE_LICENSE_FAILED;\n    } else if (data.details === Hls.ErrorDetails.KEY_SYSTEM_SERVER_CERTIFICATE_UPDATE_FAILED) {\n      const message = i18n(\n        'Your server certificate failed when attempting to set it. This may be an issue with a no longer valid certificate.'\n      );\n      mediaError = new MediaError(message, MediaError.MEDIA_ERR_ENCRYPTED, data.fatal);\n      mediaError.errorCategory = MuxErrorCategory.DRM;\n      mediaError.muxCode = MuxErrorCode.ENCRYPTED_UPDATE_SERVER_CERT_FAILED;\n    } else if (data.details === Hls.ErrorDetails.KEY_SYSTEM_STATUS_INTERNAL_ERROR) {\n      const message = i18n(\n        'The DRM Content Decryption Module system had an internal failure. Try reloading the page, upading your browser, or playing in another browser.'\n      );\n      mediaError = new MediaError(message, MediaError.MEDIA_ERR_ENCRYPTED, data.fatal);\n      mediaError.errorCategory = MuxErrorCategory.DRM;\n      mediaError.muxCode = MuxErrorCode.ENCRYPTED_CDM_ERROR;\n    } else if (data.details === Hls.ErrorDetails.KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED) {\n      const message = i18n(\n        'DRM playback is being attempted in an environment that is not sufficiently secure. User may see black screen.'\n      );\n      // NOTE: When encountered, this is a non-fatal error (though it's certainly interruptive of standard playback experience). (CJP)\n      mediaError = new MediaError(message, MediaError.MEDIA_ERR_ENCRYPTED, false);\n      mediaError.errorCategory = MuxErrorCategory.DRM;\n      mediaError.muxCode = MuxErrorCode.ENCRYPTED_OUTPUT_RESTRICTED;\n    } else {\n      mediaError = new MediaError(data.error.message, MediaError.MEDIA_ERR_ENCRYPTED, data.fatal);\n      mediaError.errorCategory = MuxErrorCategory.DRM;\n      mediaError.muxCode = MuxErrorCode.ENCRYPTED_ERROR;\n    }\n  } else {\n    mediaError = new MediaError('', errorCode, data.fatal);\n  }\n  if (!mediaError.context) {\n    mediaError.context =\n      `${data.url ? `url: ${data.url}\\n` : ''}` +\n      `${\n        data.response && (data.response.code || data.response.text)\n          ? `response: ${data.response.code}, ${data.response.text}\\n`\n          : ''\n      }` +\n      `${data.reason ? `failure reason: ${data.reason}\\n` : ''}` +\n      `${data.level ? `level: ${data.level}\\n` : ''}` +\n      `${data.parent ? `parent stream controller: ${data.parent}\\n` : ''}` +\n      `${data.buffer ? `buffer length: ${data.buffer}\\n` : ''}` +\n      `${data.error ? `error: ${data.error}\\n` : ''}` +\n      `${data.event ? `event: ${data.event}\\n` : ''}` +\n      `${data.err ? `error message: ${data.err?.message}\\n` : ''}`;\n  }\n  mediaError.data = data;\n  return mediaError;\n};\n","import Hls from 'hls.js';\nimport type HlsClassType from 'hls.js';\nexport default Hls;\nexport type HlsInterface = HlsClassType;\n","// Identifies what kind of request was made that resulted in an error\nexport const MuxErrorCategory = {\n  VIDEO: 'video',\n  THUMBNAIL: 'thumbnail',\n  STORYBOARD: 'storyboard',\n  DRM: 'drm',\n} as const;\n\nexport const MuxErrorCode = {\n  NOT_AN_ERROR: 0,\n  NETWORK_OFFLINE: 2000002,\n  NETWORK_UNKNOWN_ERROR: 2000000,\n  NETWORK_NO_STATUS: 2000001,\n  NETWORK_INVALID_URL: 2400000,\n  NETWORK_NOT_FOUND: 2404000,\n  NETWORK_NOT_READY: 2412000,\n  NETWORK_GENERIC_SERVER_FAIL: 2500000,\n  NETWORK_TOKEN_MISSING: 2403201,\n  NETWORK_TOKEN_MALFORMED: 2412202,\n  NETWORK_TOKEN_EXPIRED: 2403210,\n  NETWORK_TOKEN_AUD_MISSING: 2403221,\n  NETWORK_TOKEN_AUD_MISMATCH: 2403222,\n  NETWORK_TOKEN_SUB_MISMATCH: 2403232,\n  ENCRYPTED_ERROR: 5000000, // Generic\n  ENCRYPTED_UNSUPPORTED_KEY_SYSTEM: 5000001,\n  ENCRYPTED_GENERATE_REQUEST_FAILED: 5000002,\n  ENCRYPTED_UPDATE_LICENSE_FAILED: 5000003,\n  ENCRYPTED_UPDATE_SERVER_CERT_FAILED: 5000004,\n  ENCRYPTED_CDM_ERROR: 5000005,\n  ENCRYPTED_OUTPUT_RESTRICTED: 5000006,\n  ENCRYPTED_MISSING_TOKEN: 5000002,\n} as const;\n\nexport type MuxErrorCategory = typeof MuxErrorCategory;\nexport type MuxErrorCode = typeof MuxErrorCode;\n\nexport type MuxErrorCategoryValue = MuxErrorCategory[keyof MuxErrorCategory];\nexport type MuxErrorCodeValue = MuxErrorCode[keyof MuxErrorCode];\n\nexport const errorCategoryToTokenNameOrPrefix = (category: MuxErrorCategoryValue) => {\n  if (category === MuxErrorCategory.VIDEO) return 'playback';\n  return category;\n};\n\n// Typescript says it's strictly a string, but it can also be a number or an object with a toString method.\n// https://github.com/microsoft/TypeScript/issues/6032\n// https://262.ecma-international.org/6.0/#sec-error-message\n\ntype Stringable = string | { toString(): string };\n\ndeclare global {\n  interface ErrorConstructor {\n    new (message?: Stringable): Error;\n    (message?: Stringable): Error;\n    readonly prototype: Error;\n  }\n}\n\nexport class MediaError extends Error {\n  static MEDIA_ERR_ABORTED = 1 as const;\n  static MEDIA_ERR_NETWORK = 2 as const;\n  static MEDIA_ERR_DECODE = 3 as const;\n  static MEDIA_ERR_SRC_NOT_SUPPORTED = 4 as const;\n  static MEDIA_ERR_ENCRYPTED = 5 as const;\n  // @see https://docs.mux.com/guides/data/monitor-html5-video-element#customize-error-tracking-behavior\n  static MEDIA_ERR_CUSTOM = 100;\n\n  static defaultMessages: Record<number, string> = {\n    1: 'You aborted the media playback',\n    2: 'A network error caused the media download to fail.',\n    3: 'A media error caused playback to be aborted. The media could be corrupt or your browser does not support this format.',\n    4: 'An unsupported error occurred. The server or network failed, or your browser does not support this format.',\n    5: 'The media is encrypted and there are no keys to decrypt it.',\n  };\n\n  name: string;\n  code: number;\n  public muxCode?: MuxErrorCodeValue;\n  public errorCategory?: MuxErrorCategoryValue;\n  context?: string;\n  fatal: boolean;\n  data?: any;\n  streamType?: 'live' | 'on-demand' | 'unknown';\n\n  constructor(message?: Stringable, code: number = MediaError.MEDIA_ERR_CUSTOM, fatal?: boolean, context?: string) {\n    super(message);\n    this.name = 'MediaError';\n    this.code = code;\n    this.context = context;\n    this.fatal = fatal ?? (code >= MediaError.MEDIA_ERR_NETWORK && code <= MediaError.MEDIA_ERR_ENCRYPTED);\n\n    if (!this.message) {\n      this.message = MediaError.defaultMessages[this.code] ?? '';\n    }\n  }\n}\n","/* eslint @typescript-eslint/triple-slash-reference: \"off\" */\n/// <reference path=\"../../../node_modules/mux-embed/dist/types/mux-embed.d.ts\" preserve=\"true\" />\nimport type { Options, Mux } from 'mux-embed';\nimport type { MediaError } from './errors';\nimport type { HlsConfig } from 'hls.js';\nimport type Hls from 'hls.js';\n\ntype KeyTypes = string | number | symbol;\ntype Maybe<T> = T | null | undefined;\n\nconst isNil = (x: unknown): x is null | undefined => x == undefined;\n\n// Type Guard to determine if a given key is actually a key of some object of type T\n// eslint-disable-next-line @typescript-eslint/no-empty-object-type\nexport const isKeyOf = <T extends {} = any>(k: KeyTypes, o: Maybe<T>): k is keyof T => {\n  if (isNil(o)) return false;\n  return k in o;\n};\n\nexport type ValueOf<T> = T[keyof T];\nexport type Metadata = Partial<Required<Options>['data']>;\ntype MetaData = Metadata;\nexport type PlaybackEngine = Hls;\nexport type MuxDataSDK = Mux;\n\nexport type PlaybackCore = {\n  engine?: PlaybackEngine;\n  muxDataSDK?: MuxDataSDK;\n  setAutoplay: (autoplay?: Autoplay) => void;\n  setPreload: (preload?: HTMLMediaElement['preload']) => void;\n};\n\n// TODO add INVIEW_MUTED, INVIEW_ANY\nexport type AutoplayTypes = {\n  ANY: 'any';\n  MUTED: 'muted';\n};\n\nexport const AutoplayTypes: AutoplayTypes = {\n  ANY: 'any',\n  MUTED: 'muted',\n};\n\nexport type Autoplay = boolean | ValueOf<AutoplayTypes>;\n\nexport type HlsPlaylistTypes = 'VOD' | 'EVENT' | null | undefined;\n\nexport type StreamTypes = {\n  ON_DEMAND: 'on-demand';\n  LIVE: 'live';\n  UNKNOWN: 'unknown';\n};\n\nexport const StreamTypes: StreamTypes = {\n  ON_DEMAND: 'on-demand',\n  LIVE: 'live',\n  UNKNOWN: 'unknown',\n};\n\nexport type PlaybackTypes = {\n  MSE: 'mse';\n  NATIVE: 'native';\n};\n\nexport const PlaybackTypes: PlaybackTypes = {\n  MSE: 'mse',\n  NATIVE: 'native',\n};\n\nexport type CmcdTypes = {\n  HEADER: 'header';\n  QUERY: 'query';\n  NONE: 'none';\n};\n\nexport const CmcdTypes: CmcdTypes = {\n  HEADER: 'header',\n  QUERY: 'query',\n  NONE: 'none',\n};\n\nexport const CmcdTypeValues = Object.values(CmcdTypes);\n\nexport type ExtensionMimeTypeMap = {\n  M3U8: 'application/vnd.apple.mpegurl';\n  MP4: 'video/mp4';\n};\n\nexport const ExtensionMimeTypeMap: ExtensionMimeTypeMap = {\n  M3U8: 'application/vnd.apple.mpegurl',\n  MP4: 'video/mp4',\n};\n\nexport type MimeTypeShorthandMap = {\n  HLS: ExtensionMimeTypeMap['M3U8'];\n};\n\nexport const MimeTypeShorthandMap: MimeTypeShorthandMap = {\n  HLS: ExtensionMimeTypeMap.M3U8,\n};\n\nexport const shorthandKeys = Object.keys(MimeTypeShorthandMap);\n\nexport type MediaTypes =\n  | ValueOf<ExtensionMimeTypeMap>\n  | keyof MimeTypeShorthandMap\n  /** @TODO Figure out a way to \"downgrade\" derived types below to early TS syntax (e.g. 3.4) instead of explicit versions here (CJP) */\n  | 'hls';\n// | `${Lowercase<keyof MimeTypeShorthandMap>}`\n// | `${Uppercase<keyof MimeTypeShorthandMap>}`;\n\nexport const allMediaTypes = [\n  ...(Object.values(ExtensionMimeTypeMap) as ValueOf<ExtensionMimeTypeMap>[]),\n  /** @TODO Figure out a way to \"downgrade\" derived types below to early TS syntax (e.g. 3.4) instead of explicit versions here (CJP) */\n  'hls',\n  'HLS',\n  // ...(shorthandKeys as (keyof MimeTypeShorthandMap)[]),\n  // ...(shorthandKeys.map((k) => k.toUpperCase()) as `${Uppercase<keyof MimeTypeShorthandMap>}`[]),\n  // ...(shorthandKeys.map((k) => k.toLowerCase()) as `${Lowercase<keyof MimeTypeShorthandMap>}`[]),\n] as MediaTypes[];\n\n// Both cuepoints and chapters have optional end times\n// so support both joined up and sparse cue placements\ntype CueLike<T = any> = {\n  startTime: number;\n  endTime?: number;\n  value: T;\n};\nexport type CuePoint<T = any> =\n  | CueLike<T> // new shape\n  | { time: number; value: T }; // legacy shape, still supported for now\nexport type Chapter = CueLike<string>;\n\nexport const MaxResolution = {\n  upTo720p: '720p',\n  upTo1080p: '1080p',\n  upTo1440p: '1440p',\n  upTo2160p: '2160p',\n} as const;\n\nexport const MinResolution = {\n  noLessThan480p: '480p',\n  noLessThan540p: '540p',\n  noLessThan720p: '720p',\n  noLessThan1080p: '1080p',\n  noLessThan1440p: '1440p',\n  noLessThan2160p: '2160p',\n} as const;\n\nexport const RenditionOrder = {\n  DESCENDING: 'desc',\n} as const;\n\nexport const MaxAutoResolution = {\n  upTo720p: '720p',\n  upTo1080p: '1080p',\n  upTo1440p: '1440p',\n  upTo2160p: '2160p',\n} as const;\n\nexport type MaxResolutionValue = ValueOf<typeof MaxResolution>;\nexport type MinResolutionValue = ValueOf<typeof MinResolution>;\nexport type RenditionOrderValue = ValueOf<typeof RenditionOrder>;\nexport type MaxAutoResolutionValue = ValueOf<typeof MaxAutoResolution>;\n\nexport type Tokens = {\n  playback?: string;\n  drm?: string;\n  thumbnail?: string;\n  storyboard?: string;\n};\n\nexport type MuxMediaPropTypes = {\n  _hlsConfig?: Partial<HlsConfig>;\n  autoPlay?: Autoplay;\n  autoplay?: Autoplay;\n  beaconCollectionDomain: Options['beaconCollectionDomain'];\n  customDomain: string;\n  debug: Options['debug'] & Hls['config']['debug'];\n  disableCookies: Options['disableCookies'];\n  disableTracking: boolean;\n  disablePseudoEnded: boolean;\n  drmToken?: string;\n  playbackToken?: string;\n  envKey: MetaData['env_key'];\n  error?: HTMLMediaElement['error'] | MediaError;\n  errorTranslator: Options['errorTranslator'];\n  liveEdgeStart: number;\n  maxResolution: MaxResolutionValue;\n  metadata: Partial<Options['data']>;\n  minResolution: MinResolutionValue;\n  maxAutoResolution: MaxAutoResolutionValue;\n  playbackId: string;\n  playerInitTime: MetaData['player_init_time'];\n  preferCmcd: ValueOf<CmcdTypes> | undefined;\n  preferPlayback: ValueOf<PlaybackTypes> | undefined;\n  programStartTime: number;\n  programEndTime: number;\n  assetStartTime: number;\n  assetEndTime: number;\n  renditionOrder: RenditionOrderValue;\n  startTime: Hls['config']['startPosition'];\n  streamType: ValueOf<StreamTypes>;\n  targetLiveWindow: number;\n  tokens: Tokens;\n  type: MediaTypes;\n  extraSourceParams: Record<string, any>;\n};\n\nexport type HTMLMediaElementProps = Partial<Pick<HTMLMediaElement, 'src' | 'preload' | 'error' | 'seekable'>>;\n\nexport type MuxMediaProps = HTMLMediaElementProps & MuxMediaPropTypes;\nexport type MuxMediaPropsInternal = MuxMediaProps & {\n  playerSoftwareName: MetaData['player_software_name'];\n  playerSoftwareVersion: MetaData['player_software_version'];\n  muxDataSDK?: Mux;\n  muxDataSDKOptions?: Mux;\n  muxDataKeepSession?: boolean;\n  drmTypeCb?: (drmType: Metadata['view_drm_type']) => void;\n};\n\n// TODO: Make these more uniform, remove bubbles, discuss to remove detail.\nexport type MuxMediaEventsMap = {\n  cuepointchange: CustomEvent<{ composed: true; bubbles: true; detail: CuePoint }>;\n  chapterchange: CustomEvent<{ composed: true; bubbles: true; detail: Chapter }>;\n  targetlivewindowchange: CustomEvent<{ composed: true; bubbles: true }>;\n  streamtypechange: CustomEvent<{ composed: true; bubbles: true }>;\n  seekablechange: CustomEvent<{ composed: true }>;\n  error: CustomEvent<{ detail: MediaError }>;\n};\n","const code = 'en'; export default { code }","import { isKeyOf, ExtensionMimeTypeMap, MimeTypeShorthandMap, StreamTypes } from './types';\nimport type { HlsPlaylistTypes, MuxMediaProps } from './types';\n// @ts-ignore\nimport lang from '../lang/en.json';\n\ntype addEventListenerWithTeardown = <\n  K extends keyof HTMLMediaElementEventMap,\n  T extends EventTarget = HTMLMediaElement,\n>(\n  mediaEl: HTMLMediaElement,\n  type: K,\n  listener: (this: T, ev: HTMLMediaElementEventMap[K]) => any,\n  options?: boolean | AddEventListenerOptions,\n  target?: T | HTMLMediaElement\n) => void;\n\n// Adds an event listener to a media element that will be removed when an 'teardown' event is dispatched.\n// Using this instead of 'emptied' as that can fire on initial load based on prior state of the media element\n// Will be fired as a result of (directly or indirectly) invoking playback-core's `teardown()` function.\nexport const addEventListenerWithTeardown: addEventListenerWithTeardown = (\n  mediaEl,\n  type,\n  listener,\n  options,\n  target = mediaEl\n) => {\n  /** @TODO fix types (hard problem due to lack of explicit relationship between Element and EventMap definitions) */\n  // @ts-ignore\n  target.addEventListener(type, listener, options);\n  // NOTE: Using custom teardown\n  mediaEl.addEventListener(\n    'teardown',\n    () => {\n      /** @TODO fix types (hard problem due to lack of explicit relationship between Element and EventMap definitions) */\n      // @ts-ignore\n      target.removeEventListener(type, listener);\n    },\n    { once: true }\n  );\n};\n\nexport function inSeekableRange(seekable: TimeRanges, duration: number, time: number) {\n  if (duration && time > duration) {\n    time = duration;\n  }\n  for (let i = 0; i < seekable.length; i++) {\n    if (seekable.start(i) <= time && seekable.end(i) >= time) {\n      return true;\n    }\n  }\n  return false;\n}\n\nexport const toPlaybackIdParts = (playbackIdWithOptionalParams: string): [string, string?] => {\n  const qIndex = playbackIdWithOptionalParams.indexOf('?');\n  if (qIndex < 0) return [playbackIdWithOptionalParams];\n  const idPart = playbackIdWithOptionalParams.slice(0, qIndex);\n  const queryPart = playbackIdWithOptionalParams.slice(qIndex);\n  return [idPart, queryPart];\n};\n\nexport const getType = (props: Partial<Pick<MuxMediaProps, 'type' | 'src' | 'customDomain'>>) => {\n  const { type } = props;\n  if (type) {\n    const upperType = type.toUpperCase();\n    return isKeyOf(upperType, MimeTypeShorthandMap) ? MimeTypeShorthandMap[upperType] : type;\n  }\n  return inferMimeTypeFromURL(props);\n};\n\nexport const toStreamTypeFromPlaylistType = (playlistType: HlsPlaylistTypes) => {\n  return playlistType === 'VOD' ? StreamTypes.ON_DEMAND : StreamTypes.LIVE;\n};\n\nexport const toTargetLiveWindowFromPlaylistType = (playlistType: HlsPlaylistTypes) => {\n  if (playlistType === 'EVENT') return Number.POSITIVE_INFINITY;\n  if (playlistType === 'VOD') return Number.NaN;\n  return 0;\n};\n\nexport const inferMimeTypeFromURL = (props: Partial<Pick<MuxMediaProps, 'src' | 'customDomain'>>) => {\n  const { src } = props;\n  if (!src) return '';\n\n  let pathname = '';\n  try {\n    pathname = new URL(src).pathname;\n  } catch (_e) {\n    console.error('invalid url');\n  }\n\n  const extDelimIdx = pathname.lastIndexOf('.');\n  if (extDelimIdx < 0) {\n    if (isExtensionLessMuxM3U8URL(props)) {\n      return ExtensionMimeTypeMap.M3U8; // Treat extension-less Mux URLs as HLS\n    }\n    return '';\n  }\n\n  const ext = pathname.slice(extDelimIdx + 1);\n  const upperExt = ext.toUpperCase();\n\n  return isKeyOf(upperExt, ExtensionMimeTypeMap) ? ExtensionMimeTypeMap[upperExt] : '';\n};\n\nconst MUX_VIDEO_DOMAIN = 'mux.com';\nexport const isExtensionLessMuxM3U8URL = ({\n  src,\n  customDomain = MUX_VIDEO_DOMAIN,\n}: Partial<Pick<MuxMediaProps, 'src' | 'customDomain'>>) => {\n  let urlObj;\n  try {\n    urlObj = new URL(`${src}`);\n  } catch {\n    return false;\n  }\n  const validProtocol = urlObj.protocol === 'https:';\n  const validHostname = urlObj.hostname === `stream.${customDomain}`.toLowerCase();\n  const pathParts = urlObj.pathname.split('/');\n  const validPathPartsLength = pathParts.length === 2;\n  const validExtensionlessPath = !pathParts?.[1].includes('.');\n  return validProtocol && validHostname && validPathPartsLength && validExtensionlessPath;\n};\n\nexport type MuxJWT = {\n  sub: string;\n  aud: 'v' | 't' | 'g' | 's' | 'd';\n  exp: number;\n};\n\nexport const parseJwt = (token: string | undefined): Partial<MuxJWT> | undefined => {\n  const base64Url = (token ?? '').split('.')[1];\n\n  // exit early on invalid value\n  if (!base64Url) return undefined;\n\n  // Account for malformed JWTs\n  try {\n    const base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');\n    const jsonPayload = decodeURIComponent(\n      atob(base64)\n        .split('')\n        .map(function (c) {\n          return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);\n        })\n        .join('')\n    );\n    return JSON.parse(jsonPayload);\n  } catch {\n    return undefined;\n  }\n};\n\nexport const isJWTExpired = ({ exp }: Partial<Pick<MuxJWT, 'exp'>>, referenceTime: number = Date.now()) => {\n  return !exp || exp * 1000 < referenceTime;\n};\n\n// NOTE: Treating missing sub (and expected sub) as mismatches for now (CJP)\nexport const isJWTSubMismatch = ({ sub }: Partial<Pick<MuxJWT, 'sub'>>, expectedSub: string | undefined) => {\n  return sub !== expectedSub;\n};\n\nexport const isJWTAudMissing = ({ aud }: Partial<Pick<MuxJWT, 'aud'>>, _expectedAud: string | undefined) => {\n  return !aud;\n};\n\nexport const isJWTAudMismatch = ({ aud }: Partial<Pick<MuxJWT, 'aud'>>, expectedAud: string | undefined) => {\n  return aud !== expectedAud;\n};\n\nconst DEFAULT_LOCALE = 'en';\n\n// NL example\n// lang = {\n//   \"Network Error\": \"Netwerk Fout\",\n// };\nexport function i18n(str: string, translate = true) {\n  const message = translate ? ((lang as unknown as any)?.[str] ?? str) : str;\n  const locale = translate ? (lang as unknown as any).code : DEFAULT_LOCALE;\n  return new IntlMessageFormat(message, locale);\n}\n\n/**\n * Poor man's IntlMessageFormat, enrich if need be.\n * @see https://formatjs.io/docs/intl-messageformat/\n */\nclass IntlMessageFormat {\n  message: string;\n  locale: string;\n\n  /** @TODO re-implement esbuild custom plugin for code usage (CJP) */\n  constructor(message: string, locale = (lang as unknown as any) ?? DEFAULT_LOCALE) {\n    this.message = message;\n    this.locale = locale;\n  }\n\n  format(values: Record<string, any>): string {\n    return this.message.replace(/\\{(\\w+)\\}/g, (_match, key) => {\n      return values[key] ?? '';\n    });\n  }\n\n  toString() {\n    return this.message;\n  }\n}\n","import { addEventListenerWithTeardown } from './util';\nimport { ValueOf, Autoplay, AutoplayTypes, PlaybackEngine, MuxMediaPropsInternal, StreamTypes } from './types';\nimport Hls from './hls';\n\nconst AutoplayTypeValues = Object.values(AutoplayTypes);\nexport const isAutoplayValue = (value: unknown): value is Autoplay => {\n  return (\n    typeof value === 'boolean' ||\n    (typeof value === 'string' && AutoplayTypeValues.includes(value as ValueOf<AutoplayTypes>))\n  );\n};\n\n// Given a video element, will listen to lifecycle events to determine important\n// things like whether the video is live or whether the video has played\n// and then handles autoplaying the video as appropraite.\n// It works with both the native video element or hls.js.\n// This returns a method UpdateAutoplay, that allows the user to change\n// the value of the autoplay attribute and it will react appropriately.\nexport const setupAutoplay = (\n  props: Partial<MuxMediaPropsInternal>,\n  mediaEl: HTMLMediaElement,\n  hls?: PlaybackEngine\n) => {\n  const { autoplay: maybeAutoplay } = props;\n  let hasPlayed = false;\n  let isLive = false;\n  let autoplay: Autoplay = isAutoplayValue(maybeAutoplay) ? maybeAutoplay : !!maybeAutoplay;\n\n  const updateHasPlayed = () => {\n    // hasPlayed\n\n    if (!hasPlayed) {\n      addEventListenerWithTeardown(\n        mediaEl,\n        'playing',\n        () => {\n          hasPlayed = true;\n        },\n        { once: true }\n      );\n    }\n  };\n\n  updateHasPlayed();\n\n  // on `loadstart`\n  // hasPlayed should default to false\n  // we should try and autoplay\n  addEventListenerWithTeardown(\n    mediaEl,\n    'loadstart',\n    () => {\n      hasPlayed = false;\n      updateHasPlayed();\n      handleAutoplay(mediaEl, autoplay);\n    },\n    { once: true }\n  );\n\n  // on `loadedmetadata` we can check whether we're live in the case of native playback\n  addEventListenerWithTeardown(\n    mediaEl,\n    'loadstart',\n    () => {\n      // only update isLive here if we're using native playback\n      if (!hls) {\n        // defer to streamType if set (including inferred)\n        if (props.streamType && props.streamType !== StreamTypes.UNKNOWN) {\n          isLive = props.streamType === StreamTypes.LIVE;\n        } else {\n          isLive = !Number.isFinite(mediaEl.duration);\n        }\n      }\n      handleAutoplay(mediaEl, autoplay);\n    },\n    { once: true }\n  );\n\n  // determine if we're live for hls.js\n  if (hls) {\n    hls.once(Hls.Events.LEVEL_LOADED, (_event: any, data: any) => {\n      // defer to streamType if set (including inferred)\n      if (props.streamType && props.streamType !== StreamTypes.UNKNOWN) {\n        isLive = props.streamType === StreamTypes.LIVE;\n      } else {\n        isLive = data.details.live ?? false;\n      }\n    });\n  }\n\n  // When we are not auto-playing, we should seek to the live sync position\n  // This will seek first play event of *any* live video including event-type,\n  // which probably shouldn't seek\n  if (!autoplay) {\n    const handleSeek = () => {\n      // don't seek if we're not live or if a `startTime` has been explicitly set\n      if (!isLive || Number.isFinite(props.startTime)) {\n        return;\n      }\n      // seek to either hls.js's liveSyncPosition or the native seekable end\n      if (hls?.liveSyncPosition) {\n        mediaEl.currentTime = hls.liveSyncPosition;\n      } else {\n        if (Number.isFinite(mediaEl.seekable.end(0))) {\n          mediaEl.currentTime = mediaEl.seekable.end(0);\n        }\n      }\n    };\n    if (hls) {\n      addEventListenerWithTeardown(\n        mediaEl,\n        'play',\n        () => {\n          if (mediaEl.preload === 'metadata') {\n            hls.once(Hls.Events.LEVEL_UPDATED, handleSeek);\n          } else {\n            handleSeek();\n          }\n        },\n        { once: true }\n      );\n    }\n  }\n\n  // this method allows us to update the value of autoplay\n  // and try autoplaying appropriately.\n  const updateAutoplay = (newAutoplay?: Autoplay) => {\n    if (!hasPlayed) {\n      autoplay = isAutoplayValue(newAutoplay) ? newAutoplay : !!newAutoplay;\n      handleAutoplay(mediaEl, autoplay);\n    }\n  };\n\n  return updateAutoplay;\n};\n\nexport const handleAutoplay = (mediaEl: HTMLMediaElement, autoplay: Autoplay) => {\n  if (!autoplay) {\n    return;\n  }\n\n  const oldMuted = mediaEl.muted;\n  const restoreMuted = () => (mediaEl.muted = oldMuted);\n\n  switch (autoplay) {\n    // ANY:\n    // try to play with current options\n    // if it fails, mute and try playing again\n    // if that fails, restore muted state and don't try playing again\n    case AutoplayTypes.ANY:\n      mediaEl.play().catch(() => {\n        mediaEl.muted = true;\n        mediaEl.play().catch(restoreMuted);\n      });\n      break;\n\n    // MUTED:\n    // mute the player and then try playing\n    // if that fails, restore muted state\n    case AutoplayTypes.MUTED:\n      mediaEl.muted = true;\n      mediaEl.play().catch(restoreMuted);\n      break;\n\n    // Default or if autoplay is a boolean attribute:\n    // Try playing the video and catch the failed autoplay warning\n    default: // eslint-disable-next-line\n      mediaEl.play().catch(() => {});\n      break;\n  }\n};\n","import { addEventListenerWithTeardown } from './util';\nimport { PlaybackEngine } from './types';\n\nexport const setupPreload = (\n  { preload, src }: Partial<HTMLMediaElement>,\n  mediaEl: HTMLMediaElement,\n  hls?: PlaybackEngine\n) => {\n  const updatePreload = (val?: HTMLMediaElement['preload']) => {\n    if (val != null && ['', 'none', 'metadata', 'auto'].includes(val)) {\n      mediaEl.setAttribute('preload', val);\n    } else {\n      mediaEl.removeAttribute('preload');\n    }\n  };\n\n  // handle native without hls.js (MSE)\n  if (!hls) {\n    updatePreload(preload);\n    return updatePreload;\n  }\n\n  let hasLoadedSource = false;\n  let hasPlayFired = false;\n\n  const originalLength = hls.config.maxBufferLength;\n  const originalSize = hls.config.maxBufferSize;\n\n  const updateHlsPreload = (val?: HTMLMediaElement['preload']) => {\n    // even if it doesn't have an effect on a <video> w/ MSE\n    // still update the `preload` attribute.\n    updatePreload(val);\n\n    const newPreload = val ?? mediaEl.preload;\n    if (hasPlayFired || newPreload === 'none') return;\n    if (newPreload === 'metadata') {\n      // load the least amount of data possible\n      hls.config.maxBufferLength = 1;\n      hls.config.maxBufferSize = 1;\n    } else {\n      hls.config.maxBufferLength = originalLength;\n      hls.config.maxBufferSize = originalSize;\n    }\n\n    safeLoadSource();\n  };\n\n  const safeLoadSource = () => {\n    if (!hasLoadedSource && src) {\n      hasLoadedSource = true;\n      hls.loadSource(src);\n    }\n  };\n\n  addEventListenerWithTeardown(\n    mediaEl,\n    'play',\n    () => {\n      hasPlayFired = true;\n\n      // once a user has played, allow for it to load data as normal\n      hls.config.maxBufferLength = originalLength;\n      hls.config.maxBufferSize = originalSize;\n\n      // load the source on first play if needed\n      safeLoadSource();\n    },\n    { once: true }\n  );\n\n  updateHlsPreload(preload);\n\n  return updateHlsPreload;\n};\n","import Hls from './hls';\n\nexport function setupMediaTracks(\n  customMediaEl: HTMLMediaElement,\n  hls: Pick<\n    Hls,\n    'audioTrack' | 'audioTracks' | 'autoLevelEnabled' | 'nextLevel' | 'levels' | 'on' | 'once' | 'off' | 'trigger'\n  >\n) {\n  if (!('videoTracks' in customMediaEl)) return;\n\n  // Create a map to save the unique id's we create for each level and rendition.\n  // hls.js uses the levels array index primarily but we'll use the id to have a\n  // 1 to 1 relation from rendition to level.\n  const levelIdMap = new WeakMap();\n\n  hls.on(Hls.Events.MANIFEST_PARSED, function (_event, data) {\n    removeAllMediaTracks();\n\n    const videoTrack = customMediaEl.addVideoTrack('main');\n    videoTrack.selected = true;\n\n    for (const [id, level] of data.levels.entries()) {\n      const videoRendition = videoTrack.addRendition(\n        level.url[0],\n        level.width,\n        level.height,\n        level.videoCodec,\n        level.bitrate\n      );\n\n      // The returned levels all have an id of `0`, save the id in a WeakMap.\n      levelIdMap.set(level, `${id}`);\n      videoRendition.id = `${id}`;\n    }\n  });\n\n  hls.on(Hls.Events.AUDIO_TRACKS_UPDATED, function (_event, data) {\n    removeAudioTracks();\n\n    for (const a of data.audioTracks) {\n      // hls.js doesn't return a `kind` property for audio tracks yet.\n      const kind = a.default ? 'main' : 'alternative';\n      const audioTrack = customMediaEl.addAudioTrack(kind, a.name, a.lang);\n      audioTrack.id = `${a.id}`;\n\n      if (a.default) {\n        audioTrack.enabled = true;\n      }\n    }\n  });\n\n  customMediaEl.audioTracks.addEventListener('change', () => {\n    // Cast to number, hls.js uses numeric id's.\n    const audioTrackId = +[...customMediaEl.audioTracks].find((t) => t.enabled)?.id;\n    const availableIds = hls.audioTracks.map((t) => t.id);\n    if (audioTrackId != hls.audioTrack && availableIds.includes(audioTrackId)) {\n      hls.audioTrack = audioTrackId;\n    }\n  });\n\n  // Fired when a level is removed after calling `removeLevel()`\n  hls.on(Hls.Events.LEVELS_UPDATED, function (_event, data) {\n    const videoTrack = customMediaEl.videoTracks[customMediaEl.videoTracks.selectedIndex ?? 0];\n    if (!videoTrack) return;\n\n    const levelIds: string[] = data.levels.map((l) => levelIdMap.get(l));\n\n    for (const rendition of customMediaEl.videoRenditions) {\n      if (rendition.id && !levelIds.includes(rendition.id)) {\n        videoTrack.removeRendition(rendition);\n      }\n    }\n  });\n\n  // hls.js doesn't support enabling multiple renditions.\n  //\n  // 1. if all renditions are enabled it's auto selection.\n  // 2. if 1 of the renditions is disabled we assume a selection was made\n  //    and lock it to the first rendition that is enabled.\n  const switchRendition = (event: Event) => {\n    // @ts-ignore\n    const level = event.target.selectedIndex as number;\n    if (level != hls.nextLevel) {\n      hls.nextLevel = level;\n    }\n  };\n\n  customMediaEl.videoRenditions?.addEventListener('change', switchRendition);\n\n  const removeVideoTracks = () => {\n    for (const videoTrack of customMediaEl.videoTracks) {\n      customMediaEl.removeVideoTrack(videoTrack);\n    }\n  };\n\n  const removeAudioTracks = () => {\n    for (const audioTrack of customMediaEl.audioTracks) {\n      customMediaEl.removeAudioTrack(audioTrack);\n    }\n  };\n\n  const removeAllMediaTracks = () => {\n    removeVideoTracks();\n    removeAudioTracks();\n  };\n\n  // NOTE: Since this is only relevant for hls, using destroying event (CJP).\n  hls.once(Hls.Events.DESTROYING, removeAllMediaTracks);\n}\n","import Hls from './hls';\nimport { CuePoint, Chapter } from './types';\nimport { addEventListenerWithTeardown } from './util';\n\ntype Config = { label: string };\n\n// Shared utils\n\n// Extracts the start time from a cuepoint, considering legacy \"time\" prop\nconst cuePointStart = (cuePoint: CuePoint): number => {\n  if ('time' in cuePoint) {\n    return cuePoint.time;\n  }\n  return cuePoint.startTime;\n};\n\nexport function setupTextTracks(\n  mediaEl: HTMLMediaElement,\n  hls: Pick<Hls, 'on' | 'once' | 'subtitleTracks' | 'subtitleTrack'>\n) {\n  hls.on(Hls.Events.NON_NATIVE_TEXT_TRACKS_FOUND, (_type, { tracks }) => {\n    tracks.forEach((trackObj) => {\n      const baseTrackObj = trackObj.subtitleTrack ?? trackObj.closedCaptions;\n      const idx = hls.subtitleTracks.findIndex(({ lang, name, type }) => {\n        return lang == baseTrackObj?.lang && name === trackObj.label && type.toLowerCase() === trackObj.kind;\n      });\n\n      // NOTE: Undocumented method for determining identifier by hls.js. Relied on for\n      // ensuring CUES_PARSED events can identify and apply cues to the appropriate track (CJP).\n      // See: https://github.com/video-dev/hls.js/blob/master/src/controller/timeline-controller.ts#L640\n      const id = (trackObj._id ?? trackObj.default) ? 'default' : `${trackObj.kind}${idx}`;\n\n      addTextTrack(mediaEl, trackObj.kind as TextTrackKind, trackObj.label, baseTrackObj?.lang, id, trackObj.default);\n    });\n  });\n\n  const changeHandler = () => {\n    if (!hls.subtitleTracks.length) return;\n\n    const showingTrack = Array.from(mediaEl.textTracks).find((textTrack) => {\n      return textTrack.id && textTrack.mode === 'showing' && ['subtitles', 'captions'].includes(textTrack.kind);\n    });\n\n    if (!showingTrack) return;\n\n    const currentHlsTrack = hls.subtitleTracks[hls.subtitleTrack];\n\n    // If hls.subtitleTrack is -1 or its id changed compared to the one that is showing load the new subtitle track.\n    const hlsTrackId = !currentHlsTrack\n      ? undefined\n      : currentHlsTrack.default\n        ? 'default'\n        : `${hls.subtitleTracks[hls.subtitleTrack].type.toLowerCase()}${hls.subtitleTrack}`;\n\n    if (hls.subtitleTrack < 0 || showingTrack?.id !== hlsTrackId) {\n      const idx = hls.subtitleTracks.findIndex(({ lang, name, type, default: defaultTrack }) => {\n        return (\n          (showingTrack.id === 'default' && defaultTrack) ||\n          (lang == showingTrack.language && name === showingTrack.label && type.toLowerCase() === showingTrack.kind)\n        );\n      });\n      // After the subtitleTrack is set here, hls.js will load the playlist and CUES_PARSED events will be fired below.\n      hls.subtitleTrack = idx;\n    }\n\n    if (showingTrack?.id === hlsTrackId) {\n      // Refresh the cues after a texttrack mode change to fix a Chrome bug causing the captions not to render.\n      if (showingTrack.cues) {\n        Array.from(showingTrack.cues).forEach((cue) => {\n          showingTrack.addCue(cue);\n        });\n      }\n    }\n  };\n\n  mediaEl.textTracks.addEventListener('change', changeHandler);\n\n  hls.on(Hls.Events.CUES_PARSED, (_type, { track, cues }) => {\n    const textTrack = mediaEl.textTracks.getTrackById(track);\n    if (!textTrack) return;\n\n    const disabled = textTrack.mode === 'disabled';\n    if (disabled) {\n      textTrack.mode = 'hidden';\n    }\n\n    cues.forEach((cue: VTTCue) => {\n      if (textTrack.cues?.getCueById(cue.id)) return;\n      textTrack.addCue(cue);\n    });\n\n    if (disabled) {\n      textTrack.mode = 'disabled';\n    }\n  });\n\n  // NOTE: Since this is only relevant for hls, using destroying event (CJP).\n  hls.once(Hls.Events.DESTROYING, () => {\n    mediaEl.textTracks.removeEventListener('change', changeHandler);\n    // Use data attribute to identify tracks that should be removed when switching sources/destroying hls.js instance.\n    const trackEls: NodeListOf<HTMLTrackElement> = mediaEl.querySelectorAll('track[data-removeondestroy]');\n    trackEls.forEach((trackEl) => {\n      trackEl.remove();\n    });\n  });\n\n  const forceHiddenTracks = () => {\n    // Keeping this a forEach in case we want to expand the scope of this.\n    Array.from(mediaEl.textTracks).forEach((track) => {\n      if (['subtitles', 'caption'].includes(track.kind)) return;\n      if (!(track.label === 'thumbnails' || track.kind === 'chapters')) return;\n      if (!track.cues?.length) {\n        let selector = 'track';\n        if (track.kind) selector += `[kind=\"${track.kind}\"]`;\n        if (track.label) selector += `[label=\"${track.label}\"]`;\n        const trackEl = mediaEl.querySelector(selector);\n        // Force a reload of the cues if they've been removed\n        const src = trackEl?.getAttribute('src') ?? '';\n        trackEl?.removeAttribute('src');\n        setTimeout(() => {\n          trackEl?.setAttribute('src', src);\n        }, 0);\n      }\n      // Force hidden mode if it's not hidden\n      if (track.mode !== 'hidden') {\n        track.mode = 'hidden';\n      }\n    });\n  };\n\n  // hls.js will forcibly clear all cues from tracks on manifest loads or media attaches.\n  // This ensures that we re-load them after it's done that.\n  hls.once(Hls.Events.MANIFEST_LOADED, forceHiddenTracks);\n  hls.once(Hls.Events.MEDIA_ATTACHED, forceHiddenTracks);\n}\n\nexport function addTextTrack(\n  mediaEl: HTMLMediaElement,\n  kind: TextTrackKind,\n  label: string,\n  lang?: string,\n  id?: string,\n  defaultTrack?: boolean\n): TextTrack {\n  const trackEl = document.createElement('track');\n  trackEl.kind = kind;\n  trackEl.label = label;\n  if (lang) {\n    // This attribute must be present if the element's kind attribute is in the subtitles state.\n    trackEl.srclang = lang;\n  }\n  if (id) {\n    trackEl.id = id;\n  }\n  if (!!defaultTrack) {\n    trackEl.default = true;\n  }\n  trackEl.track.mode = ['subtitles', 'captions'].includes(kind) ? 'disabled' : 'hidden';\n\n  // Add data attribute to identify tracks that should be removed when switching sources/destroying hls.js instance.\n  trackEl.setAttribute('data-removeondestroy', '');\n  mediaEl.append(trackEl);\n\n  return trackEl.track as TextTrack;\n}\n\nexport function removeTextTrack(mediaEl: HTMLMediaElement, track: TextTrack) {\n  const trackElement: HTMLTrackElement | undefined = Array.prototype.find.call(\n    mediaEl.querySelectorAll('track'),\n    (trackEl: HTMLTrackElement) => trackEl.track === track\n  );\n  trackElement?.remove();\n}\n\nexport function getTextTrack(mediaEl: HTMLMediaElement, label: string, kind: TextTrackKind) {\n  return Array.from(mediaEl.querySelectorAll('track')).find((trackEl) => {\n    return trackEl.track.label === label && trackEl.track.kind === kind;\n  })?.track;\n}\n\nexport async function addCuesToTextTrack<T = any>(\n  mediaEl: HTMLMediaElement,\n  cues: CuePoint<T>[] | Chapter[],\n  label: string,\n  kind: TextTrackKind\n) {\n  // If the track has already been created/added, use it.\n  let track = getTextTrack(mediaEl, label, kind);\n  if (!track) {\n    // Otherwise, create a new one\n    track = addTextTrack(mediaEl, kind, label);\n    track.mode = 'hidden';\n    // Wait a tick before providing a newly created track. Otherwise e.g. cues disappear when using track.addCue().\n    await new Promise((resolve) => setTimeout(() => resolve(undefined), 0));\n  }\n\n  if (track.mode !== 'hidden') {\n    track.mode = 'hidden';\n  }\n\n  // Copy cuePoints to ensure sort is not mutative\n  [...cues]\n    // Sort descending to ensure last cuepoints are added as cues first. This is done\n    // so the track's cue's can be used for reference when determining an appropriate\n    // endTime, allowing support of multiple invocations of addCuePoints\n    .sort((cuePointA, cuePointB) => cuePointStart(cuePointB) - cuePointStart(cuePointA))\n    .forEach((cuePoint) => {\n      const value = cuePoint.value;\n      const startTime = cuePointStart(cuePoint);\n\n      if ('endTime' in cuePoint && cuePoint.endTime != undefined) {\n        track?.addCue(\n          new VTTCue(\n            startTime,\n            cuePoint.endTime,\n            kind === 'chapters' ? (value as string) : JSON.stringify(value ?? null)\n          )\n        );\n      } else {\n        // find the cue that starts immediately after the cuePoint's time\n        const cueAfterIndex = Array.prototype.findIndex.call(track?.cues, (cue) => cue.startTime >= startTime);\n        const cueAfter = track?.cues?.[cueAfterIndex];\n        const endTime = cueAfter\n          ? cueAfter.startTime\n          : Number.isFinite(mediaEl.duration)\n            ? mediaEl.duration\n            : Number.MAX_SAFE_INTEGER;\n\n        // Adjust the endTime of the already added previous cue,\n        // if present, so it does not overlap with the newly added cue.\n        const previousCue = track?.cues?.[cueAfterIndex - 1];\n        if (previousCue) {\n          previousCue.endTime = startTime;\n        }\n        track?.addCue(\n          new VTTCue(startTime, endTime, kind === 'chapters' ? (value as string) : JSON.stringify(value ?? null))\n        );\n      }\n    });\n\n  // NOTE: this doesn't naturally fire when we update the list\n  // of cue points (without changing the active cue). We manually\n  // fire this to force the state manager to reflect the new change\n  mediaEl.textTracks.dispatchEvent(\n    new Event('change', {\n      bubbles: true,\n      composed: true,\n    })\n  );\n\n  return track;\n}\n\n// Cuepoints\n\nconst DEFAULT_CUEPOINTS_TRACK_LABEL = 'cuepoints';\nexport const DefaultCuePointsConfig: Config = Object.freeze({ label: DEFAULT_CUEPOINTS_TRACK_LABEL });\n\nexport async function addCuePoints<T>(\n  mediaEl: HTMLMediaElement,\n  cuePoints: CuePoint<T>[],\n  cuePointsConfig: Config = DefaultCuePointsConfig\n) {\n  return addCuesToTextTrack(mediaEl, cuePoints, cuePointsConfig.label, 'metadata');\n}\n\nconst toCuePoint = (cue: VTTCue) => ({\n  time: cue.startTime,\n  value: JSON.parse(cue.text),\n});\n\nexport function getCuePoints(\n  mediaEl: HTMLMediaElement,\n  cuePointsConfig: Config = { label: DEFAULT_CUEPOINTS_TRACK_LABEL }\n) {\n  const track = getTextTrack(mediaEl, cuePointsConfig.label, 'metadata');\n  if (!track?.cues) return [];\n  return Array.from(track.cues, (cue) => toCuePoint(cue as VTTCue));\n}\n\nexport function getActiveCuePoint(\n  mediaEl: HTMLMediaElement,\n  cuePointsConfig: Config = { label: DEFAULT_CUEPOINTS_TRACK_LABEL }\n) {\n  const track = getTextTrack(mediaEl, cuePointsConfig.label, 'metadata');\n  if (!track?.activeCues?.length) return undefined;\n  if (track.activeCues.length === 1) return toCuePoint(track.activeCues[0] as VTTCue);\n  // NOTE: There is a bug in Chromium where there may be \"lingering activeCues\" even\n  // after the playhead is no longer within their [startTime, endTime) bounds. This\n  // accounts for those cases (CJP)\n  const { currentTime } = mediaEl;\n  const actualActiveCue = Array.prototype.find.call(track.activeCues ?? [], ({ startTime, endTime }) => {\n    return startTime <= currentTime && endTime > currentTime;\n  }) as VTTCue | undefined;\n  if (!actualActiveCue) {\n    return toCuePoint(track.activeCues[0] as VTTCue);\n  }\n  return toCuePoint(actualActiveCue);\n}\n\nexport async function setupCuePoints(mediaEl: HTMLMediaElement, cuePointsConfig: Config = DefaultCuePointsConfig) {\n  return new Promise((resolve) => {\n    addEventListenerWithTeardown(mediaEl, 'loadstart', async () => {\n      const track = await addCuePoints(mediaEl, [], cuePointsConfig);\n      addEventListenerWithTeardown(\n        mediaEl,\n        'cuechange',\n        () => {\n          const activeCuePoint = getActiveCuePoint(mediaEl);\n          if (activeCuePoint) {\n            const evt = new CustomEvent('cuepointchange', {\n              composed: true,\n              bubbles: true,\n              detail: activeCuePoint,\n            });\n            mediaEl.dispatchEvent(evt);\n          }\n        },\n        {},\n        track\n      );\n      resolve(track);\n    });\n  });\n}\n\n/**\n * Chapters\n */\n\nconst DEFAULT_CHAPTERS_TRACK_LABEL = 'chapters';\nexport const DefaultChaptersConfig: Config = Object.freeze({ label: DEFAULT_CHAPTERS_TRACK_LABEL });\n\nconst vttCueToChapter = (cue: VTTCue) => ({\n  startTime: cue.startTime,\n  endTime: cue.endTime,\n  value: cue.text,\n});\n\nexport async function addChapters(\n  mediaEl: HTMLMediaElement,\n  chapters: Chapter[],\n  chaptersConfig: Config = DefaultChaptersConfig\n) {\n  return addCuesToTextTrack(mediaEl, chapters, chaptersConfig.label, 'chapters');\n}\n\nexport function getChapters(\n  mediaEl: HTMLMediaElement,\n  chaptersConfig: Config = { label: DEFAULT_CHAPTERS_TRACK_LABEL }\n) {\n  const track = getTextTrack(mediaEl, chaptersConfig.label, 'chapters');\n  if (!track?.cues?.length) return [];\n  return Array.from(track.cues, (cue) => vttCueToChapter(cue as VTTCue));\n}\n\nexport function getActiveChapter(\n  mediaEl: HTMLMediaElement,\n  chaptersConfig: Config = { label: DEFAULT_CHAPTERS_TRACK_LABEL }\n) {\n  const track = getTextTrack(mediaEl, chaptersConfig.label, 'chapters');\n  if (!track?.activeCues?.length) return undefined;\n  if (track.activeCues.length === 1) return vttCueToChapter(track.activeCues[0] as VTTCue);\n  // NOTE: There is a bug in Chromium where there may be \"lingering activeCues\" even\n  // after the playhead is no longer within their [startTime, endTime) bounds. This\n  // accounts for those cases (CJP)\n  const { currentTime } = mediaEl;\n  const actualActiveCue = Array.prototype.find.call(track.activeCues ?? [], ({ startTime, endTime }) => {\n    return startTime <= currentTime && endTime > currentTime;\n  }) as VTTCue | undefined;\n  if (!actualActiveCue) {\n    return vttCueToChapter(track.activeCues[0] as VTTCue);\n  }\n  return vttCueToChapter(actualActiveCue);\n}\n\nexport async function setupChapters(mediaEl: HTMLMediaElement, chaptersConfig: Config = DefaultChaptersConfig) {\n  return new Promise((resolve) => {\n    addEventListenerWithTeardown(mediaEl, 'loadstart', async () => {\n      const track = await addChapters(mediaEl, [], chaptersConfig);\n\n      addEventListenerWithTeardown(\n        mediaEl,\n        'cuechange',\n        () => {\n          const activeCuePoint = getActiveChapter(mediaEl);\n          if (activeCuePoint) {\n            const evt = new CustomEvent('chapterchange', {\n              composed: true,\n              bubbles: true,\n              detail: activeCuePoint,\n            });\n            mediaEl.dispatchEvent(evt);\n          }\n        },\n        {},\n        track\n      );\n\n      resolve(track);\n    });\n  });\n}\n","import { PlaybackEngine } from './types';\n\ntype MediaWithPDT = HTMLMediaElement & { getStartDate?: () => Date };\n\nexport function getStartDate(mediaEl: MediaWithPDT, hls: PlaybackEngine | undefined) {\n  if (hls) {\n    const playingDate = hls.playingDate;\n\n    if (playingDate != null) {\n      // If the video is very long and the currentTime will transition day boundaries,\n      // this may end up not being accurate\n      return new Date(playingDate.getTime() - mediaEl.currentTime * 1000);\n    }\n  }\n\n  if (typeof mediaEl.getStartDate === 'function') {\n    return mediaEl.getStartDate();\n  }\n\n  return new Date(NaN);\n}\n\nexport function getCurrentPdt(mediaEl: MediaWithPDT, hls: PlaybackEngine | undefined) {\n  if (hls && hls.playingDate) {\n    return hls.playingDate;\n  }\n\n  if (typeof mediaEl.getStartDate === 'function') {\n    const startDate = mediaEl.getStartDate();\n\n    // If the video is very long and the currentTime will transition day boundaries,\n    // this may end up not being accurate\n    return new Date(startDate.getTime() + mediaEl.currentTime * 1000);\n  }\n\n  return new Date(NaN);\n}\n","import type { LoaderResponse } from 'hls.js';\nimport {\n  i18n,\n  isJWTAudMismatch,\n  isJWTAudMissing,\n  isJWTExpired,\n  isJWTSubMismatch,\n  parseJwt,\n  toPlaybackIdParts,\n} from './util';\nimport { isKeyOf, MuxMediaPropsInternal, StreamTypes } from './types';\nimport type { MuxErrorCategoryValue } from './errors';\nimport { errorCategoryToTokenNameOrPrefix, MediaError, MuxErrorCategory, MuxErrorCode } from './errors';\n\nexport const MuxJWTAud = {\n  VIDEO: 'v',\n  // NOTE: These are not \"built in\" for mux-video/mux-audio (only mux-player) (CJP)\n  THUMBNAIL: 't',\n  STORYBOARD: 's',\n  // GIF: 'g', // currently unused\n  DRM: 'd',\n} as const;\n\nexport const categoryToAud = (category: MuxErrorCategoryValue) => {\n  if (category === MuxErrorCategory.VIDEO) return MuxJWTAud.VIDEO;\n  if (category === MuxErrorCategory.DRM) return MuxJWTAud.DRM;\n};\n\nexport const categoryToToken = (\n  category: MuxErrorCategoryValue,\n  muxMediaEl: Partial<Pick<MuxMediaPropsInternal, 'drmToken' | 'playbackToken' | 'tokens'>>\n) => {\n  const nameOrPrefix = errorCategoryToTokenNameOrPrefix(category);\n  const tokenName = `${nameOrPrefix}Token` as const;\n  if (muxMediaEl.tokens?.[nameOrPrefix]) return muxMediaEl.tokens?.[nameOrPrefix];\n  return isKeyOf(tokenName, muxMediaEl) ? muxMediaEl[tokenName] : undefined;\n};\n\nexport const getErrorFromResponse = (\n  resp: Pick<Response, 'status' | 'url'> | Pick<LoaderResponse, 'code' | 'url'>,\n  category: MuxErrorCategoryValue,\n  muxMediaEl: Partial<\n    Pick<MuxMediaPropsInternal, 'playbackId' | 'drmToken' | 'playbackToken' | 'tokens' | 'streamType'>\n  >,\n  fatal?: boolean,\n  translate = false,\n  offline = !globalThis.navigator?.onLine // NOTE: Passing this in for testing purposes\n) => {\n  if (offline) {\n    const message = i18n(`Your device appears to be offline`, translate);\n    const context = undefined;\n    const mediaErrorCode = MediaError.MEDIA_ERR_NETWORK;\n    // Being offline is not immediately a fatal error for playback.\n    const mediaError = new MediaError(message, mediaErrorCode, false, context);\n    mediaError.errorCategory = category;\n    mediaError.muxCode = MuxErrorCode.NETWORK_OFFLINE;\n    mediaError.data = resp;\n    return mediaError;\n  }\n  const status = 'status' in resp ? resp.status : resp.code;\n  const requestTime = Date.now();\n  const mediaErrorCode = MediaError.MEDIA_ERR_NETWORK;\n  // Not an error. WHAT ARE YOU EVEN DOING HERE?!?\n  if (status === 200) return undefined;\n  const tokenNamePrefix = errorCategoryToTokenNameOrPrefix(category);\n  const token = categoryToToken(category, muxMediaEl);\n  const expectedAud = categoryToAud(category);\n  const [playbackId] = toPlaybackIdParts(muxMediaEl.playbackId ?? '');\n  // NOTE: *should* have playback id when reaching here\n  // if (!status) return MuxErrorCode.NETWORK_NO_STATUS;\n  if (!status || !playbackId) return undefined;\n\n  const jwtObj = parseJwt(token);\n  // Make sure we didn't get here because of a malformed JWT and/or claim\n  if (!!token && !jwtObj) {\n    // 403 for DRM\n    const message = i18n(`The {tokenNamePrefix}-token provided is invalid or malformed.`, translate).format({\n      tokenNamePrefix,\n    });\n    const context = i18n(`Compact JWT string: {token}`, translate).format({\n      token,\n    });\n    const mediaError = new MediaError(message, mediaErrorCode, true, context);\n    mediaError.errorCategory = category;\n    mediaError.muxCode = MuxErrorCode.NETWORK_TOKEN_MALFORMED;\n    mediaError.data = resp;\n    return mediaError;\n  }\n\n  if (status >= 500) {\n    /**\n     * @TODO We plausibly should have some basic retry logic for all other 500 status\n     * cases (CJP)\n     **/\n    const mediaError = new MediaError('', mediaErrorCode, fatal ?? true);\n    mediaError.errorCategory = category;\n    mediaError.muxCode = MuxErrorCode.NETWORK_UNKNOWN_ERROR;\n    /** @TODO Add error msg + context crud here (NOT YET DEFINED) (CJP) */\n    return mediaError;\n  }\n\n  if (status === 403) {\n    if (jwtObj) {\n      if (isJWTExpired(jwtObj, requestTime)) {\n        const dateOptions: any = {\n          timeStyle: 'medium',\n          dateStyle: 'medium',\n        };\n        // E.g. for DRM: \"The videos secured drm-token has expired.\"\n        // E.g. for Video: \"The videos secured playback-token has expired.\"\n        const message = i18n(`The videos secured {tokenNamePrefix}-token has expired.`, translate).format({\n          tokenNamePrefix,\n        });\n        const context = i18n(`Expired at: {expiredDate}. Current time: {currentDate}.`, translate).format({\n          expiredDate: new Intl.DateTimeFormat('en', dateOptions).format(jwtObj.exp ?? 0 * 1000),\n          currentDate: new Intl.DateTimeFormat('en', dateOptions).format(requestTime),\n        });\n        const mediaError = new MediaError(message, mediaErrorCode, true, context);\n        mediaError.errorCategory = category;\n        mediaError.muxCode = MuxErrorCode.NETWORK_TOKEN_EXPIRED;\n        mediaError.data = resp;\n        return mediaError;\n      }\n      if (isJWTSubMismatch(jwtObj, playbackId)) {\n        const message = i18n(\n          `The videos playback ID does not match the one encoded in the {tokenNamePrefix}-token.`,\n          translate\n        ).format({\n          tokenNamePrefix,\n        });\n        const context = i18n(\n          `Specified playback ID: {playbackId} and the playback ID encoded in the {tokenNamePrefix}-token: {tokenPlaybackId}`,\n          translate\n        ).format({\n          tokenNamePrefix,\n          playbackId,\n          tokenPlaybackId: jwtObj.sub,\n        });\n        const mediaError = new MediaError(message, mediaErrorCode, true, context);\n        mediaError.errorCategory = category;\n        mediaError.muxCode = MuxErrorCode.NETWORK_TOKEN_SUB_MISMATCH;\n        mediaError.data = resp;\n        return mediaError;\n      }\n      if (isJWTAudMissing(jwtObj, expectedAud)) {\n        const message = i18n(`The {tokenNamePrefix}-token is formatted with incorrect information.`, translate).format({\n          tokenNamePrefix,\n        });\n        const context = i18n(\n          `The {tokenNamePrefix}-token has no aud value. aud value should be {expectedAud}.`,\n          translate\n        ).format({\n          tokenNamePrefix,\n          expectedAud,\n        });\n        const mediaError = new MediaError(message, mediaErrorCode, true, context);\n        mediaError.errorCategory = category;\n        mediaError.muxCode = MuxErrorCode.NETWORK_TOKEN_AUD_MISSING;\n        mediaError.data = resp;\n        return mediaError;\n      }\n      if (isJWTAudMismatch(jwtObj, expectedAud)) {\n        const message = i18n(`The {tokenNamePrefix}-token is formatted with incorrect information.`, translate).format({\n          tokenNamePrefix,\n        });\n        const context = i18n(\n          `The {tokenNamePrefix}-token has an incorrect aud value: {aud}. aud value should be {expectedAud}.`,\n          translate\n        ).format({\n          tokenNamePrefix,\n          expectedAud,\n          aud: jwtObj.aud,\n        });\n        const mediaError = new MediaError(message, mediaErrorCode, true, context);\n        mediaError.errorCategory = category;\n        mediaError.muxCode = MuxErrorCode.NETWORK_TOKEN_AUD_MISMATCH;\n        mediaError.data = resp;\n        return mediaError;\n      }\n\n      // NOTE: This *should* not happen for DRM, since the drm token\n      // is currently used to detect whether or not DRM should\n      // be setup at all. Including for exhaustiveness. (CJP)\n    } else {\n      const message = i18n(\n        `Authorization error trying to access this {category} URL. If this is a signed URL, you might need to provide a {tokenNamePrefix}-token.`,\n        translate\n      ).format({\n        tokenNamePrefix,\n        category,\n      });\n      const context = i18n(`Specified playback ID: {playbackId}`, translate).format({ playbackId });\n      const mediaError = new MediaError(message, mediaErrorCode, fatal ?? true, context);\n      mediaError.errorCategory = category;\n      mediaError.muxCode = MuxErrorCode.NETWORK_TOKEN_MISSING;\n      mediaError.data = resp;\n      return mediaError;\n    }\n  }\n\n  if (status === 412) {\n    const message = i18n(\n      `This playback-id may belong to a live stream that is not currently active or an asset that is not ready.`,\n      translate\n    );\n    const context = i18n(`Specified playback ID: {playbackId}`, translate).format({ playbackId });\n    const mediaError = new MediaError(message, mediaErrorCode, fatal ?? true, context);\n    mediaError.errorCategory = category;\n    mediaError.muxCode = MuxErrorCode.NETWORK_NOT_READY;\n    mediaError.streamType =\n      muxMediaEl.streamType === StreamTypes.LIVE\n        ? 'live'\n        : muxMediaEl.streamType === StreamTypes.ON_DEMAND\n          ? 'on-demand'\n          : 'unknown';\n    mediaError.data = resp;\n    return mediaError;\n  }\n\n  /**\n   * NOTE: When using a \"structurally valid but non-existent\" playback id for a DRM (license or app certificate) request, this will result in a 403 status.\n   * However, since we will only currently make a DRM request after successfully loading the media, this case should not need\n   * to be accounted for. If we ever eagerly fetch FPS app certs prior to or in parallel to media requests, we would potentially\n   * want to account for that case (either by normalizing statuses, in our messaging for generic 403 above, or through more complex\n   * solutions like waiting for the media response). (CJP)\n   */\n  if (status === 404) {\n    // NOTE: This *should* not happen for DRM (only playback/media requests), since the URL should never be invalid if code\n    // is correct. Aka if we end up here it's almost definitely a bug.\n    const message = i18n(\n      `This URL or playback-id does not exist. You may have used an Asset ID or an ID from a different resource.`,\n      translate\n    );\n    const context = i18n(`Specified playback ID: {playbackId}`, translate).format({ playbackId });\n    const mediaError = new MediaError(message, mediaErrorCode, fatal ?? true, context);\n    mediaError.errorCategory = category;\n    mediaError.muxCode = MuxErrorCode.NETWORK_NOT_FOUND;\n    mediaError.data = resp;\n    return mediaError;\n  }\n\n  /**\n   * NOTE: Omitting a token for a DRM (license or app certificate) request results in a 400 status, unlike playback/media requests,\n   * which are a 403 status (See above).\n   * However, since we will only currently setup Mux Player for DRM if a drm token is provided, this case should not need\n   * to be accounted for. If we ever change this, we would potentially\n   * want to account for that case (either by normalizing statuses, in our messaging for generic 400 above, or through more complex\n   * solutions like checking the category before deciding on error details here). (CJP)\n   */\n  if (status === 400) {\n    const message = i18n(`The URL or playback-id was invalid. You may have used an invalid value as a playback-id.`);\n    const context = i18n(`Specified playback ID: {playbackId}`, translate).format({ playbackId });\n    const mediaError = new MediaError(message, mediaErrorCode, fatal ?? true, context);\n    mediaError.errorCategory = category;\n    mediaError.muxCode = MuxErrorCode.NETWORK_INVALID_URL;\n    mediaError.data = resp;\n    return mediaError;\n  }\n\n  const mediaError = new MediaError('', mediaErrorCode, fatal ?? true);\n  mediaError.errorCategory = category;\n  mediaError.muxCode = MuxErrorCode.NETWORK_UNKNOWN_ERROR;\n  mediaError.data = resp;\n  return mediaError;\n};\n","import Hls from './hls';\nimport type { HlsInterface } from './hls';\nimport type { Level } from 'hls.js';\nimport type { MaxAutoResolutionValue } from './types';\n\n// The hls.js commonJS module doesn't export CapLevelController, so get it from the default config.\nconst CapLevelController = Hls.DefaultConfig.capLevelController;\n\n/**\n * Resolution pricing tiers based on total pixels (width * height)\n * Values align with Mux Video pricing tiers: https://www.mux.com/docs/pricing/video#resolution-based-pricing\n */\nconst RESOLUTION_PIXEL_LIMITS: Record<string, number> = {\n  '720p': 921600, // Up to 921,600 pixels (1280x720)\n  '1080p': 2073600, // Up to 2,073,600 pixels (1920x1080)\n  '1440p': 4194304, // Up to 4,194,304 pixels (2560x1440)\n  '2160p': 8294400, // Up to 8,294,400 pixels (3840x2160)\n};\n\n/**\n * Convert resolution string to maximum total pixels\n * Only accepts predefined tiers from the list\n */\nfunction resolutionToMaxPixels(resolution: string): number | undefined {\n  const normalized = resolution.toLowerCase().trim();\n\n  return RESOLUTION_PIXEL_LIMITS[normalized];\n}\n\n/**\n * A custom HLS.js CapLevelController that behaves like the default one, except\n * it enforces a \"minimum maximum\" to avoid forced capping to lower quality at small sizes\n */\nclass MinCapLevelController extends CapLevelController {\n  // Never cap below this level.\n  static minMaxResolution = 720;\n  private static maxAutoResolution = new WeakMap<HlsInterface, MaxAutoResolutionValue>();\n\n  constructor(hls: HlsInterface) {\n    super(hls);\n  }\n\n  static setMaxAutoResolution(hls: HlsInterface, maxAutoResolution: MaxAutoResolutionValue | undefined) {\n    if (maxAutoResolution) {\n      MinCapLevelController.maxAutoResolution.set(hls, maxAutoResolution);\n    } else {\n      MinCapLevelController.maxAutoResolution.delete(hls);\n    }\n  }\n\n  private getMaxAutoResolution(): MaxAutoResolutionValue | undefined {\n    // NOTE: hls is a TS-private member in CapLevelController. Should be TS-protected\n    // @ts-ignore\n    const hlsInstance = this.hls;\n    return MinCapLevelController.maxAutoResolution.get(hlsInstance) ?? undefined;\n  }\n\n  get levels() {\n    // NOTE: hls is a TS-private member in CapLevelController. Should be TS-protected (CJP)\n    // @ts-ignore\n    return (this.hls.levels ?? []) as Level[];\n  }\n\n  getValidLevels(capLevelIndex: number) {\n    return this.levels.filter(\n      // NOTE: isLevelAllowed is a TS-private member in CapLevelController. Should be TS-protected (CJP)\n      // @ts-ignore\n      (level, index) => this.isLevelAllowed(level) && index <= capLevelIndex\n    );\n  }\n\n  /**\n   * Get the maximum level capped to maxAutoResolution\n   *\n   * Selection logic (in order of priority):\n   * 1. If there's an exact match for maxAutoResolution, use it\n   * 2. If no exact match exists, always select the highest quality that doesn't exceed the cap\n   *    (to prevent extra costs by going over the resolution limit)\n   */\n  private getMaxLevelCapped(capLevelIndex: number): number {\n    const validLevels = this.getValidLevels(capLevelIndex);\n    const maxAutoResolution = this.getMaxAutoResolution();\n\n    if (!maxAutoResolution) {\n      return super.getMaxLevel(capLevelIndex);\n    }\n\n    // Convert resolution string to maximum total pixels\n    const maxPixels = resolutionToMaxPixels(maxAutoResolution);\n    if (!maxPixels) {\n      // Invalid resolution string, fallback to default behavior\n      return super.getMaxLevel(capLevelIndex);\n    }\n\n    // Compare by total pixels (width * height) to match Mux Video pricing tiers\n    // Find levels that don't exceed the cap (total pixels <= maxPixels)\n    const levelsWithinCap = validLevels.filter((level) => {\n      const totalPixels = level.width * level.height;\n      return totalPixels <= maxPixels;\n    });\n\n    // Check if there's an exact match first (total pixels === maxPixels)\n    const exactMatch = levelsWithinCap.findIndex((level) => {\n      const totalPixels = level.width * level.height;\n      return totalPixels === maxPixels;\n    });\n\n    if (exactMatch !== -1) {\n      const exactLevel = levelsWithinCap[exactMatch];\n      return validLevels.findIndex((level) => level === exactLevel);\n    }\n\n    // No exact match - always select the highest quality that doesn't exceed the cap\n    if (levelsWithinCap.length === 0) {\n      // No levels within cap, return the lowest level\n      return 0;\n    }\n    // Return the highest quality within cap (last item, since levels are ordered from lowest to highest)\n    const highestQualityWithinCap = levelsWithinCap[levelsWithinCap.length - 1];\n    return validLevels.findIndex((level) => level === highestQualityWithinCap);\n  }\n\n  getMaxLevel(capLevelIndex: number) {\n    if (this.getMaxAutoResolution() !== undefined) {\n      return this.getMaxLevelCapped(capLevelIndex);\n    }\n\n    const baseMaxLevel = super.getMaxLevel(capLevelIndex);\n    const validLevels = this.getValidLevels(capLevelIndex);\n\n    // Default maxLevel selection ended up out of bounds to indicate e.g. no capping/no levels available (yet), so use it\n    if (!validLevels[baseMaxLevel]) return baseMaxLevel;\n\n    const baseMaxLevelResolution = Math.min(validLevels[baseMaxLevel].width, validLevels[baseMaxLevel].height);\n    const preferredMinMaxResolution = MinCapLevelController.minMaxResolution;\n\n    // Default maxLevel selection already meets our conditions, so use it\n    if (baseMaxLevelResolution >= preferredMinMaxResolution) return baseMaxLevel;\n\n    // Default maxLevel selection is below the preferred \"min max\", so find the lowest level\n    // that is >= the preference. We can simply repurpose CapLevelController:getMaxLevelByMediaSize()\n    // for this, \"lying\" about the element's size.\n    // NOTE: Since CapLevelController:getMaxLevelByMediaSize() uses \"max square size\" under the hood\n    // already, we don't need to duplicate that logic here.\n    const maxLevel = CapLevelController.getMaxLevelByMediaSize(\n      validLevels,\n      preferredMinMaxResolution * (16 / 9),\n      preferredMinMaxResolution\n    );\n\n    return maxLevel;\n  }\n}\n\nexport default MinCapLevelController;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}