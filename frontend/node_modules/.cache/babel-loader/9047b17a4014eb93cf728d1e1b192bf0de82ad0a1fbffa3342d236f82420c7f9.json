{"ast":null,"code":"import { percent, mixNumber } from 'motion-dom';\nimport { scalePoint } from './delta-apply.mjs';\n\n/**\n * Remove a delta from a point. This is essentially the steps of applyPointDelta in reverse\n */\nfunction removePointDelta(point, translate, scale, originPoint, boxScale) {\n  point -= translate;\n  point = scalePoint(point, 1 / scale, originPoint);\n  if (boxScale !== undefined) {\n    point = scalePoint(point, 1 / boxScale, originPoint);\n  }\n  return point;\n}\n/**\n * Remove a delta from an axis. This is essentially the steps of applyAxisDelta in reverse\n */\nfunction removeAxisDelta(axis) {\n  let translate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  let scale = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  let origin = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0.5;\n  let boxScale = arguments.length > 4 ? arguments[4] : undefined;\n  let originAxis = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : axis;\n  let sourceAxis = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : axis;\n  if (percent.test(translate)) {\n    translate = parseFloat(translate);\n    const relativeProgress = mixNumber(sourceAxis.min, sourceAxis.max, translate / 100);\n    translate = relativeProgress - sourceAxis.min;\n  }\n  if (typeof translate !== \"number\") return;\n  let originPoint = mixNumber(originAxis.min, originAxis.max, origin);\n  if (axis === originAxis) originPoint -= translate;\n  axis.min = removePointDelta(axis.min, translate, scale, originPoint, boxScale);\n  axis.max = removePointDelta(axis.max, translate, scale, originPoint, boxScale);\n}\n/**\n * Remove a transforms from an axis. This is essentially the steps of applyAxisTransforms in reverse\n * and acts as a bridge between motion values and removeAxisDelta\n */\nfunction removeAxisTransforms(axis, transforms, _ref, origin, sourceAxis) {\n  let [key, scaleKey, originKey] = _ref;\n  removeAxisDelta(axis, transforms[key], transforms[scaleKey], transforms[originKey], transforms.scale, origin, sourceAxis);\n}\n/**\n * The names of the motion values we want to apply as translation, scale and origin.\n */\nconst xKeys = [\"x\", \"scaleX\", \"originX\"];\nconst yKeys = [\"y\", \"scaleY\", \"originY\"];\n/**\n * Remove a transforms from an box. This is essentially the steps of applyAxisBox in reverse\n * and acts as a bridge between motion values and removeAxisDelta\n */\nfunction removeBoxTransforms(box, transforms, originBox, sourceBox) {\n  removeAxisTransforms(box.x, transforms, xKeys, originBox ? originBox.x : undefined, sourceBox ? sourceBox.x : undefined);\n  removeAxisTransforms(box.y, transforms, yKeys, originBox ? originBox.y : undefined, sourceBox ? sourceBox.y : undefined);\n}\nexport { removeAxisDelta, removeAxisTransforms, removeBoxTransforms, removePointDelta };","map":{"version":3,"names":["removePointDelta","point","translate","scale","originPoint","boxScale","scalePoint","undefined","removeAxisDelta","axis","arguments","length","origin","originAxis","sourceAxis","percent","test","parseFloat","relativeProgress","mixNumber","min","max","removeAxisTransforms","transforms","_ref","key","scaleKey","originKey","xKeys","yKeys","removeBoxTransforms","box","originBox","sourceBox","x","y"],"sources":["/app/frontend/node_modules/framer-motion/src/projection/geometry/delta-remove.ts"],"sourcesContent":["import { mixNumber, percent } from \"motion-dom\"\nimport { Axis, Box } from \"motion-utils\"\nimport { ResolvedValues } from \"../../render/types\"\nimport { scalePoint } from \"./delta-apply\"\n\n/**\n * Remove a delta from a point. This is essentially the steps of applyPointDelta in reverse\n */\nexport function removePointDelta(\n    point: number,\n    translate: number,\n    scale: number,\n    originPoint: number,\n    boxScale?: number\n): number {\n    point -= translate\n    point = scalePoint(point, 1 / scale, originPoint)\n\n    if (boxScale !== undefined) {\n        point = scalePoint(point, 1 / boxScale, originPoint)\n    }\n\n    return point\n}\n\n/**\n * Remove a delta from an axis. This is essentially the steps of applyAxisDelta in reverse\n */\nexport function removeAxisDelta(\n    axis: Axis,\n    translate: number | string = 0,\n    scale: number = 1,\n    origin: number = 0.5,\n    boxScale?: number,\n    originAxis: Axis = axis,\n    sourceAxis: Axis = axis\n): void {\n    if (percent.test(translate)) {\n        translate = parseFloat(translate as string)\n        const relativeProgress = mixNumber(\n            sourceAxis.min,\n            sourceAxis.max,\n            translate / 100\n        )\n        translate = relativeProgress - sourceAxis.min\n    }\n\n    if (typeof translate !== \"number\") return\n\n    let originPoint = mixNumber(originAxis.min, originAxis.max, origin)\n    if (axis === originAxis) originPoint -= translate\n\n    axis.min = removePointDelta(\n        axis.min,\n        translate,\n        scale,\n        originPoint,\n        boxScale\n    )\n\n    axis.max = removePointDelta(\n        axis.max,\n        translate,\n        scale,\n        originPoint,\n        boxScale\n    )\n}\n\n/**\n * Remove a transforms from an axis. This is essentially the steps of applyAxisTransforms in reverse\n * and acts as a bridge between motion values and removeAxisDelta\n */\nexport function removeAxisTransforms(\n    axis: Axis,\n    transforms: ResolvedValues,\n    [key, scaleKey, originKey]: string[],\n    origin?: Axis,\n    sourceAxis?: Axis\n) {\n    removeAxisDelta(\n        axis,\n        transforms[key] as number,\n        transforms[scaleKey] as number,\n        transforms[originKey] as number,\n        transforms.scale as number,\n        origin,\n        sourceAxis\n    )\n}\n\n/**\n * The names of the motion values we want to apply as translation, scale and origin.\n */\nconst xKeys = [\"x\", \"scaleX\", \"originX\"]\nconst yKeys = [\"y\", \"scaleY\", \"originY\"]\n\n/**\n * Remove a transforms from an box. This is essentially the steps of applyAxisBox in reverse\n * and acts as a bridge between motion values and removeAxisDelta\n */\nexport function removeBoxTransforms(\n    box: Box,\n    transforms: ResolvedValues,\n    originBox?: Box,\n    sourceBox?: Box\n): void {\n    removeAxisTransforms(\n        box.x,\n        transforms,\n        xKeys,\n        originBox ? originBox.x : undefined,\n        sourceBox ? sourceBox.x : undefined\n    )\n    removeAxisTransforms(\n        box.y,\n        transforms,\n        yKeys,\n        originBox ? originBox.y : undefined,\n        sourceBox ? sourceBox.y : undefined\n    )\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}