{"ast":null,"code":"/**\n * Super Media Element\n * Based on https://github.com/muxinc/custom-video-element - Mux - MIT License\n *\n * The goal is to create an element that works just like the video element\n * but can be extended/sub-classed, because native elements cannot be\n * extended today across browsers. Support for extending async loaded video\n * like API's. e.g. video players.\n */\n\n// The onevent like props are weirdly set on the HTMLElement prototype with other\n// generic events making it impossible to pick these specific to HTMLMediaElement.\nexport const Events = ['abort', 'canplay', 'canplaythrough', 'durationchange', 'emptied', 'encrypted', 'ended', 'error', 'loadeddata', 'loadedmetadata', 'loadstart', 'pause', 'play', 'playing', 'progress', 'ratechange', 'seeked', 'seeking', 'stalled', 'suspend', 'timeupdate', 'volumechange', 'waiting', 'waitingforkey', 'resize', 'enterpictureinpicture', 'leavepictureinpicture', 'webkitbeginfullscreen', 'webkitendfullscreen', 'webkitpresentationmodechanged'];\nexport const template = globalThis.document?.createElement('template');\nif (template) {\n  template.innerHTML = /*html*/`\n    <style>\n      :host {\n        display: inline-block;\n        line-height: 0;\n      }\n\n      video,\n      audio {\n        max-width: 100%;\n        max-height: 100%;\n        min-width: 100%;\n        min-height: 100%;\n      }\n    </style>\n    <slot></slot>\n  `;\n}\n\n/**\n * @see https://justinfagnani.com/2015/12/21/real-mixins-with-javascript-classes/\n */\nexport const SuperMediaMixin = (superclass, {\n  tag,\n  is\n}) => {\n  const nativeElTest = globalThis.document?.createElement(tag, {\n    is\n  });\n  const nativeElProps = nativeElTest ? getNativeElProps(nativeElTest) : [];\n  return class SuperMedia extends superclass {\n    static Events = Events;\n    static template = template;\n    static skipAttributes = [];\n    static #isDefined;\n    static get observedAttributes() {\n      SuperMedia.#define();\n\n      // Include any attributes from the custom built-in.\n      const natAttrs = nativeElTest?.constructor?.observedAttributes ?? [];\n      return [...natAttrs, 'autopictureinpicture', 'disablepictureinpicture', 'disableremoteplayback', 'autoplay', 'controls', 'controlslist', 'crossorigin', 'loop', 'muted', 'playsinline', 'poster', 'preload', 'src'];\n    }\n    static #define() {\n      if (this.#isDefined) return;\n      this.#isDefined = true;\n      const propsToAttrs = new Set(this.observedAttributes);\n      // defaultMuted maps to the muted attribute, handled manually below.\n      propsToAttrs.delete('muted');\n\n      // Passthrough native el functions from the custom el to the native el\n      for (let prop of nativeElProps) {\n        if (prop in this.prototype) continue;\n        const type = typeof nativeElTest[prop];\n        if (type == 'function') {\n          // Function\n          this.prototype[prop] = function (...args) {\n            this.#init();\n            const fn = () => {\n              if (this.call) return this.call(prop, ...args);\n              return this.nativeEl[prop].apply(this.nativeEl, args);\n            };\n            if (this.loadComplete && !this.isLoaded) {\n              return this.loadComplete.then(fn);\n            }\n            return fn();\n          };\n        } else {\n          // Some properties like src, preload, defaultMuted are handled manually.\n\n          // Getter\n          let config = {\n            get() {\n              this.#init();\n              let attr = prop.toLowerCase();\n              if (propsToAttrs.has(attr)) {\n                const val = this.getAttribute(attr);\n                return val === null ? false : val === '' ? true : val;\n              }\n              return this.get?.(prop) ?? this.nativeEl?.[prop] ?? this.#standinEl[prop];\n            }\n          };\n          if (prop !== prop.toUpperCase()) {\n            // Setter (not a CONSTANT)\n            config.set = async function (val) {\n              this.#init();\n              let attr = prop.toLowerCase();\n              if (propsToAttrs.has(attr)) {\n                if (val === true || val === false || val == null) {\n                  this.toggleAttribute(attr, Boolean(val));\n                } else {\n                  this.setAttribute(attr, val);\n                }\n                return;\n              }\n              if (this.loadComplete && !this.isLoaded) await this.loadComplete;\n              if (this.set) {\n                this.set(prop, val);\n                return;\n              }\n              this.nativeEl[prop] = val;\n            };\n          }\n          Object.defineProperty(this.prototype, prop, config);\n        }\n      }\n    }\n    #isInit;\n    #loadComplete;\n    #hasLoaded = false;\n    #isLoaded = false;\n    #nativeEl;\n    #standinEl;\n    constructor() {\n      super();\n      if (!this.shadowRoot) {\n        this.attachShadow({\n          mode: 'open'\n        });\n        this.shadowRoot.append(this.constructor.template.content.cloneNode(true));\n      }\n\n      // If a load method is provided in the child class create a load promise.\n      if (this.load !== SuperMedia.prototype.load) {\n        this.loadComplete = new PublicPromise();\n      }\n\n      // If the custom element is defined before the custom element's HTML is parsed\n      // no attributes will be available in the constructor (construction process).\n      // Wait until initializing in the attributeChangedCallback or\n      // connectedCallback or accessing any properties.\n    }\n    get loadComplete() {\n      return this.#loadComplete;\n    }\n    set loadComplete(promise) {\n      this.#isLoaded = false;\n      this.#loadComplete = promise;\n      promise?.then(() => {\n        this.#isLoaded = true;\n      });\n    }\n    get isLoaded() {\n      return this.#isLoaded;\n    }\n    get nativeEl() {\n      return this.#nativeEl ?? this.shadowRoot.querySelector(tag) ?? this.querySelector(tag);\n    }\n    set nativeEl(val) {\n      this.#nativeEl = val;\n    }\n    get defaultMuted() {\n      return this.hasAttribute('muted');\n    }\n    set defaultMuted(val) {\n      this.toggleAttribute('muted', Boolean(val));\n    }\n    get src() {\n      return this.getAttribute('src');\n    }\n    set src(val) {\n      this.setAttribute('src', `${val}`);\n    }\n    get preload() {\n      return this.getAttribute('preload') ?? this.nativeEl?.preload;\n    }\n    set preload(val) {\n      this.setAttribute('preload', `${val}`);\n    }\n    async #init() {\n      if (this.#isInit) return;\n      this.#isInit = true;\n      this.#initStandinEl();\n      this.#initNativeEl();\n      for (let prop of nativeElProps) this.#upgradeProperty(prop);\n\n      // Keep some native child elements like track and source in sync.\n      const childMap = new Map();\n      // An unnamed <slot> will be filled with all of the custom element's\n      // top-level child nodes that do not have the slot attribute.\n      const slotEl = this.shadowRoot.querySelector('slot:not([name])');\n      slotEl?.addEventListener('slotchange', () => {\n        const removeNativeChildren = new Map(childMap);\n        slotEl.assignedElements().filter(el => ['track', 'source'].includes(el.localName)).forEach(async el => {\n          // If the source or track is still in the assigned elements keep it.\n          removeNativeChildren.delete(el);\n          // Re-use clones if possible.\n          let clone = childMap.get(el);\n          if (!clone) {\n            clone = el.cloneNode();\n            childMap.set(el, clone);\n          }\n          if (this.loadComplete && !this.isLoaded) await this.loadComplete;\n          this.nativeEl.append?.(clone);\n        });\n        removeNativeChildren.forEach(el => el.remove());\n      });\n\n      // The video events are dispatched on the SuperMediaElement instance.\n      // This makes it possible to add event listeners before the element is upgraded.\n      for (let type of this.constructor.Events) {\n        this.shadowRoot.addEventListener?.(type, evt => {\n          if (evt.target !== this.nativeEl) return;\n          this.dispatchEvent(new CustomEvent(evt.type, {\n            detail: evt.detail\n          }));\n        }, true);\n      }\n    }\n    #upgradeProperty(prop) {\n      // Sets properties that are set before the custom element is upgraded.\n      // https://web.dev/custom-elements-best-practices/#make-properties-lazy\n      if (Object.prototype.hasOwnProperty.call(this, prop)) {\n        const value = this[prop];\n        // Delete the set property from this instance.\n        delete this[prop];\n        // Set the value again via the (prototype) setter on this class.\n        this[prop] = value;\n      }\n    }\n    #initStandinEl() {\n      // Neither Chrome or Firefox support setting the muted attribute\n      // after using document.createElement.\n      // Get around this by setting the muted property manually.\n      const dummyEl = document.createElement(tag, {\n        is\n      });\n      dummyEl.muted = this.hasAttribute('muted');\n      for (let {\n        name,\n        value\n      } of this.attributes) {\n        dummyEl.setAttribute(name, value);\n      }\n      this.#standinEl = {};\n      for (let name of getNativeElProps(dummyEl)) {\n        this.#standinEl[name] = dummyEl[name];\n      }\n\n      // unload dummy video element\n      dummyEl.removeAttribute('src');\n      dummyEl.load();\n    }\n    async #initNativeEl() {\n      if (this.loadComplete && !this.isLoaded) await this.loadComplete;\n\n      // If there is no nativeEl by now, create it our bloody selves.\n      if (!this.nativeEl) {\n        const nativeEl = document.createElement(tag, {\n          is\n        });\n        nativeEl.part = tag;\n        this.shadowRoot.append(nativeEl);\n      }\n\n      // Neither Chrome or Firefox support setting the muted attribute\n      // after using document.createElement.\n      // Get around this by setting the muted property manually.\n      this.nativeEl.muted = this.hasAttribute('muted');\n    }\n    attributeChangedCallback(attrName, oldValue, newValue) {\n      // Initialize right after construction when the attributes become available.\n      this.#init();\n\n      // Only call loadSrc when the super class has a load method.\n      if (attrName === 'src' && this.load !== SuperMedia.prototype.load) {\n        this.#loadSrc();\n      }\n      this.#forwardAttribute(attrName, oldValue, newValue);\n    }\n    async #loadSrc() {\n      // The first time we use the Promise created in the constructor.\n      if (this.#hasLoaded) this.loadComplete = new PublicPromise();\n      this.#hasLoaded = true;\n\n      // Wait 1 tick to allow other attributes to be set.\n      await Promise.resolve();\n      await this.load();\n      this.loadComplete?.resolve();\n      await this.loadComplete;\n    }\n    async #forwardAttribute(attrName, oldValue, newValue) {\n      if (this.loadComplete && !this.isLoaded) await this.loadComplete;\n\n      // Ignore a few that don't need to be passed & skipped attributes.\n      // e.g. src: native element is using MSE and has a blob url as src attribute.\n      if (['id', 'class', ...this.constructor.skipAttributes].includes(attrName)) {\n        return;\n      }\n      if (newValue === null) {\n        this.nativeEl.removeAttribute?.(attrName);\n      } else {\n        this.nativeEl.setAttribute?.(attrName, newValue);\n      }\n    }\n    connectedCallback() {\n      this.#init();\n    }\n  };\n};\nfunction getNativeElProps(nativeElTest) {\n  // Map all native element properties to the custom element\n  // so that they're applied to the native element.\n  // Skipping HTMLElement because of things like \"attachShadow\"\n  // causing issues. Most of those props still need to apply to\n  // the custom element.\n  let nativeElProps = [];\n\n  // Walk the prototype chain up to HTMLElement.\n  // This will grab all super class props in between.\n  // i.e. VideoElement and MediaElement\n  for (let proto = Object.getPrototypeOf(nativeElTest); proto && proto !== HTMLElement.prototype; proto = Object.getPrototypeOf(proto)) {\n    nativeElProps.push(...Object.getOwnPropertyNames(proto));\n  }\n  return nativeElProps;\n}\n\n/**\n * A utility to create Promises with convenient public resolve and reject methods.\n * @return {Promise}\n */\nclass PublicPromise extends Promise {\n  constructor(executor = () => {}) {\n    let res, rej;\n    super((resolve, reject) => {\n      executor(resolve, reject);\n      res = resolve;\n      rej = reject;\n    });\n    this.resolve = res;\n    this.reject = rej;\n  }\n}\nexport const SuperVideoElement = globalThis.document ? SuperMediaMixin(HTMLElement, {\n  tag: 'video'\n}) : class {};\nexport const SuperAudioElement = globalThis.document ? SuperMediaMixin(HTMLElement, {\n  tag: 'audio'\n}) : class {};","map":{"version":3,"names":["Events","template","globalThis","document","createElement","innerHTML","SuperMediaMixin","superclass","tag","is","nativeElTest","nativeElProps","getNativeElProps","SuperMedia","skipAttributes","isDefined","observedAttributes","define","natAttrs","constructor","#define","propsToAttrs","Set","delete","prop","prototype","type","args","init","fn","call","nativeEl","apply","loadComplete","isLoaded","then","config","get","attr","toLowerCase","has","val","getAttribute","standinEl","toUpperCase","set","toggleAttribute","Boolean","setAttribute","Object","defineProperty","isInit","hasLoaded","shadowRoot","attachShadow","mode","append","content","cloneNode","load","PublicPromise","promise","querySelector","defaultMuted","hasAttribute","src","preload","#init","initStandinEl","initNativeEl","upgradeProperty","childMap","Map","slotEl","addEventListener","removeNativeChildren","assignedElements","filter","el","includes","localName","forEach","clone","remove","evt","target","dispatchEvent","CustomEvent","detail","#upgradeProperty","hasOwnProperty","value","#initStandinEl","dummyEl","muted","name","attributes","removeAttribute","#initNativeEl","part","attributeChangedCallback","attrName","oldValue","newValue","loadSrc","forwardAttribute","#loadSrc","Promise","resolve","#forwardAttribute","connectedCallback","proto","getPrototypeOf","HTMLElement","push","getOwnPropertyNames","executor","res","rej","reject","SuperVideoElement","SuperAudioElement"],"sources":["/app/frontend/node_modules/super-media-element/super-media-element.js"],"sourcesContent":["/**\n * Super Media Element\n * Based on https://github.com/muxinc/custom-video-element - Mux - MIT License\n *\n * The goal is to create an element that works just like the video element\n * but can be extended/sub-classed, because native elements cannot be\n * extended today across browsers. Support for extending async loaded video\n * like API's. e.g. video players.\n */\n\n// The onevent like props are weirdly set on the HTMLElement prototype with other\n// generic events making it impossible to pick these specific to HTMLMediaElement.\nexport const Events = [\n  'abort',\n  'canplay',\n  'canplaythrough',\n  'durationchange',\n  'emptied',\n  'encrypted',\n  'ended',\n  'error',\n  'loadeddata',\n  'loadedmetadata',\n  'loadstart',\n  'pause',\n  'play',\n  'playing',\n  'progress',\n  'ratechange',\n  'seeked',\n  'seeking',\n  'stalled',\n  'suspend',\n  'timeupdate',\n  'volumechange',\n  'waiting',\n  'waitingforkey',\n  'resize',\n  'enterpictureinpicture',\n  'leavepictureinpicture',\n  'webkitbeginfullscreen',\n  'webkitendfullscreen',\n  'webkitpresentationmodechanged',\n];\n\nexport const template = globalThis.document?.createElement('template');\n\nif (template) {\n  template.innerHTML = /*html*/`\n    <style>\n      :host {\n        display: inline-block;\n        line-height: 0;\n      }\n\n      video,\n      audio {\n        max-width: 100%;\n        max-height: 100%;\n        min-width: 100%;\n        min-height: 100%;\n      }\n    </style>\n    <slot></slot>\n  `;\n}\n\n/**\n * @see https://justinfagnani.com/2015/12/21/real-mixins-with-javascript-classes/\n */\nexport const SuperMediaMixin = (superclass, { tag, is }) => {\n\n  const nativeElTest = globalThis.document?.createElement(tag, { is });\n  const nativeElProps = nativeElTest ? getNativeElProps(nativeElTest) : [];\n\n  return class SuperMedia extends superclass {\n    static Events = Events;\n    static template = template;\n    static skipAttributes = [];\n    static #isDefined;\n\n    static get observedAttributes() {\n      SuperMedia.#define();\n\n      // Include any attributes from the custom built-in.\n      const natAttrs = nativeElTest?.constructor?.observedAttributes ?? [];\n\n      return [\n        ...natAttrs,\n        'autopictureinpicture',\n        'disablepictureinpicture',\n        'disableremoteplayback',\n        'autoplay',\n        'controls',\n        'controlslist',\n        'crossorigin',\n        'loop',\n        'muted',\n        'playsinline',\n        'poster',\n        'preload',\n        'src',\n      ];\n    }\n\n    static #define() {\n      if (this.#isDefined) return;\n      this.#isDefined = true;\n\n      const propsToAttrs = new Set(this.observedAttributes);\n      // defaultMuted maps to the muted attribute, handled manually below.\n      propsToAttrs.delete('muted');\n\n      // Passthrough native el functions from the custom el to the native el\n      for (let prop of nativeElProps) {\n        if (prop in this.prototype) continue;\n\n        const type = typeof nativeElTest[prop];\n        if (type == 'function') {\n          // Function\n          this.prototype[prop] = function (...args) {\n            this.#init();\n\n            const fn = () => {\n              if (this.call) return this.call(prop, ...args);\n              return this.nativeEl[prop].apply(this.nativeEl, args);\n            };\n\n            if (this.loadComplete && !this.isLoaded) {\n              return this.loadComplete.then(fn);\n            }\n            return fn();\n          };\n        } else {\n          // Some properties like src, preload, defaultMuted are handled manually.\n\n          // Getter\n          let config = {\n            get() {\n              this.#init();\n\n              let attr = prop.toLowerCase();\n              if (propsToAttrs.has(attr)) {\n                const val = this.getAttribute(attr);\n                return val === null ? false : val === '' ? true : val;\n              }\n\n              return this.get?.(prop) ?? this.nativeEl?.[prop] ?? this.#standinEl[prop];\n            },\n          };\n\n          if (prop !== prop.toUpperCase()) {\n            // Setter (not a CONSTANT)\n            config.set = async function (val) {\n              this.#init();\n\n              let attr = prop.toLowerCase();\n              if (propsToAttrs.has(attr)) {\n                if (val === true || val === false || val == null) {\n                  this.toggleAttribute(attr, Boolean(val));\n                } else {\n                  this.setAttribute(attr, val);\n                }\n                return;\n              }\n\n              if (this.loadComplete && !this.isLoaded) await this.loadComplete;\n\n              if (this.set) {\n                this.set(prop, val);\n                return;\n              }\n\n              this.nativeEl[prop] = val;\n            };\n          }\n\n          Object.defineProperty(this.prototype, prop, config);\n        }\n      }\n    }\n\n    #isInit;\n    #loadComplete;\n    #hasLoaded = false;\n    #isLoaded = false;\n    #nativeEl;\n    #standinEl;\n\n    constructor() {\n      super();\n\n      if (!this.shadowRoot) {\n        this.attachShadow({ mode: 'open' });\n        this.shadowRoot.append(this.constructor.template.content.cloneNode(true));\n      }\n\n      // If a load method is provided in the child class create a load promise.\n      if (this.load !== SuperMedia.prototype.load) {\n        this.loadComplete = new PublicPromise();\n      }\n\n      // If the custom element is defined before the custom element's HTML is parsed\n      // no attributes will be available in the constructor (construction process).\n      // Wait until initializing in the attributeChangedCallback or\n      // connectedCallback or accessing any properties.\n    }\n\n    get loadComplete() {\n      return this.#loadComplete;\n    }\n\n    set loadComplete(promise) {\n      this.#isLoaded = false;\n      this.#loadComplete = promise;\n      promise?.then(() => {\n        this.#isLoaded = true;\n      });\n    }\n\n    get isLoaded() {\n      return this.#isLoaded;\n    }\n\n    get nativeEl() {\n      return this.#nativeEl\n        ?? this.shadowRoot.querySelector(tag)\n        ?? this.querySelector(tag);\n    }\n\n    set nativeEl(val) {\n      this.#nativeEl = val;\n    }\n\n    get defaultMuted() {\n      return this.hasAttribute('muted');\n    }\n\n    set defaultMuted(val) {\n      this.toggleAttribute('muted', Boolean(val));\n    }\n\n    get src() {\n      return this.getAttribute('src');\n    }\n\n    set src(val) {\n      this.setAttribute('src', `${val}`);\n    }\n\n    get preload() {\n      return this.getAttribute('preload') ?? this.nativeEl?.preload;\n    }\n\n    set preload(val) {\n      this.setAttribute('preload', `${val}`);\n    }\n\n    async #init() {\n      if (this.#isInit) return;\n      this.#isInit = true;\n\n      this.#initStandinEl();\n      this.#initNativeEl();\n\n      for (let prop of nativeElProps)\n        this.#upgradeProperty(prop);\n\n      // Keep some native child elements like track and source in sync.\n      const childMap = new Map();\n      // An unnamed <slot> will be filled with all of the custom element's\n      // top-level child nodes that do not have the slot attribute.\n      const slotEl = this.shadowRoot.querySelector('slot:not([name])');\n      slotEl?.addEventListener('slotchange', () => {\n        const removeNativeChildren = new Map(childMap);\n        slotEl\n          .assignedElements()\n          .filter((el) => ['track', 'source'].includes(el.localName))\n          .forEach(async (el) => {\n            // If the source or track is still in the assigned elements keep it.\n            removeNativeChildren.delete(el);\n            // Re-use clones if possible.\n            let clone = childMap.get(el);\n            if (!clone) {\n              clone = el.cloneNode();\n              childMap.set(el, clone);\n            }\n            if (this.loadComplete && !this.isLoaded) await this.loadComplete;\n            this.nativeEl.append?.(clone);\n          });\n        removeNativeChildren.forEach((el) => el.remove());\n      });\n\n      // The video events are dispatched on the SuperMediaElement instance.\n      // This makes it possible to add event listeners before the element is upgraded.\n      for (let type of this.constructor.Events) {\n        this.shadowRoot.addEventListener?.(type, (evt) => {\n          if (evt.target !== this.nativeEl) return;\n          this.dispatchEvent(new CustomEvent(evt.type, { detail: evt.detail }));\n        }, true);\n      }\n    }\n\n    #upgradeProperty(prop) {\n      // Sets properties that are set before the custom element is upgraded.\n      // https://web.dev/custom-elements-best-practices/#make-properties-lazy\n      if (Object.prototype.hasOwnProperty.call(this, prop)) {\n        const value = this[prop];\n        // Delete the set property from this instance.\n        delete this[prop];\n        // Set the value again via the (prototype) setter on this class.\n        this[prop] = value;\n      }\n    }\n\n    #initStandinEl() {\n      // Neither Chrome or Firefox support setting the muted attribute\n      // after using document.createElement.\n      // Get around this by setting the muted property manually.\n      const dummyEl = document.createElement(tag, { is });\n      dummyEl.muted = this.hasAttribute('muted');\n\n      for (let { name, value } of this.attributes) {\n        dummyEl.setAttribute(name, value);\n      }\n\n      this.#standinEl = {};\n      for (let name of getNativeElProps(dummyEl)) {\n        this.#standinEl[name] = dummyEl[name];\n      }\n\n      // unload dummy video element\n      dummyEl.removeAttribute('src');\n      dummyEl.load();\n    }\n\n    async #initNativeEl() {\n      if (this.loadComplete && !this.isLoaded) await this.loadComplete;\n\n      // If there is no nativeEl by now, create it our bloody selves.\n      if (!this.nativeEl) {\n        const nativeEl = document.createElement(tag, { is });\n        nativeEl.part = tag;\n        this.shadowRoot.append(nativeEl);\n      }\n\n      // Neither Chrome or Firefox support setting the muted attribute\n      // after using document.createElement.\n      // Get around this by setting the muted property manually.\n      this.nativeEl.muted = this.hasAttribute('muted');\n    }\n\n    attributeChangedCallback(attrName, oldValue, newValue) {\n      // Initialize right after construction when the attributes become available.\n      this.#init();\n\n      // Only call loadSrc when the super class has a load method.\n      if (attrName === 'src' && this.load !== SuperMedia.prototype.load) {\n        this.#loadSrc();\n      }\n\n      this.#forwardAttribute(attrName, oldValue, newValue);\n    }\n\n    async #loadSrc() {\n      // The first time we use the Promise created in the constructor.\n      if (this.#hasLoaded) this.loadComplete = new PublicPromise();\n      this.#hasLoaded = true;\n\n      // Wait 1 tick to allow other attributes to be set.\n      await Promise.resolve();\n      await this.load();\n\n      this.loadComplete?.resolve();\n      await this.loadComplete;\n    }\n\n    async #forwardAttribute(attrName, oldValue, newValue) {\n      if (this.loadComplete && !this.isLoaded) await this.loadComplete;\n\n      // Ignore a few that don't need to be passed & skipped attributes.\n      // e.g. src: native element is using MSE and has a blob url as src attribute.\n      if (['id', 'class', ...this.constructor.skipAttributes].includes(attrName)) {\n        return;\n      }\n\n      if (newValue === null) {\n        this.nativeEl.removeAttribute?.(attrName);\n      } else {\n        this.nativeEl.setAttribute?.(attrName, newValue);\n      }\n    }\n\n    connectedCallback() {\n      this.#init();\n    }\n  };\n};\n\nfunction getNativeElProps(nativeElTest) {\n  // Map all native element properties to the custom element\n  // so that they're applied to the native element.\n  // Skipping HTMLElement because of things like \"attachShadow\"\n  // causing issues. Most of those props still need to apply to\n  // the custom element.\n  let nativeElProps = [];\n\n  // Walk the prototype chain up to HTMLElement.\n  // This will grab all super class props in between.\n  // i.e. VideoElement and MediaElement\n  for (\n    let proto = Object.getPrototypeOf(nativeElTest);\n    proto && proto !== HTMLElement.prototype;\n    proto = Object.getPrototypeOf(proto)\n  ) {\n    nativeElProps.push(...Object.getOwnPropertyNames(proto));\n  }\n\n  return nativeElProps;\n}\n\n/**\n * A utility to create Promises with convenient public resolve and reject methods.\n * @return {Promise}\n */\nclass PublicPromise extends Promise {\n  constructor(executor = () => {}) {\n    let res, rej;\n    super((resolve, reject) => {\n      executor(resolve, reject);\n      res = resolve;\n      rej = reject;\n    });\n    this.resolve = res;\n    this.reject = rej;\n  }\n}\n\nexport const SuperVideoElement = globalThis.document ? SuperMediaMixin(HTMLElement, { tag: 'video' }) : class {};\n\nexport const SuperAudioElement = globalThis.document ? SuperMediaMixin(HTMLElement, { tag: 'audio' }) : class {};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}