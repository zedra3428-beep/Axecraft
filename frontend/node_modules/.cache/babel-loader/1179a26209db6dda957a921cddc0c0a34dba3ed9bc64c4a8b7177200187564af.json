{"ast":null,"code":"import _objectSpread from \"/app/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { resolveVariant } from '../../render/utils/resolve-dynamic-variants.mjs';\nimport { calcChildStagger } from '../utils/calc-child-stagger.mjs';\nimport { animateTarget } from './visual-element-target.mjs';\nfunction animateVariant(visualElement, variant) {\n  var _visualElement$presen;\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const resolved = resolveVariant(visualElement, variant, options.type === \"exit\" ? (_visualElement$presen = visualElement.presenceContext) === null || _visualElement$presen === void 0 ? void 0 : _visualElement$presen.custom : undefined);\n  let {\n    transition = visualElement.getDefaultTransition() || {}\n  } = resolved || {};\n  if (options.transitionOverride) {\n    transition = options.transitionOverride;\n  }\n  /**\n   * If we have a variant, create a callback that runs it as an animation.\n   * Otherwise, we resolve a Promise immediately for a composable no-op.\n   */\n  const getAnimation = resolved ? () => Promise.all(animateTarget(visualElement, resolved, options)) : () => Promise.resolve();\n  /**\n   * If we have children, create a callback that runs all their animations.\n   * Otherwise, we resolve a Promise immediately for a composable no-op.\n   */\n  const getChildAnimations = visualElement.variantChildren && visualElement.variantChildren.size ? function () {\n    let forwardDelay = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    const {\n      delayChildren = 0,\n      staggerChildren,\n      staggerDirection\n    } = transition;\n    return animateChildren(visualElement, variant, forwardDelay, delayChildren, staggerChildren, staggerDirection, options);\n  } : () => Promise.resolve();\n  /**\n   * If the transition explicitly defines a \"when\" option, we need to resolve either\n   * this animation or all children animations before playing the other.\n   */\n  const {\n    when\n  } = transition;\n  if (when) {\n    const [first, last] = when === \"beforeChildren\" ? [getAnimation, getChildAnimations] : [getChildAnimations, getAnimation];\n    return first().then(() => last());\n  } else {\n    return Promise.all([getAnimation(), getChildAnimations(options.delay)]);\n  }\n}\nfunction animateChildren(visualElement, variant) {\n  let delay = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  let delayChildren = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n  let staggerChildren = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n  let staggerDirection = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 1;\n  let options = arguments.length > 6 ? arguments[6] : undefined;\n  const animations = [];\n  for (const child of visualElement.variantChildren) {\n    child.notify(\"AnimationStart\", variant);\n    animations.push(animateVariant(child, variant, _objectSpread(_objectSpread({}, options), {}, {\n      delay: delay + (typeof delayChildren === \"function\" ? 0 : delayChildren) + calcChildStagger(visualElement.variantChildren, child, delayChildren, staggerChildren, staggerDirection)\n    })).then(() => child.notify(\"AnimationComplete\", variant)));\n  }\n  return Promise.all(animations);\n}\nexport { animateVariant };","map":{"version":3,"names":["animateVariant","visualElement","variant","_visualElement$presen","options","arguments","length","undefined","resolved","resolveVariant","type","presenceContext","custom","transition","getDefaultTransition","transitionOverride","getAnimation","Promise","all","animateTarget","resolve","getChildAnimations","variantChildren","size","forwardDelay","delayChildren","staggerChildren","staggerDirection","animateChildren","when","first","last","then","delay","animations","child","notify","push","_objectSpread","calcChildStagger"],"sources":["/app/frontend/node_modules/framer-motion/src/animation/interfaces/visual-element-variant.ts"],"sourcesContent":["import { DynamicOption } from \"motion-dom\"\nimport { resolveVariant } from \"../../render/utils/resolve-dynamic-variants\"\nimport { VisualElement } from \"../../render/VisualElement\"\nimport { calcChildStagger } from \"../utils/calc-child-stagger\"\nimport { VisualElementAnimationOptions } from \"./types\"\nimport { animateTarget } from \"./visual-element-target\"\n\nexport function animateVariant(\n    visualElement: VisualElement,\n    variant: string,\n    options: VisualElementAnimationOptions = {}\n): Promise<any> {\n    const resolved = resolveVariant(\n        visualElement,\n        variant,\n        options.type === \"exit\"\n            ? visualElement.presenceContext?.custom\n            : undefined\n    )\n\n    let { transition = visualElement.getDefaultTransition() || {} } =\n        resolved || {}\n\n    if (options.transitionOverride) {\n        transition = options.transitionOverride\n    }\n\n    /**\n     * If we have a variant, create a callback that runs it as an animation.\n     * Otherwise, we resolve a Promise immediately for a composable no-op.\n     */\n    const getAnimation: () => Promise<any> = resolved\n        ? () => Promise.all(animateTarget(visualElement, resolved, options))\n        : () => Promise.resolve()\n\n    /**\n     * If we have children, create a callback that runs all their animations.\n     * Otherwise, we resolve a Promise immediately for a composable no-op.\n     */\n    const getChildAnimations =\n        visualElement.variantChildren && visualElement.variantChildren.size\n            ? (forwardDelay = 0) => {\n                  const {\n                      delayChildren = 0,\n                      staggerChildren,\n                      staggerDirection,\n                  } = transition\n\n                  return animateChildren(\n                      visualElement,\n                      variant,\n                      forwardDelay,\n                      delayChildren,\n                      staggerChildren,\n                      staggerDirection,\n                      options\n                  )\n              }\n            : () => Promise.resolve()\n\n    /**\n     * If the transition explicitly defines a \"when\" option, we need to resolve either\n     * this animation or all children animations before playing the other.\n     */\n    const { when } = transition\n    if (when) {\n        const [first, last] =\n            when === \"beforeChildren\"\n                ? [getAnimation, getChildAnimations]\n                : [getChildAnimations, getAnimation]\n\n        return first().then(() => last())\n    } else {\n        return Promise.all([getAnimation(), getChildAnimations(options.delay)])\n    }\n}\n\nfunction animateChildren(\n    visualElement: VisualElement,\n    variant: string,\n    delay: number = 0,\n    delayChildren: number | DynamicOption<number> = 0,\n    staggerChildren = 0,\n    staggerDirection = 1,\n    options: VisualElementAnimationOptions\n) {\n    const animations: Promise<any>[] = []\n\n    for (const child of visualElement.variantChildren!) {\n        child.notify(\"AnimationStart\", variant)\n        animations.push(\n            animateVariant(child, variant, {\n                ...options,\n                delay:\n                    delay +\n                    (typeof delayChildren === \"function\" ? 0 : delayChildren) +\n                    calcChildStagger(\n                        visualElement.variantChildren!,\n                        child,\n                        delayChildren,\n                        staggerChildren,\n                        staggerDirection\n                    ),\n            }).then(() => child.notify(\"AnimationComplete\", variant))\n        )\n    }\n\n    return Promise.all(animations)\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}