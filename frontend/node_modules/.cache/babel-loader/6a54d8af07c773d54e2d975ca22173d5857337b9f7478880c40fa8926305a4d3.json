{"ast":null,"code":"\"use client\";\n\nimport { useContext, useRef, useInsertionEffect, useEffect } from 'react';\nimport { optimizedAppearDataAttribute } from '../../animation/optimized-appear/data-id.mjs';\nimport { LazyContext } from '../../context/LazyContext.mjs';\nimport { MotionConfigContext } from '../../context/MotionConfigContext.mjs';\nimport { MotionContext } from '../../context/MotionContext/index.mjs';\nimport { PresenceContext } from '../../context/PresenceContext.mjs';\nimport { SwitchLayoutGroupContext } from '../../context/SwitchLayoutGroupContext.mjs';\nimport { isRefObject } from '../../utils/is-ref-object.mjs';\nimport { useIsomorphicLayoutEffect } from '../../utils/use-isomorphic-effect.mjs';\nfunction useVisualElement(Component, visualState, props, createVisualElement, ProjectionNodeConstructor, isSVG) {\n  var _window$MotionHandoff, _window, _window$MotionHasOpti, _window2;\n  const {\n    visualElement: parent\n  } = useContext(MotionContext);\n  const lazyContext = useContext(LazyContext);\n  const presenceContext = useContext(PresenceContext);\n  const reducedMotionConfig = useContext(MotionConfigContext).reducedMotion;\n  const visualElementRef = useRef(null);\n  /**\n   * If we haven't preloaded a renderer, check to see if we have one lazy-loaded\n   */\n  createVisualElement = createVisualElement || lazyContext.renderer;\n  if (!visualElementRef.current && createVisualElement) {\n    visualElementRef.current = createVisualElement(Component, {\n      visualState,\n      parent,\n      props,\n      presenceContext,\n      blockInitialAnimation: presenceContext ? presenceContext.initial === false : false,\n      reducedMotionConfig,\n      isSVG\n    });\n  }\n  const visualElement = visualElementRef.current;\n  /**\n   * Load Motion gesture and animation features. These are rendered as renderless\n   * components so each feature can optionally make use of React lifecycle methods.\n   */\n  const initialLayoutGroupConfig = useContext(SwitchLayoutGroupContext);\n  if (visualElement && !visualElement.projection && ProjectionNodeConstructor && (visualElement.type === \"html\" || visualElement.type === \"svg\")) {\n    createProjectionNode(visualElementRef.current, props, ProjectionNodeConstructor, initialLayoutGroupConfig);\n  }\n  const isMounted = useRef(false);\n  useInsertionEffect(() => {\n    /**\n     * Check the component has already mounted before calling\n     * `update` unnecessarily. This ensures we skip the initial update.\n     */\n    if (visualElement && isMounted.current) {\n      visualElement.update(props, presenceContext);\n    }\n  });\n  /**\n   * Cache this value as we want to know whether HandoffAppearAnimations\n   * was present on initial render - it will be deleted after this.\n   */\n  const optimisedAppearId = props[optimizedAppearDataAttribute];\n  const wantsHandoff = useRef(Boolean(optimisedAppearId) && !((_window$MotionHandoff = (_window = window).MotionHandoffIsComplete) !== null && _window$MotionHandoff !== void 0 && _window$MotionHandoff.call(_window, optimisedAppearId)) && ((_window$MotionHasOpti = (_window2 = window).MotionHasOptimisedAnimation) === null || _window$MotionHasOpti === void 0 ? void 0 : _window$MotionHasOpti.call(_window2, optimisedAppearId)));\n  useIsomorphicLayoutEffect(() => {\n    if (!visualElement) return;\n    isMounted.current = true;\n    window.MotionIsMounted = true;\n    visualElement.updateFeatures();\n    visualElement.scheduleRenderMicrotask();\n    /**\n     * Ideally this function would always run in a useEffect.\n     *\n     * However, if we have optimised appear animations to handoff from,\n     * it needs to happen synchronously to ensure there's no flash of\n     * incorrect styles in the event of a hydration error.\n     *\n     * So if we detect a situtation where optimised appear animations\n     * are running, we use useLayoutEffect to trigger animations.\n     */\n    if (wantsHandoff.current && visualElement.animationState) {\n      visualElement.animationState.animateChanges();\n    }\n  });\n  useEffect(() => {\n    if (!visualElement) return;\n    if (!wantsHandoff.current && visualElement.animationState) {\n      visualElement.animationState.animateChanges();\n    }\n    if (wantsHandoff.current) {\n      // This ensures all future calls to animateChanges() in this component will run in useEffect\n      queueMicrotask(() => {\n        var _window$MotionHandoff2, _window3;\n        (_window$MotionHandoff2 = (_window3 = window).MotionHandoffMarkAsComplete) === null || _window$MotionHandoff2 === void 0 || _window$MotionHandoff2.call(_window3, optimisedAppearId);\n      });\n      wantsHandoff.current = false;\n    }\n    /**\n     * Now we've finished triggering animations for this element we\n     * can wipe the enteringChildren set for the next render.\n     */\n    visualElement.enteringChildren = undefined;\n  });\n  return visualElement;\n}\nfunction createProjectionNode(visualElement, props, ProjectionNodeConstructor, initialPromotionConfig) {\n  const {\n    layoutId,\n    layout,\n    drag,\n    dragConstraints,\n    layoutScroll,\n    layoutRoot,\n    layoutCrossfade\n  } = props;\n  visualElement.projection = new ProjectionNodeConstructor(visualElement.latestValues, props[\"data-framer-portal-id\"] ? undefined : getClosestProjectingNode(visualElement.parent));\n  visualElement.projection.setOptions({\n    layoutId,\n    layout,\n    alwaysMeasureLayout: Boolean(drag) || dragConstraints && isRefObject(dragConstraints),\n    visualElement,\n    /**\n     * TODO: Update options in an effect. This could be tricky as it'll be too late\n     * to update by the time layout animations run.\n     * We also need to fix this safeToRemove by linking it up to the one returned by usePresence,\n     * ensuring it gets called if there's no potential layout animations.\n     *\n     */\n    animationType: typeof layout === \"string\" ? layout : \"both\",\n    initialPromotionConfig,\n    crossfade: layoutCrossfade,\n    layoutScroll,\n    layoutRoot\n  });\n}\nfunction getClosestProjectingNode(visualElement) {\n  if (!visualElement) return undefined;\n  return visualElement.options.allowProjection !== false ? visualElement.projection : getClosestProjectingNode(visualElement.parent);\n}\nexport { useVisualElement };","map":{"version":3,"names":["useVisualElement","Component","visualState","props","createVisualElement","ProjectionNodeConstructor","isSVG","_window$MotionHandoff","_window","_window$MotionHasOpti","_window2","lazyContext","useContext","LazyContext","presenceContext","PresenceContext","visualElementRef","useRef","current","blockInitialAnimation","initial","visualElement","initialLayoutGroupConfig","SwitchLayoutGroupContext","type","isMounted","update","optimisedAppearId","optimizedAppearDataAttribute","wantsHandoff","Boolean","window","MotionHandoffIsComplete","call","MotionHasOptimisedAnimation","MotionIsMounted","animationState","animateChanges","_window$MotionHandoff2","_window3","MotionHandoffMarkAsComplete","enteringChildren","undefined","createProjectionNode","initialPromotionConfig","layoutId","layout","drag","dragConstraints","layoutScroll","layoutRoot","layoutCrossfade","projection","latestValues","setOptions","alwaysMeasureLayout","isRefObject","animationType","crossfade","getClosestProjectingNode","options","allowProjection","parent"],"sources":["/app/frontend/node_modules/framer-motion/src/motion/utils/use-visual-element.ts"],"sourcesContent":["\"use client\"\n\nimport * as React from \"react\"\nimport { useContext, useEffect, useInsertionEffect, useRef } from \"react\"\nimport { optimizedAppearDataAttribute } from \"../../animation/optimized-appear/data-id\"\nimport { LazyContext } from \"../../context/LazyContext\"\nimport { MotionConfigContext } from \"../../context/MotionConfigContext\"\nimport { MotionContext } from \"../../context/MotionContext\"\nimport { PresenceContext } from \"../../context/PresenceContext\"\nimport {\n    InitialPromotionConfig,\n    SwitchLayoutGroupContext,\n} from \"../../context/SwitchLayoutGroupContext\"\nimport { MotionProps } from \"../../motion/types\"\nimport { IProjectionNode } from \"../../projection/node/types\"\nimport { DOMMotionComponents } from \"../../render/dom/types\"\nimport { HTMLRenderState } from \"../../render/html/types\"\nimport { SVGRenderState } from \"../../render/svg/types\"\nimport { CreateVisualElement } from \"../../render/types\"\nimport type { VisualElement } from \"../../render/VisualElement\"\nimport { isRefObject } from \"../../utils/is-ref-object\"\nimport { useIsomorphicLayoutEffect } from \"../../utils/use-isomorphic-effect\"\nimport { VisualState } from \"./use-visual-state\"\n\nexport function useVisualElement<\n    Props,\n    TagName extends keyof DOMMotionComponents | string\n>(\n    Component: TagName | string | React.ComponentType<Props>,\n    visualState:\n        | VisualState<SVGElement, SVGRenderState>\n        | VisualState<HTMLElement, HTMLRenderState>,\n    props: MotionProps & Partial<MotionConfigContext>,\n    createVisualElement?: CreateVisualElement<Props, TagName>,\n    ProjectionNodeConstructor?: any,\n    isSVG?: boolean\n): VisualElement<HTMLElement | SVGElement> | undefined {\n    const { visualElement: parent } = useContext(MotionContext)\n    const lazyContext = useContext(LazyContext)\n    const presenceContext = useContext(PresenceContext)\n    const reducedMotionConfig = useContext(MotionConfigContext).reducedMotion\n\n    const visualElementRef = useRef<VisualElement<\n        HTMLElement | SVGElement\n    > | null>(null)\n\n    /**\n     * If we haven't preloaded a renderer, check to see if we have one lazy-loaded\n     */\n    createVisualElement =\n        createVisualElement ||\n        (lazyContext.renderer as CreateVisualElement<Props, TagName>)\n\n    if (!visualElementRef.current && createVisualElement) {\n        visualElementRef.current = createVisualElement(Component, {\n            visualState,\n            parent,\n            props,\n            presenceContext,\n            blockInitialAnimation: presenceContext\n                ? presenceContext.initial === false\n                : false,\n            reducedMotionConfig,\n            isSVG,\n        })\n    }\n\n    const visualElement = visualElementRef.current\n\n    /**\n     * Load Motion gesture and animation features. These are rendered as renderless\n     * components so each feature can optionally make use of React lifecycle methods.\n     */\n    const initialLayoutGroupConfig = useContext(SwitchLayoutGroupContext)\n\n    if (\n        visualElement &&\n        !visualElement.projection &&\n        ProjectionNodeConstructor &&\n        (visualElement.type === \"html\" || visualElement.type === \"svg\")\n    ) {\n        createProjectionNode(\n            visualElementRef.current!,\n            props,\n            ProjectionNodeConstructor,\n            initialLayoutGroupConfig\n        )\n    }\n\n    const isMounted = useRef(false)\n    useInsertionEffect(() => {\n        /**\n         * Check the component has already mounted before calling\n         * `update` unnecessarily. This ensures we skip the initial update.\n         */\n        if (visualElement && isMounted.current) {\n            visualElement.update(props, presenceContext)\n        }\n    })\n\n    /**\n     * Cache this value as we want to know whether HandoffAppearAnimations\n     * was present on initial render - it will be deleted after this.\n     */\n    const optimisedAppearId =\n        props[optimizedAppearDataAttribute as keyof typeof props]\n    const wantsHandoff = useRef(\n        Boolean(optimisedAppearId) &&\n            !window.MotionHandoffIsComplete?.(optimisedAppearId) &&\n            window.MotionHasOptimisedAnimation?.(optimisedAppearId)\n    )\n\n    useIsomorphicLayoutEffect(() => {\n        if (!visualElement) return\n\n        isMounted.current = true\n        window.MotionIsMounted = true\n\n        visualElement.updateFeatures()\n        visualElement.scheduleRenderMicrotask()\n\n        /**\n         * Ideally this function would always run in a useEffect.\n         *\n         * However, if we have optimised appear animations to handoff from,\n         * it needs to happen synchronously to ensure there's no flash of\n         * incorrect styles in the event of a hydration error.\n         *\n         * So if we detect a situtation where optimised appear animations\n         * are running, we use useLayoutEffect to trigger animations.\n         */\n        if (wantsHandoff.current && visualElement.animationState) {\n            visualElement.animationState.animateChanges()\n        }\n    })\n\n    useEffect(() => {\n        if (!visualElement) return\n\n        if (!wantsHandoff.current && visualElement.animationState) {\n            visualElement.animationState.animateChanges()\n        }\n\n        if (wantsHandoff.current) {\n            // This ensures all future calls to animateChanges() in this component will run in useEffect\n            queueMicrotask(() => {\n                window.MotionHandoffMarkAsComplete?.(optimisedAppearId)\n            })\n\n            wantsHandoff.current = false\n        }\n\n        /**\n         * Now we've finished triggering animations for this element we\n         * can wipe the enteringChildren set for the next render.\n         */\n        visualElement.enteringChildren = undefined\n    })\n\n    return visualElement!\n}\n\nfunction createProjectionNode(\n    visualElement: VisualElement<any>,\n    props: MotionProps,\n    ProjectionNodeConstructor: any,\n    initialPromotionConfig?: InitialPromotionConfig\n) {\n    const {\n        layoutId,\n        layout,\n        drag,\n        dragConstraints,\n        layoutScroll,\n        layoutRoot,\n        layoutCrossfade,\n    } = props\n\n    visualElement.projection = new ProjectionNodeConstructor(\n        visualElement.latestValues,\n        props[\"data-framer-portal-id\"]\n            ? undefined\n            : getClosestProjectingNode(visualElement.parent)\n    ) as IProjectionNode\n\n    visualElement.projection.setOptions({\n        layoutId,\n        layout,\n        alwaysMeasureLayout:\n            Boolean(drag) || (dragConstraints && isRefObject(dragConstraints)),\n        visualElement,\n        /**\n         * TODO: Update options in an effect. This could be tricky as it'll be too late\n         * to update by the time layout animations run.\n         * We also need to fix this safeToRemove by linking it up to the one returned by usePresence,\n         * ensuring it gets called if there's no potential layout animations.\n         *\n         */\n        animationType: typeof layout === \"string\" ? layout : \"both\",\n        initialPromotionConfig,\n        crossfade: layoutCrossfade,\n        layoutScroll,\n        layoutRoot,\n    })\n}\n\nfunction getClosestProjectingNode(\n    visualElement?: VisualElement<\n        unknown,\n        unknown,\n        { allowProjection?: boolean }\n    >\n): IProjectionNode | undefined {\n    if (!visualElement) return undefined\n\n    return visualElement.options.allowProjection !== false\n        ? visualElement.projection\n        : getClosestProjectingNode(visualElement.parent)\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}