{"ast":null,"code":"/* global chrome */\nimport { RemotePlayback } from './castable-remote-playback.js';\nimport { privateProps, requiresCastFramework, loadCastFramework, currentSession, getDefaultCastOptions, isHls, getPlaylistSegmentFormat } from './castable-utils.js';\n\n/**\n * CastableMediaMixin\n *\n * This mixin function provides a way to compose multiple classes.\n * @see https://justinfagnani.com/2015/12/21/real-mixins-with-javascript-classes/\n *\n * @param  {HTMLMediaElement} superclass - HTMLMediaElement or an extended class of it.\n * @return {CastableMedia}\n */\nexport const CastableMediaMixin = superclass => class CastableMedia extends superclass {\n  static observedAttributes = [...(superclass.observedAttributes ?? []), 'cast-src', 'cast-content-type', 'cast-stream-type', 'cast-receiver'];\n  #localState = {\n    paused: false\n  };\n  #castOptions = getDefaultCastOptions();\n  #castCustomData;\n  #remote;\n  get remote() {\n    if (this.#remote) return this.#remote;\n    if (requiresCastFramework()) {\n      // No need to load the Cast framework if it's disabled.\n      if (!this.disableRemotePlayback) {\n        loadCastFramework();\n      }\n      privateProps.set(this, {\n        loadOnPrompt: () => this.#loadOnPrompt()\n      });\n      return this.#remote = new RemotePlayback(this);\n    }\n    return super.remote;\n  }\n  get #castPlayer() {\n    return privateProps.get(this.remote)?.getCastPlayer?.();\n  }\n  attributeChangedCallback(attrName, oldValue, newValue) {\n    super.attributeChangedCallback(attrName, oldValue, newValue);\n    if (attrName === 'cast-receiver' && newValue) {\n      this.#castOptions.receiverApplicationId = newValue;\n      return;\n    }\n    if (!this.#castPlayer) return;\n    switch (attrName) {\n      case 'cast-stream-type':\n      case 'cast-src':\n        this.load();\n        break;\n    }\n  }\n  async #loadOnPrompt() {\n    // Pause locally when the session is created.\n    this.#localState.paused = super.paused;\n    super.pause();\n\n    // Sync over the muted state but not volume, 100% is different on TV's :P\n    this.muted = super.muted;\n    try {\n      await this.load();\n    } catch (err) {\n      console.error(err);\n    }\n  }\n  async load() {\n    if (!this.#castPlayer) return super.load();\n    const mediaInfo = new chrome.cast.media.MediaInfo(this.castSrc, this.castContentType);\n    mediaInfo.customData = this.castCustomData;\n\n    // Manually add text tracks with a `src` attribute.\n    // M3U8's load text tracks in the receiver, handle these in the media loaded event.\n    const subtitles = [...this.querySelectorAll('track')].filter(({\n      kind,\n      src\n    }) => src && (kind === 'subtitles' || kind === 'captions'));\n    const activeTrackIds = [];\n    let textTrackIdCount = 0;\n    if (subtitles.length) {\n      mediaInfo.tracks = subtitles.map(trackEl => {\n        const trackId = ++textTrackIdCount;\n        // only activate 1 subtitle text track.\n        if (activeTrackIds.length === 0 && trackEl.track.mode === 'showing') {\n          activeTrackIds.push(trackId);\n        }\n        const track = new chrome.cast.media.Track(trackId, chrome.cast.media.TrackType.TEXT);\n        track.trackContentId = trackEl.src;\n        track.trackContentType = 'text/vtt';\n        track.subtype = trackEl.kind === 'captions' ? chrome.cast.media.TextTrackType.CAPTIONS : chrome.cast.media.TextTrackType.SUBTITLES;\n        track.name = trackEl.label;\n        track.language = trackEl.srclang;\n        return track;\n      });\n    }\n    if (this.castStreamType === 'live') {\n      mediaInfo.streamType = chrome.cast.media.StreamType.LIVE;\n    } else {\n      mediaInfo.streamType = chrome.cast.media.StreamType.BUFFERED;\n    }\n    mediaInfo.metadata = new chrome.cast.media.GenericMediaMetadata();\n    mediaInfo.metadata.title = this.title;\n    mediaInfo.metadata.images = [{\n      url: this.poster\n    }];\n    if (isHls(this.castSrc)) {\n      const segmentFormat = await getPlaylistSegmentFormat(this.castSrc);\n      const isFragmentedMP4 = segmentFormat?.includes('m4s') || segmentFormat?.includes('mp4');\n      if (isFragmentedMP4) {\n        mediaInfo.hlsSegmentFormat = chrome.cast.media.HlsSegmentFormat.FMP4;\n        mediaInfo.hlsVideoSegmentFormat = chrome.cast.media.HlsVideoSegmentFormat.FMP4;\n      } else if (segmentFormat?.includes('ts')) {\n        mediaInfo.hlsSegmentFormat = chrome.cast.media.HlsSegmentFormat.TS;\n        mediaInfo.hlsVideoSegmentFormat = chrome.cast.media.HlsVideoSegmentFormat.TS;\n      }\n    }\n    const request = new chrome.cast.media.LoadRequest(mediaInfo);\n    request.currentTime = super.currentTime ?? 0;\n    request.autoplay = !this.#localState.paused;\n    request.activeTrackIds = activeTrackIds;\n    await currentSession()?.loadMedia(request);\n    this.dispatchEvent(new Event('volumechange'));\n  }\n  play() {\n    if (this.#castPlayer) {\n      if (this.#castPlayer.isPaused) {\n        this.#castPlayer.controller?.playOrPause();\n      }\n      return;\n    }\n    return super.play();\n  }\n  pause() {\n    if (this.#castPlayer) {\n      if (!this.#castPlayer.isPaused) {\n        this.#castPlayer.controller?.playOrPause();\n      }\n      return;\n    }\n    super.pause();\n  }\n\n  /**\n   * @see https://developers.google.com/cast/docs/reference/web_sender/cast.framework.CastOptions\n   * @readonly\n   *\n   * @typedef {Object} CastOptions\n   * @property {string} [receiverApplicationId='CC1AD845'] - The app id of the cast receiver.\n   * @property {string} [autoJoinPolicy='origin_scoped'] - The auto join policy.\n   * @property {string} [language='en-US'] - The language to use for the cast receiver.\n   * @property {boolean} [androidReceiverCompatible=false] - Whether to use the Cast Connect.\n   * @property {boolean} [resumeSavedSession=true] - Whether to resume the last session.\n   *\n   * @return {CastOptions}\n   */\n  get castOptions() {\n    return this.#castOptions;\n  }\n  get castReceiver() {\n    return this.getAttribute('cast-receiver') ?? undefined;\n  }\n  set castReceiver(val) {\n    if (this.castReceiver == val) return;\n    this.setAttribute('cast-receiver', `${val}`);\n  }\n\n  // Allow the cast source url to be different than <video src>, could be a blob.\n  get castSrc() {\n    // Try the first <source src> for usage with even more native markup.\n    return this.getAttribute('cast-src') ?? this.querySelector('source')?.src ?? this.currentSrc;\n  }\n  set castSrc(val) {\n    if (this.castSrc == val) return;\n    this.setAttribute('cast-src', `${val}`);\n  }\n  get castContentType() {\n    return this.getAttribute('cast-content-type') ?? undefined;\n  }\n  set castContentType(val) {\n    this.setAttribute('cast-content-type', `${val}`);\n  }\n  get castStreamType() {\n    // NOTE: Per https://github.com/video-dev/media-ui-extensions/issues/3 `streamType` may yield `\"unknown\"`\n    return this.getAttribute('cast-stream-type') ?? this.streamType ?? undefined;\n  }\n  set castStreamType(val) {\n    this.setAttribute('cast-stream-type', `${val}`);\n  }\n  get castCustomData() {\n    return this.#castCustomData;\n  }\n  set castCustomData(val) {\n    const valType = typeof val;\n    if (!['object', 'undefined'].includes(valType)) {\n      console.error(`castCustomData must be nullish or an object but value was of type ${valType}`);\n      return;\n    }\n    this.#castCustomData = val;\n  }\n  get readyState() {\n    if (this.#castPlayer) {\n      switch (this.#castPlayer.playerState) {\n        case chrome.cast.media.PlayerState.IDLE:\n          return 0;\n        case chrome.cast.media.PlayerState.BUFFERING:\n          return 2;\n        default:\n          return 3;\n      }\n    }\n    return super.readyState;\n  }\n  get paused() {\n    if (this.#castPlayer) return this.#castPlayer.isPaused;\n    return super.paused;\n  }\n  get muted() {\n    if (this.#castPlayer) return this.#castPlayer?.isMuted;\n    return super.muted;\n  }\n  set muted(val) {\n    if (this.#castPlayer) {\n      if (val && !this.#castPlayer.isMuted || !val && this.#castPlayer.isMuted) {\n        this.#castPlayer.controller?.muteOrUnmute();\n      }\n      return;\n    }\n    super.muted = val;\n  }\n  get volume() {\n    if (this.#castPlayer) return this.#castPlayer?.volumeLevel ?? 1;\n    return super.volume;\n  }\n  set volume(val) {\n    if (this.#castPlayer) {\n      this.#castPlayer.volumeLevel = +val;\n      this.#castPlayer.controller?.setVolumeLevel();\n      return;\n    }\n    super.volume = val;\n  }\n  get duration() {\n    // castPlayer duration returns `0` when no media is loaded.\n    if (this.#castPlayer && this.#castPlayer?.isMediaLoaded) {\n      return this.#castPlayer?.duration ?? NaN;\n    }\n    return super.duration;\n  }\n  get currentTime() {\n    if (this.#castPlayer && this.#castPlayer?.isMediaLoaded) {\n      return this.#castPlayer?.currentTime ?? 0;\n    }\n    return super.currentTime;\n  }\n  set currentTime(val) {\n    if (this.#castPlayer) {\n      this.#castPlayer.currentTime = val;\n      this.#castPlayer.controller?.seek();\n      return;\n    }\n    super.currentTime = val;\n  }\n};\nexport const CastableVideoMixin = CastableMediaMixin;","map":{"version":3,"names":["RemotePlayback","privateProps","requiresCastFramework","loadCastFramework","currentSession","getDefaultCastOptions","isHls","getPlaylistSegmentFormat","CastableMediaMixin","superclass","CastableMedia","observedAttributes","localState","paused","castOptions","castCustomData","remote","disableRemotePlayback","set","loadOnPrompt","castPlayer","#castPlayer","get","getCastPlayer","attributeChangedCallback","attrName","oldValue","newValue","receiverApplicationId","load","#loadOnPrompt","pause","muted","err","console","error","mediaInfo","chrome","cast","media","MediaInfo","castSrc","castContentType","customData","subtitles","querySelectorAll","filter","kind","src","activeTrackIds","textTrackIdCount","length","tracks","map","trackEl","trackId","track","mode","push","Track","TrackType","TEXT","trackContentId","trackContentType","subtype","TextTrackType","CAPTIONS","SUBTITLES","name","label","language","srclang","castStreamType","streamType","StreamType","LIVE","BUFFERED","metadata","GenericMediaMetadata","title","images","url","poster","segmentFormat","isFragmentedMP4","includes","hlsSegmentFormat","HlsSegmentFormat","FMP4","hlsVideoSegmentFormat","HlsVideoSegmentFormat","TS","request","LoadRequest","currentTime","autoplay","loadMedia","dispatchEvent","Event","play","isPaused","controller","playOrPause","castReceiver","getAttribute","undefined","val","setAttribute","querySelector","currentSrc","valType","readyState","playerState","PlayerState","IDLE","BUFFERING","isMuted","muteOrUnmute","volume","volumeLevel","setVolumeLevel","duration","isMediaLoaded","NaN","seek","CastableVideoMixin"],"sources":["/app/frontend/node_modules/castable-video/castable-mixin.js"],"sourcesContent":["/* global chrome */\nimport { RemotePlayback } from './castable-remote-playback.js';\nimport {\n  privateProps,\n  requiresCastFramework,\n  loadCastFramework,\n  currentSession,\n  getDefaultCastOptions,\n  isHls,\n  getPlaylistSegmentFormat\n} from './castable-utils.js';\n\n/**\n * CastableMediaMixin\n *\n * This mixin function provides a way to compose multiple classes.\n * @see https://justinfagnani.com/2015/12/21/real-mixins-with-javascript-classes/\n *\n * @param  {HTMLMediaElement} superclass - HTMLMediaElement or an extended class of it.\n * @return {CastableMedia}\n */\nexport const CastableMediaMixin = (superclass) =>\n  class CastableMedia extends superclass {\n\n    static observedAttributes = [\n      ...(superclass.observedAttributes ?? []),\n      'cast-src',\n      'cast-content-type',\n      'cast-stream-type',\n      'cast-receiver',\n    ];\n\n    #localState = { paused: false };\n    #castOptions = getDefaultCastOptions();\n    #castCustomData;\n    #remote;\n\n    get remote() {\n      if (this.#remote) return this.#remote;\n\n      if (requiresCastFramework()) {\n        // No need to load the Cast framework if it's disabled.\n        if (!this.disableRemotePlayback) {\n          loadCastFramework();\n        }\n\n        privateProps.set(this, {\n          loadOnPrompt: () => this.#loadOnPrompt()\n        });\n\n        return (this.#remote = new RemotePlayback(this));\n      }\n\n      return super.remote;\n    }\n\n    get #castPlayer() {\n      return privateProps.get(this.remote)?.getCastPlayer?.();\n    }\n\n    attributeChangedCallback(attrName, oldValue, newValue) {\n      super.attributeChangedCallback(attrName, oldValue, newValue);\n\n      if (attrName === 'cast-receiver' && newValue) {\n        this.#castOptions.receiverApplicationId = newValue;\n        return;\n      }\n\n      if (!this.#castPlayer) return;\n\n      switch (attrName) {\n        case 'cast-stream-type':\n        case 'cast-src':\n          this.load();\n          break;\n      }\n    }\n\n    async #loadOnPrompt() {\n      // Pause locally when the session is created.\n      this.#localState.paused = super.paused;\n      super.pause();\n\n      // Sync over the muted state but not volume, 100% is different on TV's :P\n      this.muted = super.muted;\n\n      try {\n        await this.load();\n      } catch (err) {\n        console.error(err);\n      }\n    }\n\n    async load() {\n      if (!this.#castPlayer) return super.load();\n\n      const mediaInfo = new chrome.cast.media.MediaInfo(this.castSrc, this.castContentType);\n      mediaInfo.customData = this.castCustomData;\n\n      // Manually add text tracks with a `src` attribute.\n      // M3U8's load text tracks in the receiver, handle these in the media loaded event.\n      const subtitles = [...this.querySelectorAll('track')].filter(\n        ({ kind, src }) => src && (kind === 'subtitles' || kind === 'captions')\n      );\n\n      const activeTrackIds = [];\n      let textTrackIdCount = 0;\n\n      if (subtitles.length) {\n        mediaInfo.tracks = subtitles.map((trackEl) => {\n          const trackId = ++textTrackIdCount;\n          // only activate 1 subtitle text track.\n          if (activeTrackIds.length === 0 && trackEl.track.mode === 'showing') {\n            activeTrackIds.push(trackId);\n          }\n\n          const track = new chrome.cast.media.Track(\n            trackId,\n            chrome.cast.media.TrackType.TEXT\n          );\n          track.trackContentId = trackEl.src;\n          track.trackContentType = 'text/vtt';\n          track.subtype =\n            trackEl.kind === 'captions'\n              ? chrome.cast.media.TextTrackType.CAPTIONS\n              : chrome.cast.media.TextTrackType.SUBTITLES;\n          track.name = trackEl.label;\n          track.language = trackEl.srclang;\n          return track;\n        });\n      }\n\n      if (this.castStreamType === 'live') {\n        mediaInfo.streamType = chrome.cast.media.StreamType.LIVE;\n      } else {\n        mediaInfo.streamType = chrome.cast.media.StreamType.BUFFERED;\n      }\n\n      mediaInfo.metadata = new chrome.cast.media.GenericMediaMetadata();\n      mediaInfo.metadata.title = this.title;\n      mediaInfo.metadata.images = [{ url: this.poster }];\n\n      if (isHls(this.castSrc)) {\n        const segmentFormat = await getPlaylistSegmentFormat(this.castSrc);\n        const isFragmentedMP4 = segmentFormat?.includes('m4s') || segmentFormat?.includes('mp4');\n        if (isFragmentedMP4) {\n          mediaInfo.hlsSegmentFormat = chrome.cast.media.HlsSegmentFormat.FMP4;\n          mediaInfo.hlsVideoSegmentFormat = chrome.cast.media.HlsVideoSegmentFormat.FMP4;\n        } else if (segmentFormat?.includes('ts')) {\n          mediaInfo.hlsSegmentFormat = chrome.cast.media.HlsSegmentFormat.TS;\n          mediaInfo.hlsVideoSegmentFormat = chrome.cast.media.HlsVideoSegmentFormat.TS;\n        }\n      }\n\n      const request = new chrome.cast.media.LoadRequest(mediaInfo);\n      request.currentTime = super.currentTime ?? 0;\n      request.autoplay = !this.#localState.paused;\n      request.activeTrackIds = activeTrackIds;\n\n      await currentSession()?.loadMedia(request);\n\n      this.dispatchEvent(new Event('volumechange'));\n    }\n\n    play() {\n      if (this.#castPlayer) {\n        if (this.#castPlayer.isPaused) {\n          this.#castPlayer.controller?.playOrPause();\n        }\n        return;\n      }\n      return super.play();\n    }\n\n    pause() {\n      if (this.#castPlayer) {\n        if (!this.#castPlayer.isPaused) {\n          this.#castPlayer.controller?.playOrPause();\n        }\n        return;\n      }\n      super.pause();\n    }\n\n    /**\n     * @see https://developers.google.com/cast/docs/reference/web_sender/cast.framework.CastOptions\n     * @readonly\n     *\n     * @typedef {Object} CastOptions\n     * @property {string} [receiverApplicationId='CC1AD845'] - The app id of the cast receiver.\n     * @property {string} [autoJoinPolicy='origin_scoped'] - The auto join policy.\n     * @property {string} [language='en-US'] - The language to use for the cast receiver.\n     * @property {boolean} [androidReceiverCompatible=false] - Whether to use the Cast Connect.\n     * @property {boolean} [resumeSavedSession=true] - Whether to resume the last session.\n     *\n     * @return {CastOptions}\n     */\n    get castOptions() {\n      return this.#castOptions;\n    }\n\n    get castReceiver() {\n      return this.getAttribute('cast-receiver') ?? undefined;\n    }\n\n    set castReceiver(val) {\n      if (this.castReceiver == val) return;\n      this.setAttribute('cast-receiver', `${val}`);\n    }\n\n    // Allow the cast source url to be different than <video src>, could be a blob.\n    get castSrc() {\n      // Try the first <source src> for usage with even more native markup.\n      return (\n        this.getAttribute('cast-src') ??\n        this.querySelector('source')?.src ??\n        this.currentSrc\n      );\n    }\n\n    set castSrc(val) {\n      if (this.castSrc == val) return;\n      this.setAttribute('cast-src', `${val}`);\n    }\n\n    get castContentType() {\n      return this.getAttribute('cast-content-type') ?? undefined;\n    }\n\n    set castContentType(val) {\n      this.setAttribute('cast-content-type', `${val}`);\n    }\n\n    get castStreamType() {\n      // NOTE: Per https://github.com/video-dev/media-ui-extensions/issues/3 `streamType` may yield `\"unknown\"`\n      return this.getAttribute('cast-stream-type') ?? this.streamType ?? undefined;\n    }\n\n    set castStreamType(val) {\n      this.setAttribute('cast-stream-type', `${val}`);\n    }\n\n    get castCustomData() {\n      return this.#castCustomData;\n    }\n\n    set castCustomData(val) {\n      const valType = typeof val;\n      if (!['object', 'undefined'].includes(valType)) {\n        console.error(`castCustomData must be nullish or an object but value was of type ${valType}`);\n        return;\n      }\n\n      this.#castCustomData = val;\n    }\n\n    get readyState() {\n      if (this.#castPlayer) {\n        switch (this.#castPlayer.playerState) {\n          case chrome.cast.media.PlayerState.IDLE:\n            return 0;\n          case chrome.cast.media.PlayerState.BUFFERING:\n            return 2;\n          default:\n            return 3;\n        }\n      }\n      return super.readyState;\n    }\n\n    get paused() {\n      if (this.#castPlayer) return this.#castPlayer.isPaused;\n      return super.paused;\n    }\n\n    get muted() {\n      if (this.#castPlayer) return this.#castPlayer?.isMuted;\n      return super.muted;\n    }\n\n    set muted(val) {\n      if (this.#castPlayer) {\n        if (\n          (val && !this.#castPlayer.isMuted) ||\n          (!val && this.#castPlayer.isMuted)\n        ) {\n          this.#castPlayer.controller?.muteOrUnmute();\n        }\n        return;\n      }\n      super.muted = val;\n    }\n\n    get volume() {\n      if (this.#castPlayer) return this.#castPlayer?.volumeLevel ?? 1;\n      return super.volume;\n    }\n\n    set volume(val) {\n      if (this.#castPlayer) {\n        this.#castPlayer.volumeLevel = +val;\n        this.#castPlayer.controller?.setVolumeLevel();\n        return;\n      }\n      super.volume = val;\n    }\n\n    get duration() {\n      // castPlayer duration returns `0` when no media is loaded.\n      if (this.#castPlayer && this.#castPlayer?.isMediaLoaded) {\n        return this.#castPlayer?.duration ?? NaN;\n      }\n      return super.duration;\n    }\n\n    get currentTime() {\n      if (this.#castPlayer && this.#castPlayer?.isMediaLoaded) {\n        return this.#castPlayer?.currentTime ?? 0;\n      }\n      return super.currentTime;\n    }\n\n    set currentTime(val) {\n      if (this.#castPlayer) {\n        this.#castPlayer.currentTime = val;\n        this.#castPlayer.controller?.seek();\n        return;\n      }\n      super.currentTime = val;\n    }\n  };\n\nexport const CastableVideoMixin = CastableMediaMixin;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}