{"ast":null,"code":"\"use client\";\n\nimport { useRef, useInsertionEffect, useCallback } from 'react';\n\n/**\n * Creates a ref function that, when called, hydrates the provided\n * external ref and VisualElement.\n */\nfunction useMotionRef(visualState, visualElement, externalRef) {\n  /**\n   * Store externalRef in a ref to avoid including it in the useCallback\n   * dependency array. Including externalRef in dependencies causes issues\n   * with libraries like Radix UI that create new callback refs on each render\n   * when using asChild - this would cause the callback to be recreated,\n   * triggering element remounts and breaking AnimatePresence exit animations.\n   */\n  const externalRefContainer = useRef(externalRef);\n  useInsertionEffect(() => {\n    externalRefContainer.current = externalRef;\n  });\n  // Store cleanup function returned by callback refs (React 19 feature)\n  const refCleanup = useRef(null);\n  return useCallback(instance => {\n    if (instance) {\n      var _visualState$onMount;\n      (_visualState$onMount = visualState.onMount) === null || _visualState$onMount === void 0 || _visualState$onMount.call(visualState, instance);\n    }\n    if (visualElement) {\n      instance ? visualElement.mount(instance) : visualElement.unmount();\n    }\n    const ref = externalRefContainer.current;\n    if (typeof ref === \"function\") {\n      if (instance) {\n        const cleanup = ref(instance);\n        if (typeof cleanup === \"function\") {\n          refCleanup.current = cleanup;\n        }\n      } else if (refCleanup.current) {\n        refCleanup.current();\n        refCleanup.current = null;\n      } else {\n        ref(instance);\n      }\n    } else if (ref) {\n      ref.current = instance;\n    }\n  }, [visualElement]);\n}\nexport { useMotionRef };","map":{"version":3,"names":["externalRefContainer","useRef","externalRef","current","refCleanup","useCallback","instance","_visualState$onMount","visualState","onMount","call","visualElement","mount","unmount","ref","cleanup"],"sources":["/app/frontend/node_modules/framer-motion/src/motion/utils/use-motion-ref.ts"],"sourcesContent":["\"use client\"\n\nimport * as React from \"react\"\nimport { useCallback, useInsertionEffect, useRef } from \"react\"\nimport type { VisualElement } from \"../../render/VisualElement\"\nimport { VisualState } from \"./use-visual-state\"\n\n/**\n * Creates a ref function that, when called, hydrates the provided\n * external ref and VisualElement.\n */\nexport function useMotionRef<Instance, RenderState>(\n    visualState: VisualState<Instance, RenderState>,\n    visualElement?: VisualElement<Instance> | null,\n    externalRef?: React.Ref<Instance>\n): React.Ref<Instance> {\n    /**\n     * Store externalRef in a ref to avoid including it in the useCallback\n     * dependency array. Including externalRef in dependencies causes issues\n     * with libraries like Radix UI that create new callback refs on each render\n     * when using asChild - this would cause the callback to be recreated,\n     * triggering element remounts and breaking AnimatePresence exit animations.\n     */\n    const externalRefContainer = useRef(externalRef)\n    useInsertionEffect(() => {\n        externalRefContainer.current = externalRef\n    })\n\n    // Store cleanup function returned by callback refs (React 19 feature)\n    const refCleanup = useRef<(() => void) | null>(null)\n\n    return useCallback(\n        (instance: Instance) => {\n            if (instance) {\n                visualState.onMount?.(instance)\n            }\n\n            if (visualElement) {\n                instance ? visualElement.mount(instance) : visualElement.unmount()\n            }\n\n            const ref = externalRefContainer.current\n            if (typeof ref === \"function\") {\n                if (instance) {\n                    const cleanup = ref(instance)\n                    if (typeof cleanup === \"function\") {\n                        refCleanup.current = cleanup\n                    }\n                } else if (refCleanup.current) {\n                    refCleanup.current()\n                    refCleanup.current = null\n                } else {\n                    ref(instance)\n                }\n            } else if (ref) {\n                ;(ref as React.MutableRefObject<Instance>).current = instance\n            }\n        },\n        [visualElement]\n    )\n}\n"],"mappings":";;;;AAOA;;;AAGG;;EAMC;;;;;;AAMG;EACH,MAAAA,oBAAA,GAAAC,MAAA,CAAAC,WAAA;;IAEIF,oBAAA,CAAAG,OAAA,GAAAD,WAAA;EACJ;;EAGA,MAAAE,UAAA,GAAAH,MAAA;EAEA,OAAAI,WAAA,CAAAC,QAAA;;;MAGY,CAAAC,oBAAA,GAAAC,WAAA,CAAAC,OAAA,cAAAF,oBAAA,eAAAA,oBAAA,CAAAG,IAAA,CAAAF,WAAA,EAAAF,QAAA;;;MAIAA,QAAA,GAAAK,aAAA,CAAAC,KAAA,CAAAN,QAAA,IAAAK,aAAA,CAAAE,OAAA;;IAGJ,MAAAC,GAAA,GAAAd,oBAAA,CAAAG,OAAA;IACA,WAAAW,GAAA;;QAEQ,MAAAC,OAAA,GAAAD,GAAA,CAAAR,QAAA;QACA,WAAAS,OAAA;UACIX,UAAA,CAAAD,OAAA,GAAAY,OAAA;;aAED,IAAAX,UAAA,CAAAD,OAAA;;QAEHC,UAAA,CAAAD,OAAA;;;;;MAKFW,GAAA,CAAAX,OAAA,GAAAG,QAAA;;EAEV,IAAAK,aAAA;AAGR","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}